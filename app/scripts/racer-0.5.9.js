require=(function(e,t,n){function i(n,s){if(!t[n]){if(!e[n]){var o=typeof require=="function"&&require;if(!s&&o)return o(n,!0);if(r)return r(n,!0);throw new Error("Cannot find module '"+n+"'")}var u=t[n]={exports:{}};e[n][0].call(u.exports,function(t){var r=e[n][1][t];return i(r?r:t)},u,u.exports)}return t[n].exports}var r=typeof require=="function"&&require;for(var s=0;s<n.length;s++)i(n[s]);return i})({1:[function(require,module,exports){

},{}],"racer":[function(require,module,exports){
module.exports=require('NjwLal');
},{}],"NjwLal":[function(require,module,exports){
var Racer = require('./Racer');
module.exports = new Racer;

},{"./Racer":2}],3:[function(require,module,exports){
var racer = require('racer');
var BCSocket = require('browserchannel/dist/bcsocket-uncompressed').BCSocket;

racer.Model.prototype._createSocket = function(bundle) {
  var options = bundle.racerBrowserChannel;
  var base = options.base || '/channel';
  if (bundle.mount) base = bundle.mount + base;
  return new BCSocket(base, options);
};

},{"racer":"NjwLal","browserchannel/dist/bcsocket-uncompressed":4}],5:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":5}],4:[function(require,module,exports){
(function(){
function e(a) {
  throw a;
}
var h = void 0, l = !0, m = null, r = !1;
function s() {
  return function() {
  }
}
function t(a) {
  return function(b) {
    this[a] = b
  }
}
function aa(a) {
  return function() {
    return this[a]
  }
}
function ba(a) {
  return function() {
    return a
  }
}
var u, ca = ca || {}, w = this;
function da(a) {
  a = a.split(".");
  for(var b = w, c;c = a.shift();) {
    if(b[c] != m) {
      b = b[c]
    }else {
      return m
    }
  }
  return b
}
function ea() {
}
function fa(a) {
  var b = typeof a;
  if("object" == b) {
    if(a) {
      if(a instanceof Array) {
        return"array"
      }
      if(a instanceof Object) {
        return b
      }
      var c = Object.prototype.toString.call(a);
      if("[object Window]" == c) {
        return"object"
      }
      if("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) {
        return"array"
      }
      if("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) {
        return"function"
      }
    }else {
      return"null"
    }
  }else {
    if("function" == b && "undefined" == typeof a.call) {
      return"object"
    }
  }
  return b
}
function x(a) {
  return"array" == fa(a)
}
function ga(a) {
  var b = fa(a);
  return"array" == b || "object" == b && "number" == typeof a.length
}
function z(a) {
  return"string" == typeof a
}
function ha(a) {
  return"function" == fa(a)
}
function A(a) {
  return a[ia] || (a[ia] = ++ja)
}
var ia = "closure_uid_" + (1E9 * Math.random() >>> 0), ja = 0;
function ka(a, b, c) {
  return a.call.apply(a.bind, arguments)
}
function la(a, b, c) {
  a || e(Error());
  if(2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var c = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(c, d);
      return a.apply(b, c)
    }
  }
  return function() {
    return a.apply(b, arguments)
  }
}
function B(a, b, c) {
  B = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? ka : la;
  return B.apply(m, arguments)
}
var C = Date.now || function() {
  return+new Date
};
function D(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.qa = b.prototype;
  a.prototype = new c
}
;function ma(a, b) {
  for(var c = 1;c < arguments.length;c++) {
    var d = String(arguments[c]).replace(/\$/g, "$$$$");
    a = a.replace(/\%s/, d)
  }
  return a
}
function na(a) {
  if(!oa.test(a)) {
    return a
  }
  -1 != a.indexOf("&") && (a = a.replace(pa, "&amp;"));
  -1 != a.indexOf("<") && (a = a.replace(qa, "&lt;"));
  -1 != a.indexOf(">") && (a = a.replace(ra, "&gt;"));
  -1 != a.indexOf('"') && (a = a.replace(sa, "&quot;"));
  return a
}
var pa = /&/g, qa = /</g, ra = />/g, sa = /\"/g, oa = /[&<>\"]/;
var ta, ua, va, wa;
function xa() {
  return w.navigator ? w.navigator.userAgent : m
}
wa = va = ua = ta = r;
var ya;
if(ya = xa()) {
  var za = w.navigator;
  ta = 0 == ya.indexOf("Opera");
  ua = !ta && -1 != ya.indexOf("MSIE");
  va = !ta && -1 != ya.indexOf("WebKit");
  wa = !ta && !va && "Gecko" == za.product
}
var Aa = ta, E = ua, Ba = wa, F = va, Ca = w.navigator, Da = -1 != (Ca && Ca.platform || "").indexOf("Mac");
function Ea() {
  var a = w.document;
  return a ? a.documentMode : h
}
var Fa;
a: {
  var Ga = "", Ha;
  if(Aa && w.opera) {
    var Ia = w.opera.version, Ga = "function" == typeof Ia ? Ia() : Ia
  }else {
    if(Ba ? Ha = /rv\:([^\);]+)(\)|;)/ : E ? Ha = /MSIE\s+([^\);]+)(\)|;)/ : F && (Ha = /WebKit\/(\S+)/), Ha) {
      var Ja = Ha.exec(xa()), Ga = Ja ? Ja[1] : ""
    }
  }
  if(E) {
    var Ka = Ea();
    if(Ka > parseFloat(Ga)) {
      Fa = String(Ka);
      break a
    }
  }
  Fa = Ga
}
var La = {};
function G(a) {
  var b;
  if(!(b = La[a])) {
    b = 0;
    for(var c = String(Fa).replace(/^[\s\xa0]+|[\s\xa0]+$/g, "").split("."), d = String(a).replace(/^[\s\xa0]+|[\s\xa0]+$/g, "").split("."), f = Math.max(c.length, d.length), g = 0;0 == b && g < f;g++) {
      var k = c[g] || "", q = d[g] || "", n = RegExp("(\\d*)(\\D*)", "g"), y = RegExp("(\\d*)(\\D*)", "g");
      do {
        var p = n.exec(k) || ["", "", ""], v = y.exec(q) || ["", "", ""];
        if(0 == p[0].length && 0 == v[0].length) {
          break
        }
        b = ((0 == p[1].length ? 0 : parseInt(p[1], 10)) < (0 == v[1].length ? 0 : parseInt(v[1], 10)) ? -1 : (0 == p[1].length ? 0 : parseInt(p[1], 10)) > (0 == v[1].length ? 0 : parseInt(v[1], 10)) ? 1 : 0) || ((0 == p[2].length) < (0 == v[2].length) ? -1 : (0 == p[2].length) > (0 == v[2].length) ? 1 : 0) || (p[2] < v[2] ? -1 : p[2] > v[2] ? 1 : 0)
      }while(0 == b)
    }
    b = La[a] = 0 <= b
  }
  return b
}
var Ma = w.document, Na = !Ma || !E ? h : Ea() || ("CSS1Compat" == Ma.compatMode ? parseInt(Fa, 10) : 5);
function Oa(a) {
  Error.captureStackTrace ? Error.captureStackTrace(this, Oa) : this.stack = Error().stack || "";
  a && (this.message = String(a))
}
D(Oa, Error);
Oa.prototype.name = "CustomError";
function Pa(a, b) {
  b.unshift(a);
  Oa.call(this, ma.apply(m, b));
  b.shift();
  this.Ic = a
}
D(Pa, Oa);
Pa.prototype.name = "AssertionError";
function Qa(a, b) {
  e(new Pa("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1)))
}
;var Ra = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#(.*))?$");
function Sa(a) {
  var b = Ta, c;
  for(c in b) {
    a.call(h, b[c], c, b)
  }
}
function Ua(a) {
  var b = [], c = 0, d;
  for(d in a) {
    b[c++] = a[d]
  }
  return b
}
function Va(a) {
  var b = [], c = 0, d;
  for(d in a) {
    b[c++] = d
  }
  return b
}
var Wa = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Xa(a, b) {
  for(var c, d, f = 1;f < arguments.length;f++) {
    d = arguments[f];
    for(c in d) {
      a[c] = d[c]
    }
    for(var g = 0;g < Wa.length;g++) {
      c = Wa[g], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c])
    }
  }
}
;var H = Array.prototype, Ya = H.indexOf ? function(a, b, c) {
  return H.indexOf.call(a, b, c)
} : function(a, b, c) {
  c = c == m ? 0 : 0 > c ? Math.max(0, a.length + c) : c;
  if(z(a)) {
    return!z(b) || 1 != b.length ? -1 : a.indexOf(b, c)
  }
  for(;c < a.length;c++) {
    if(c in a && a[c] === b) {
      return c
    }
  }
  return-1
}, Za = H.forEach ? function(a, b, c) {
  H.forEach.call(a, b, c)
} : function(a, b, c) {
  for(var d = a.length, f = z(a) ? a.split("") : a, g = 0;g < d;g++) {
    g in f && b.call(c, f[g], g, a)
  }
};
function $a(a) {
  return H.concat.apply(H, arguments)
}
function ab(a) {
  var b = a.length;
  if(0 < b) {
    for(var c = Array(b), d = 0;d < b;d++) {
      c[d] = a[d]
    }
    return c
  }
  return[]
}
;function bb(a) {
  if("function" == typeof a.M) {
    return a.M()
  }
  if(z(a)) {
    return a.split("")
  }
  if(ga(a)) {
    for(var b = [], c = a.length, d = 0;d < c;d++) {
      b.push(a[d])
    }
    return b
  }
  return Ua(a)
}
function cb(a, b, c) {
  if("function" == typeof a.forEach) {
    a.forEach(b, c)
  }else {
    if(ga(a) || z(a)) {
      Za(a, b, c)
    }else {
      var d;
      if("function" == typeof a.ja) {
        d = a.ja()
      }else {
        if("function" != typeof a.M) {
          if(ga(a) || z(a)) {
            d = [];
            for(var f = a.length, g = 0;g < f;g++) {
              d.push(g)
            }
          }else {
            d = Va(a)
          }
        }else {
          d = h
        }
      }
      for(var f = bb(a), g = f.length, k = 0;k < g;k++) {
        b.call(c, f[k], d && d[k], a)
      }
    }
  }
}
;function db(a, b) {
  this.N = {};
  this.j = [];
  var c = arguments.length;
  if(1 < c) {
    c % 2 && e(Error("Uneven number of arguments"));
    for(var d = 0;d < c;d += 2) {
      this.set(arguments[d], arguments[d + 1])
    }
  }else {
    if(a) {
      a instanceof db ? (c = a.ja(), d = a.M()) : (c = Va(a), d = Ua(a));
      for(var f = 0;f < c.length;f++) {
        this.set(c[f], d[f])
      }
    }
  }
}
u = db.prototype;
u.f = 0;
u.ac = 0;
u.M = function() {
  eb(this);
  for(var a = [], b = 0;b < this.j.length;b++) {
    a.push(this.N[this.j[b]])
  }
  return a
};
u.ja = function() {
  eb(this);
  return this.j.concat()
};
u.ha = function(a) {
  return fb(this.N, a)
};
u.remove = function(a) {
  return fb(this.N, a) ? (delete this.N[a], this.f--, this.ac++, this.j.length > 2 * this.f && eb(this), l) : r
};
function eb(a) {
  if(a.f != a.j.length) {
    for(var b = 0, c = 0;b < a.j.length;) {
      var d = a.j[b];
      fb(a.N, d) && (a.j[c++] = d);
      b++
    }
    a.j.length = c
  }
  if(a.f != a.j.length) {
    for(var f = {}, c = b = 0;b < a.j.length;) {
      d = a.j[b], fb(f, d) || (a.j[c++] = d, f[d] = 1), b++
    }
    a.j.length = c
  }
}
u.get = function(a, b) {
  return fb(this.N, a) ? this.N[a] : b
};
u.set = function(a, b) {
  fb(this.N, a) || (this.f++, this.j.push(a), this.ac++);
  this.N[a] = b
};
u.n = function() {
  return new db(this)
};
function fb(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b)
}
;function I(a, b) {
  var c;
  if(a instanceof I) {
    this.C = b !== h ? b : a.C, gb(this, a.pa), c = a.$a, J(this), this.$a = h ? c ? decodeURIComponent(c) : "" : c, hb(this, a.ia), ib(this, a.Aa), jb(this, a.G), kb(this, a.Q.n()), c = a.La, J(this), this.La = h ? c ? decodeURIComponent(c) : "" : c
  }else {
    if(a && (c = String(a).match(Ra))) {
      this.C = !!b;
      gb(this, c[1] || "", l);
      var d = c[2] || "";
      J(this);
      this.$a = l ? d ? decodeURIComponent(d) : "" : d;
      hb(this, c[3] || "", l);
      ib(this, c[4]);
      jb(this, c[5] || "", l);
      kb(this, c[6] || "", l);
      c = c[7] || "";
      J(this);
      this.La = l ? c ? decodeURIComponent(c) : "" : c
    }else {
      this.C = !!b, this.Q = new lb(m, 0, this.C)
    }
  }
}
u = I.prototype;
u.pa = "";
u.$a = "";
u.ia = "";
u.Aa = m;
u.G = "";
u.La = "";
u.lc = r;
u.C = r;
u.toString = function() {
  var a = [], b = this.pa;
  b && a.push(mb(b, nb), ":");
  if(b = this.ia) {
    a.push("//");
    var c = this.$a;
    c && a.push(mb(c, nb), "@");
    a.push(encodeURIComponent(String(b)));
    b = this.Aa;
    b != m && a.push(":", String(b))
  }
  if(b = this.G) {
    this.ia && "/" != b.charAt(0) && a.push("/"), a.push(mb(b, "/" == b.charAt(0) ? ob : pb))
  }
  (b = this.Q.toString()) && a.push("?", b);
  (b = this.La) && a.push("#", mb(b, qb));
  return a.join("")
};
u.n = function() {
  return new I(this)
};
function gb(a, b, c) {
  J(a);
  a.pa = c ? b ? decodeURIComponent(b) : "" : b;
  a.pa && (a.pa = a.pa.replace(/:$/, ""))
}
function hb(a, b, c) {
  J(a);
  a.ia = c ? b ? decodeURIComponent(b) : "" : b
}
function ib(a, b) {
  J(a);
  b ? (b = Number(b), (isNaN(b) || 0 > b) && e(Error("Bad port number " + b)), a.Aa = b) : a.Aa = m
}
function jb(a, b, c) {
  J(a);
  a.G = c ? b ? decodeURIComponent(b) : "" : b
}
function kb(a, b, c) {
  J(a);
  b instanceof lb ? (a.Q = b, a.Q.pb(a.C)) : (c || (b = mb(b, rb)), a.Q = new lb(b, 0, a.C))
}
function K(a, b, c) {
  J(a);
  a.Q.set(b, c)
}
function sb(a, b, c) {
  J(a);
  x(c) || (c = [String(c)]);
  tb(a.Q, b, c)
}
function M(a) {
  J(a);
  K(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ C()).toString(36));
  return a
}
function J(a) {
  a.lc && e(Error("Tried to modify a read-only Uri"))
}
u.pb = function(a) {
  this.C = a;
  this.Q && this.Q.pb(a);
  return this
};
function ub(a, b, c, d) {
  var f = new I(m, h);
  a && gb(f, a);
  b && hb(f, b);
  c && ib(f, c);
  d && jb(f, d);
  return f
}
function mb(a, b) {
  return z(a) ? encodeURI(a).replace(b, vb) : m
}
function vb(a) {
  a = a.charCodeAt(0);
  return"%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16)
}
var nb = /[#\/\?@]/g, pb = /[\#\?:]/g, ob = /[\#\?]/g, rb = /[\#\?@]/g, qb = /#/g;
function lb(a, b, c) {
  this.B = a || m;
  this.C = !!c
}
function N(a) {
  if(!a.i && (a.i = new db, a.f = 0, a.B)) {
    for(var b = a.B.split("&"), c = 0;c < b.length;c++) {
      var d = b[c].indexOf("="), f = m, g = m;
      0 <= d ? (f = b[c].substring(0, d), g = b[c].substring(d + 1)) : f = b[c];
      f = decodeURIComponent(f.replace(/\+/g, " "));
      f = O(a, f);
      a.add(f, g ? decodeURIComponent(g.replace(/\+/g, " ")) : "")
    }
  }
}
u = lb.prototype;
u.i = m;
u.f = m;
u.add = function(a, b) {
  N(this);
  this.B = m;
  a = O(this, a);
  var c = this.i.get(a);
  c || this.i.set(a, c = []);
  c.push(b);
  this.f++;
  return this
};
u.remove = function(a) {
  N(this);
  a = O(this, a);
  return this.i.ha(a) ? (this.B = m, this.f -= this.i.get(a).length, this.i.remove(a)) : r
};
u.ha = function(a) {
  N(this);
  a = O(this, a);
  return this.i.ha(a)
};
u.ja = function() {
  N(this);
  for(var a = this.i.M(), b = this.i.ja(), c = [], d = 0;d < b.length;d++) {
    for(var f = a[d], g = 0;g < f.length;g++) {
      c.push(b[d])
    }
  }
  return c
};
u.M = function(a) {
  N(this);
  var b = [];
  if(a) {
    this.ha(a) && (b = $a(b, this.i.get(O(this, a))))
  }else {
    a = this.i.M();
    for(var c = 0;c < a.length;c++) {
      b = $a(b, a[c])
    }
  }
  return b
};
u.set = function(a, b) {
  N(this);
  this.B = m;
  a = O(this, a);
  this.ha(a) && (this.f -= this.i.get(a).length);
  this.i.set(a, [b]);
  this.f++;
  return this
};
u.get = function(a, b) {
  var c = a ? this.M(a) : [];
  return 0 < c.length ? String(c[0]) : b
};
function tb(a, b, c) {
  a.remove(b);
  0 < c.length && (a.B = m, a.i.set(O(a, b), ab(c)), a.f += c.length)
}
u.toString = function() {
  if(this.B) {
    return this.B
  }
  if(!this.i) {
    return""
  }
  for(var a = [], b = this.i.ja(), c = 0;c < b.length;c++) {
    for(var d = b[c], f = encodeURIComponent(String(d)), d = this.M(d), g = 0;g < d.length;g++) {
      var k = f;
      "" !== d[g] && (k += "=" + encodeURIComponent(String(d[g])));
      a.push(k)
    }
  }
  return this.B = a.join("&")
};
u.n = function() {
  var a = new lb;
  a.B = this.B;
  this.i && (a.i = this.i.n(), a.f = this.f);
  return a
};
function O(a, b) {
  var c = String(b);
  a.C && (c = c.toLowerCase());
  return c
}
u.pb = function(a) {
  a && !this.C && (N(this), this.B = m, cb(this.i, function(a, c) {
    var d = c.toLowerCase();
    c != d && (this.remove(c), tb(this, d, a))
  }, this));
  this.C = a
};
function wb() {
}
wb.prototype.Fa = m;
var xb;
function yb() {
}
D(yb, wb);
function zb(a) {
  return(a = Ab(a)) ? new ActiveXObject(a) : new XMLHttpRequest
}
function Bb(a) {
  var b = {};
  Ab(a) && (b[0] = l, b[1] = l);
  return b
}
function Ab(a) {
  if(!a.Fb && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
    for(var b = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], c = 0;c < b.length;c++) {
      var d = b[c];
      try {
        return new ActiveXObject(d), a.Fb = d
      }catch(f) {
      }
    }
    e(Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed"))
  }
  return a.Fb
}
xb = new yb;
function P() {
  0 != Cb && (this.Fc = Error().stack, Db[A(this)] = this)
}
var Cb = 0, Db = {};
P.prototype.xb = r;
P.prototype.Ha = function() {
  if(!this.xb && (this.xb = l, this.u(), 0 != Cb)) {
    var a = A(this);
    delete Db[a]
  }
};
P.prototype.u = function() {
  if(this.Mb) {
    for(;this.Mb.length;) {
      this.Mb.shift()()
    }
  }
};
function Q(a, b) {
  this.type = a;
  this.currentTarget = this.target = b
}
u = Q.prototype;
u.u = s();
u.Ha = s();
u.ma = r;
u.defaultPrevented = r;
u.Va = l;
u.preventDefault = function() {
  this.defaultPrevented = l;
  this.Va = r
};
var Eb = 0;
function Fb() {
}
u = Fb.prototype;
u.key = 0;
u.da = r;
u.Ga = r;
u.Na = function(a, b, c, d, f, g) {
  ha(a) ? this.Hb = l : a && a.handleEvent && ha(a.handleEvent) ? this.Hb = r : e(Error("Invalid listener argument"));
  this.V = a;
  this.Tb = b;
  this.src = c;
  this.type = d;
  this.capture = !!f;
  this.kb = g;
  this.Ga = r;
  this.key = ++Eb;
  this.da = r
};
u.handleEvent = function(a) {
  return this.Hb ? this.V.call(this.kb || this.src, a) : this.V.handleEvent.call(this.V, a)
};
var Gb = !E || E && 9 <= Na, Hb = E && !G("9");
!F || G("528");
Ba && G("1.9b") || E && G("8") || Aa && G("9.5") || F && G("528");
Ba && !G("8") || E && G("9");
function Ib(a) {
  Ib[" "](a);
  return a
}
Ib[" "] = ea;
function Jb(a, b) {
  a && this.Na(a, b)
}
D(Jb, Q);
u = Jb.prototype;
u.target = m;
u.relatedTarget = m;
u.offsetX = 0;
u.offsetY = 0;
u.clientX = 0;
u.clientY = 0;
u.screenX = 0;
u.screenY = 0;
u.button = 0;
u.keyCode = 0;
u.charCode = 0;
u.ctrlKey = r;
u.altKey = r;
u.shiftKey = r;
u.metaKey = r;
u.xc = r;
u.yb = m;
u.Na = function(a, b) {
  var c = this.type = a.type;
  Q.call(this, c);
  this.target = a.target || a.srcElement;
  this.currentTarget = b;
  var d = a.relatedTarget;
  if(d) {
    if(Ba) {
      var f;
      a: {
        try {
          Ib(d.nodeName);
          f = l;
          break a
        }catch(g) {
        }
        f = r
      }
      f || (d = m)
    }
  }else {
    "mouseover" == c ? d = a.fromElement : "mouseout" == c && (d = a.toElement)
  }
  this.relatedTarget = d;
  this.offsetX = F || a.offsetX !== h ? a.offsetX : a.layerX;
  this.offsetY = F || a.offsetY !== h ? a.offsetY : a.layerY;
  this.clientX = a.clientX !== h ? a.clientX : a.pageX;
  this.clientY = a.clientY !== h ? a.clientY : a.pageY;
  this.screenX = a.screenX || 0;
  this.screenY = a.screenY || 0;
  this.button = a.button;
  this.keyCode = a.keyCode || 0;
  this.charCode = a.charCode || ("keypress" == c ? a.keyCode : 0);
  this.ctrlKey = a.ctrlKey;
  this.altKey = a.altKey;
  this.shiftKey = a.shiftKey;
  this.metaKey = a.metaKey;
  this.xc = Da ? a.metaKey : a.ctrlKey;
  this.state = a.state;
  this.yb = a;
  a.defaultPrevented && this.preventDefault();
  delete this.ma
};
u.preventDefault = function() {
  Jb.qa.preventDefault.call(this);
  var a = this.yb;
  if(a.preventDefault) {
    a.preventDefault()
  }else {
    if(a.returnValue = r, Hb) {
      try {
        if(a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) {
          a.keyCode = -1
        }
      }catch(b) {
      }
    }
  }
};
u.u = s();
var Ta = {}, R = {}, S = {}, Kb = {};
function Lb(a, b, c, d, f) {
  if(x(b)) {
    for(var g = 0;g < b.length;g++) {
      Lb(a, b[g], c, d, f)
    }
    return m
  }
  a: {
    b || e(Error("Invalid event type"));
    d = !!d;
    var k = R;
    b in k || (k[b] = {f:0, t:0});
    k = k[b];
    d in k || (k[d] = {f:0, t:0}, k.f++);
    var k = k[d], g = A(a), q;
    k.t++;
    if(k[g]) {
      q = k[g];
      for(var n = 0;n < q.length;n++) {
        if(k = q[n], k.V == c && k.kb == f) {
          if(k.da) {
            break
          }
          q[n].Ga = r;
          a = q[n];
          break a
        }
      }
    }else {
      q = k[g] = [], k.f++
    }
    n = Mb();
    k = new Fb;
    k.Na(c, n, a, b, d, f);
    k.Ga = r;
    n.src = a;
    n.V = k;
    q.push(k);
    S[g] || (S[g] = []);
    S[g].push(k);
    a.addEventListener ? (a == w || !a.vb) && a.addEventListener(b, n, d) : a.attachEvent(b in Kb ? Kb[b] : Kb[b] = "on" + b, n);
    a = k
  }
  b = a.key;
  Ta[b] = a;
  return b
}
function Mb() {
  var a = Nb, b = Gb ? function(c) {
    return a.call(b.src, b.V, c)
  } : function(c) {
    c = a.call(b.src, b.V, c);
    if(!c) {
      return c
    }
  };
  return b
}
function Ob(a, b, c, d, f) {
  if(x(b)) {
    for(var g = 0;g < b.length;g++) {
      Ob(a, b[g], c, d, f)
    }
  }else {
    d = !!d;
    a: {
      g = R;
      if(b in g && (g = g[b], d in g && (g = g[d], a = A(a), g[a]))) {
        a = g[a];
        break a
      }
      a = m
    }
    if(a) {
      for(g = 0;g < a.length;g++) {
        if(a[g].V == c && a[g].capture == d && a[g].kb == f) {
          Pb(a[g].key);
          break
        }
      }
    }
  }
}
function Pb(a) {
  var b = Ta[a];
  if(!b || b.da) {
    return r
  }
  var c = b.src, d = b.type, f = b.Tb, g = b.capture;
  c.removeEventListener ? (c == w || !c.vb) && c.removeEventListener(d, f, g) : c.detachEvent && c.detachEvent(d in Kb ? Kb[d] : Kb[d] = "on" + d, f);
  c = A(c);
  if(S[c]) {
    var f = S[c], k = Ya(f, b);
    0 <= k && H.splice.call(f, k, 1);
    0 == f.length && delete S[c]
  }
  b.da = l;
  if(b = R[d][g][c]) {
    b.Lb = l, Qb(d, g, c, b)
  }
  delete Ta[a];
  return l
}
function Qb(a, b, c, d) {
  if(!d.Pa && d.Lb) {
    for(var f = 0, g = 0;f < d.length;f++) {
      d[f].da ? d[f].Tb.src = m : (f != g && (d[g] = d[f]), g++)
    }
    d.length = g;
    d.Lb = r;
    0 == g && (delete R[a][b][c], R[a][b].f--, 0 == R[a][b].f && (delete R[a][b], R[a].f--), 0 == R[a].f && delete R[a])
  }
}
function Rb(a) {
  var b = 0;
  if(a != m) {
    if(a = A(a), S[a]) {
      a = S[a];
      for(var c = a.length - 1;0 <= c;c--) {
        Pb(a[c].key), b++
      }
    }
  }else {
    Sa(function(a, c) {
      Pb(c);
      b++
    })
  }
}
function Sb(a, b, c, d, f) {
  var g = 1;
  b = A(b);
  if(a[b]) {
    var k = --a.t, q = a[b];
    q.Pa ? q.Pa++ : q.Pa = 1;
    try {
      for(var n = q.length, y = 0;y < n;y++) {
        var p = q[y];
        p && !p.da && (g &= Tb(p, f) !== r)
      }
    }finally {
      a.t = Math.max(k, a.t), q.Pa--, Qb(c, d, b, q)
    }
  }
  return Boolean(g)
}
function Tb(a, b) {
  a.Ga && Pb(a.key);
  return a.handleEvent(b)
}
function Nb(a, b) {
  if(a.da) {
    return l
  }
  var c = a.type, d = R;
  if(!(c in d)) {
    return l
  }
  var d = d[c], f, g;
  if(!Gb) {
    f = b || da("window.event");
    var k = l in d, q = r in d;
    if(k) {
      if(0 > f.keyCode || f.returnValue != h) {
        return l
      }
      a: {
        var n = r;
        if(0 == f.keyCode) {
          try {
            f.keyCode = -1;
            break a
          }catch(y) {
            n = l
          }
        }
        if(n || f.returnValue == h) {
          f.returnValue = l
        }
      }
    }
    n = new Jb;
    n.Na(f, this);
    f = l;
    try {
      if(k) {
        for(var p = [], v = n.currentTarget;v;v = v.parentNode) {
          p.push(v)
        }
        g = d[l];
        g.t = g.f;
        for(var L = p.length - 1;!n.ma && 0 <= L && g.t;L--) {
          n.currentTarget = p[L], f &= Sb(g, p[L], c, l, n)
        }
        if(q) {
          g = d[r];
          g.t = g.f;
          for(L = 0;!n.ma && L < p.length && g.t;L++) {
            n.currentTarget = p[L], f &= Sb(g, p[L], c, r, n)
          }
        }
      }else {
        f = Tb(a, n)
      }
    }finally {
      p && (p.length = 0)
    }
    return f
  }
  c = new Jb(b, this);
  return f = Tb(a, c)
}
;function Ub() {
  P.call(this)
}
D(Ub, P);
u = Ub.prototype;
u.vb = l;
u.ob = m;
u.addEventListener = function(a, b, c, d) {
  Lb(this, a, b, c, d)
};
u.removeEventListener = function(a, b, c, d) {
  Ob(this, a, b, c, d)
};
u.dispatchEvent = function(a) {
  var b = a.type || a, c = R;
  if(b in c) {
    if(z(a)) {
      a = new Q(a, this)
    }else {
      if(a instanceof Q) {
        a.target = a.target || this
      }else {
        var d = a;
        a = new Q(b, this);
        Xa(a, d)
      }
    }
    var d = 1, f, c = c[b], b = l in c, g;
    if(b) {
      f = [];
      for(g = this;g;g = g.ob) {
        f.push(g)
      }
      g = c[l];
      g.t = g.f;
      for(var k = f.length - 1;!a.ma && 0 <= k && g.t;k--) {
        a.currentTarget = f[k], d &= Sb(g, f[k], a.type, l, a) && a.Va != r
      }
    }
    if(r in c) {
      if(g = c[r], g.t = g.f, b) {
        for(k = 0;!a.ma && k < f.length && g.t;k++) {
          a.currentTarget = f[k], d &= Sb(g, f[k], a.type, r, a) && a.Va != r
        }
      }else {
        for(f = this;!a.ma && f && g.t;f = f.ob) {
          a.currentTarget = f, d &= Sb(g, f, a.type, r, a) && a.Va != r
        }
      }
    }
    a = Boolean(d)
  }else {
    a = l
  }
  return a
};
u.u = function() {
  Ub.qa.u.call(this);
  Rb(this);
  this.ob = m
};
function Vb(a, b) {
  P.call(this);
  this.ca = a || 1;
  this.Da = b || Wb;
  this.cb = B(this.Dc, this);
  this.nb = C()
}
D(Vb, Ub);
Vb.prototype.enabled = r;
var Wb = w;
u = Vb.prototype;
u.r = m;
u.setInterval = function(a) {
  this.ca = a;
  this.r && this.enabled ? (this.stop(), this.start()) : this.r && this.stop()
};
u.Dc = function() {
  if(this.enabled) {
    var a = C() - this.nb;
    0 < a && a < 0.8 * this.ca ? this.r = this.Da.setTimeout(this.cb, this.ca - a) : (this.dispatchEvent(Xb), this.enabled && (this.r = this.Da.setTimeout(this.cb, this.ca), this.nb = C()))
  }
};
u.start = function() {
  this.enabled = l;
  this.r || (this.r = this.Da.setTimeout(this.cb, this.ca), this.nb = C())
};
u.stop = function() {
  this.enabled = r;
  this.r && (this.Da.clearTimeout(this.r), this.r = m)
};
u.u = function() {
  Vb.qa.u.call(this);
  this.stop();
  delete this.Da
};
var Xb = "tick";
function Yb(a) {
  P.call(this);
  this.e = a;
  this.j = []
}
D(Yb, P);
var Zb = [];
function $b(a, b, c, d) {
  x(c) || (Zb[0] = c, c = Zb);
  for(var f = 0;f < c.length;f++) {
    var g = Lb(b, c[f], d || a, r, a.e || a);
    a.j.push(g)
  }
}
Yb.prototype.u = function() {
  Yb.qa.u.call(this);
  Za(this.j, Pb);
  this.j.length = 0
};
Yb.prototype.handleEvent = function() {
  e(Error("EventHandler.handleEvent not implemented"))
};
function ac(a, b, c) {
  P.call(this);
  this.mc = a;
  this.ca = b;
  this.e = c;
  this.gc = B(this.sc, this)
}
D(ac, P);
u = ac.prototype;
u.Wa = r;
u.Sb = 0;
u.r = m;
u.stop = function() {
  this.r && (Wb.clearTimeout(this.r), this.r = m, this.Wa = r)
};
u.u = function() {
  ac.qa.u.call(this);
  this.stop()
};
u.sc = function() {
  this.r = m;
  this.Wa && !this.Sb && (this.Wa = r, bc(this))
};
function bc(a) {
  var b;
  b = a.gc;
  var c = a.ca;
  ha(b) || (b && "function" == typeof b.handleEvent ? b = B(b.handleEvent, b) : e(Error("Invalid listener argument")));
  b = 2147483647 < c ? -1 : Wb.setTimeout(b, c || 0);
  a.r = b;
  a.mc.call(a.e)
}
;function T(a, b, c, d, f) {
  this.b = a;
  this.a = b;
  this.Y = c;
  this.A = d;
  this.Ba = f || 1;
  this.Ca = cc;
  this.ib = new Yb(this);
  this.Ra = new Vb;
  this.Ra.setInterval(dc)
}
u = T.prototype;
u.v = m;
u.I = r;
u.ta = m;
u.rb = m;
u.oa = m;
u.ra = m;
u.S = m;
u.w = m;
u.W = m;
u.l = m;
u.Ea = 0;
u.J = m;
u.sa = m;
u.p = m;
u.h = -1;
u.Wb = l;
u.$ = r;
u.na = 0;
u.Sa = m;
var cc = 45E3, dc = 250;
function ec(a, b) {
  switch(a) {
    case 0:
      return"Non-200 return code (" + b + ")";
    case 1:
      return"XMLHTTP failure (no data)";
    case 2:
      return"HttpConnection timeout";
    default:
      return"Unknown error"
  }
}
var fc = {}, gc = {};
function hc() {
  return!E || E && 10 <= Na
}
u = T.prototype;
u.X = t("v");
u.setTimeout = t("Ca");
u.Zb = t("na");
function ic(a, b, c) {
  a.ra = 1;
  a.S = M(b.n());
  a.W = c;
  a.wb = l;
  jc(a, m)
}
function kc(a, b, c, d, f) {
  a.ra = 1;
  a.S = M(b.n());
  a.W = m;
  a.wb = c;
  f && (a.Wb = r);
  jc(a, d)
}
function jc(a, b) {
  a.oa = C();
  lc(a);
  a.w = a.S.n();
  sb(a.w, "t", a.Ba);
  a.Ea = 0;
  a.l = a.b.gb(a.b.Xa() ? b : m);
  0 < a.na && (a.Sa = new ac(B(a.cc, a, a.l), a.na));
  $b(a.ib, a.l, "readystatechange", a.zc);
  var c;
  if(a.v) {
    c = a.v;
    var d = {}, f;
    for(f in c) {
      d[f] = c[f]
    }
    c = d
  }else {
    c = {}
  }
  a.W ? (a.sa = "POST", c["Content-Type"] = "application/x-www-form-urlencoded", a.l.send(a.w, a.sa, a.W, c)) : (a.sa = "GET", a.Wb && !F && (c.Connection = "close"), a.l.send(a.w, a.sa, m, c));
  a.b.F(mc);
  if(d = a.W) {
    c = "";
    d = d.split("&");
    for(f = 0;f < d.length;f++) {
      var g = d[f].split("=");
      if(1 < g.length) {
        var k = g[0], g = g[1], q = k.split("_");
        c = 2 <= q.length && "type" == q[1] ? c + (k + "=" + g + "&") : c + (k + "=redacted&")
      }
    }
  }else {
    c = m
  }
  a.a.info("XMLHTTP REQ (" + a.A + ") [attempt " + a.Ba + "]: " + a.sa + "\n" + a.w + "\n" + c)
}
u.zc = function(a) {
  a = a.target;
  var b = this.Sa;
  b && 3 == U(a) ? (this.a.debug("Throttling readystatechange."), !b.r && !b.Sb ? bc(b) : b.Wa = l) : this.cc(a)
};
u.cc = function(a) {
  try {
    if(a == this.l) {
      a: {
        var b = U(this.l), c = this.l.ka, d = nc(this.l);
        if(!hc() || F && !G("420+")) {
          if(4 > b) {
            break a
          }
        }else {
          if(3 > b || 3 == b && !Aa && !oc(this.l)) {
            break a
          }
        }
        !this.$ && (4 == b && c != pc) && (c == qc || 0 >= d ? this.b.F(rc) : this.b.F(sc));
        tc(this);
        var f = nc(this.l);
        this.h = f;
        var g = oc(this.l);
        g || this.a.debug("No response text for uri " + this.w + " status " + f);
        this.I = 200 == f;
        this.a.info("XMLHTTP RESP (" + this.A + ") [ attempt " + this.Ba + "]: " + this.sa + "\n" + this.w + "\n" + b + " " + f);
        this.I ? (4 == b && uc(this), this.wb ? (vc(this, b, g), Aa && 3 == b && ($b(this.ib, this.Ra, Xb, this.yc), this.Ra.start())) : (wc(this.a, this.A, g, m), xc(this, g)), this.I && !this.$ && (4 == b ? this.b.la(this) : (this.I = r, lc(this)))) : (400 == f && 0 < g.indexOf("Unknown SID") ? (this.p = 3, V(yc), this.a.Z("XMLHTTP Unknown SID (" + this.A + ")")) : (this.p = 0, V(zc), this.a.Z("XMLHTTP Bad status " + f + " (" + this.A + ")")), uc(this), Ac(this))
      }
    }else {
      this.a.Z("Called back with an unexpected xmlhttp")
    }
  }catch(k) {
    this.a.debug("Failed call to OnXmlHttpReadyStateChanged_"), this.l && oc(this.l) ? Bc(this.a, k, "ResponseText: " + oc(this.l)) : Bc(this.a, k, "No response text")
  }finally {
  }
};
function vc(a, b, c) {
  for(var d = l;!a.$ && a.Ea < c.length;) {
    var f = Cc(a, c);
    if(f == gc) {
      4 == b && (a.p = 4, V(Dc), d = r);
      wc(a.a, a.A, m, "[Incomplete Response]");
      break
    }else {
      if(f == fc) {
        a.p = 4;
        V(Ec);
        wc(a.a, a.A, c, "[Invalid Chunk]");
        d = r;
        break
      }else {
        wc(a.a, a.A, f, m), xc(a, f)
      }
    }
  }
  4 == b && 0 == c.length && (a.p = 1, V(Fc), d = r);
  a.I = a.I && d;
  d || (wc(a.a, a.A, c, "[Invalid Chunked Response]"), uc(a), Ac(a))
}
u.yc = function() {
  var a = U(this.l), b = oc(this.l);
  this.Ea < b.length && (tc(this), vc(this, a, b), this.I && 4 != a && lc(this))
};
function Cc(a, b) {
  var c = a.Ea, d = b.indexOf("\n", c);
  if(-1 == d) {
    return gc
  }
  c = Number(b.substring(c, d));
  if(isNaN(c)) {
    return fc
  }
  d += 1;
  if(d + c > b.length) {
    return gc
  }
  var f = b.substr(d, c);
  a.Ea = d + c;
  return f
}
function Gc(a, b) {
  a.oa = C();
  lc(a);
  var c = b ? window.location.hostname : "";
  a.w = a.S.n();
  K(a.w, "DOMAIN", c);
  K(a.w, "t", a.Ba);
  try {
    a.J = new ActiveXObject("htmlfile")
  }catch(d) {
    a.a.H("ActiveX blocked");
    uc(a);
    a.p = 7;
    V(Hc);
    Ac(a);
    return
  }
  var f = "<html><body>";
  b && (f += '<script>document.domain="' + c + '"\x3c/script>');
  f += "</body></html>";
  a.J.open();
  a.J.write(f);
  a.J.close();
  a.J.parentWindow.m = B(a.vc, a);
  a.J.parentWindow.d = B(a.Rb, a, l);
  a.J.parentWindow.rpcClose = B(a.Rb, a, r);
  c = a.J.createElement("div");
  a.J.parentWindow.document.body.appendChild(c);
  c.innerHTML = '<iframe src="' + a.w + '"></iframe>';
  a.a.info("TRIDENT REQ (" + a.A + ") [ attempt " + a.Ba + "]: GET\n" + a.w);
  a.b.F(mc)
}
u.vc = function(a) {
  W(B(this.uc, this, a), 0)
};
u.uc = function(a) {
  if(!this.$) {
    var b = this.a;
    b.info("TRIDENT TEXT (" + this.A + "): " + Ic(b, a));
    tc(this);
    xc(this, a);
    lc(this)
  }
};
u.Rb = function(a) {
  W(B(this.tc, this, a), 0)
};
u.tc = function(a) {
  this.$ || (this.a.info("TRIDENT TEXT (" + this.A + "): " + a ? "success" : "failure"), uc(this), this.I = a, this.b.la(this), this.b.F(Jc))
};
u.kc = function() {
  tc(this);
  this.b.la(this)
};
u.cancel = function() {
  this.$ = l;
  uc(this)
};
function lc(a) {
  a.rb = C() + a.Ca;
  Kc(a, a.Ca)
}
function Kc(a, b) {
  a.ta != m && e(Error("WatchDog timer not null"));
  a.ta = W(B(a.wc, a), b)
}
function tc(a) {
  a.ta && (w.clearTimeout(a.ta), a.ta = m)
}
u.wc = function() {
  this.ta = m;
  var a = C();
  0 <= a - this.rb ? (this.I && this.a.H("Received watchdog timeout even though request loaded successfully"), this.a.info("TIMEOUT: " + this.w), 2 != this.ra && this.b.F(rc), uc(this), this.p = 2, V(Lc), Ac(this)) : (this.a.Z("WatchDog timer called too early"), Kc(this, this.rb - a))
};
function Ac(a) {
  !a.b.Gb() && !a.$ && a.b.la(a)
}
function uc(a) {
  tc(a);
  var b = a.Sa;
  b && "function" == typeof b.Ha && b.Ha();
  a.Sa = m;
  a.Ra.stop();
  b = a.ib;
  Za(b.j, Pb);
  b.j.length = 0;
  a.l && (b = a.l, a.l = m, b.abort(), b.Ha());
  a.J && (a.J = m)
}
u.Db = aa("p");
function xc(a, b) {
  try {
    a.b.Ob(a, b), a.b.F(Jc)
  }catch(c) {
    Bc(a.a, c, "Error in httprequest callback")
  }
}
;function Mc(a) {
  a = String(a);
  if(/^\s*$/.test(a) ? 0 : /^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g, ""))) {
    try {
      return eval("(" + a + ")")
    }catch(b) {
    }
  }
  e(Error("Invalid JSON string: " + a))
}
function Nc(a) {
  return eval("(" + a + ")")
}
function Oc(a) {
  var b = [];
  Pc(new Qc(h), a, b);
  return b.join("")
}
function Qc(a) {
  this.Ua = a
}
function Pc(a, b, c) {
  switch(typeof b) {
    case "string":
      Rc(b, c);
      break;
    case "number":
      c.push(isFinite(b) && !isNaN(b) ? b : "null");
      break;
    case "boolean":
      c.push(b);
      break;
    case "undefined":
      c.push("null");
      break;
    case "object":
      if(b == m) {
        c.push("null");
        break
      }
      if(x(b)) {
        var d = b.length;
        c.push("[");
        for(var f = "", g = 0;g < d;g++) {
          c.push(f), f = b[g], Pc(a, a.Ua ? a.Ua.call(b, String(g), f) : f, c), f = ","
        }
        c.push("]");
        break
      }
      c.push("{");
      d = "";
      for(g in b) {
        Object.prototype.hasOwnProperty.call(b, g) && (f = b[g], "function" != typeof f && (c.push(d), Rc(g, c), c.push(":"), Pc(a, a.Ua ? a.Ua.call(b, g, f) : f, c), d = ","))
      }
      c.push("}");
      break;
    case "function":
      break;
    default:
      e(Error("Unknown type: " + typeof b))
  }
}
var Sc = {'"':'\\"', "\\":"\\\\", "/":"\\/", "\b":"\\b", "\f":"\\f", "\n":"\\n", "\r":"\\r", "\t":"\\t", "\x0B":"\\u000b"}, Tc = /\uffff/.test("\uffff") ? /[\\\"\x00-\x1f\x7f-\uffff]/g : /[\\\"\x00-\x1f\x7f-\xff]/g;
function Rc(a, b) {
  b.push('"', a.replace(Tc, function(a) {
    if(a in Sc) {
      return Sc[a]
    }
    var b = a.charCodeAt(0), f = "\\u";
    16 > b ? f += "000" : 256 > b ? f += "00" : 4096 > b && (f += "0");
    return Sc[a] = f + b.toString(16)
  }), '"')
}
;function Uc(a) {
  return Vc(a || arguments.callee.caller, [])
}
function Vc(a, b) {
  var c = [];
  if(0 <= Ya(b, a)) {
    c.push("[...circular reference...]")
  }else {
    if(a && 50 > b.length) {
      c.push(Wc(a) + "(");
      for(var d = a.arguments, f = 0;f < d.length;f++) {
        0 < f && c.push(", ");
        var g;
        g = d[f];
        switch(typeof g) {
          case "object":
            g = g ? "object" : "null";
            break;
          case "string":
            break;
          case "number":
            g = String(g);
            break;
          case "boolean":
            g = g ? "true" : "false";
            break;
          case "function":
            g = (g = Wc(g)) ? g : "[fn]";
            break;
          default:
            g = typeof g
        }
        40 < g.length && (g = g.substr(0, 40) + "...");
        c.push(g)
      }
      b.push(a);
      c.push(")\n");
      try {
        c.push(Vc(a.caller, b))
      }catch(k) {
        c.push("[exception trying to get caller]\n")
      }
    }else {
      a ? c.push("[...long stack...]") : c.push("[end]")
    }
  }
  return c.join("")
}
function Wc(a) {
  if(Xc[a]) {
    return Xc[a]
  }
  a = String(a);
  if(!Xc[a]) {
    var b = /function ([^\(]+)/.exec(a);
    Xc[a] = b ? b[1] : "[Anonymous]"
  }
  return Xc[a]
}
var Xc = {};
function Yc(a, b, c, d, f) {
  this.reset(a, b, c, d, f)
}
Yc.prototype.Bc = 0;
Yc.prototype.Ab = m;
Yc.prototype.zb = m;
var Zc = 0;
Yc.prototype.reset = function(a, b, c, d, f) {
  this.Bc = "number" == typeof f ? f : Zc++;
  this.Pc = d || C();
  this.ya = a;
  this.nc = b;
  this.Hc = c;
  delete this.Ab;
  delete this.zb
};
Yc.prototype.Xb = t("ya");
function $c(a) {
  this.oc = a
}
$c.prototype.Qa = m;
$c.prototype.ya = m;
$c.prototype.eb = m;
$c.prototype.Eb = m;
function ad(a, b) {
  this.name = a;
  this.value = b
}
ad.prototype.toString = aa("name");
var bd = new ad("SEVERE", 1E3), cd = new ad("WARNING", 900), dd = new ad("INFO", 800), ed = new ad("CONFIG", 700), fd = new ad("FINE", 500);
u = $c.prototype;
u.getParent = aa("Qa");
u.Xb = t("ya");
function gd(a) {
  if(a.ya) {
    return a.ya
  }
  if(a.Qa) {
    return gd(a.Qa)
  }
  Qa("Root logger has no level set.");
  return m
}
u.log = function(a, b, c) {
  if(a.value >= gd(this).value) {
    a = this.jc(a, b, c);
    b = "log:" + a.nc;
    w.console && (w.console.timeStamp ? w.console.timeStamp(b) : w.console.markTimeline && w.console.markTimeline(b));
    w.msWriteProfilerMark && w.msWriteProfilerMark(b);
    for(b = this;b;) {
      c = b;
      var d = a;
      if(c.Eb) {
        for(var f = 0, g = h;g = c.Eb[f];f++) {
          g(d)
        }
      }
      b = b.getParent()
    }
  }
};
u.jc = function(a, b, c) {
  var d = new Yc(a, String(b), this.oc);
  if(c) {
    d.Ab = c;
    var f;
    var g = arguments.callee.caller;
    try {
      var k;
      var q = da("window.location.href");
      if(z(c)) {
        k = {message:c, name:"Unknown error", lineNumber:"Not available", fileName:q, stack:"Not available"}
      }else {
        var n, y, p = r;
        try {
          n = c.lineNumber || c.Gc || "Not available"
        }catch(v) {
          n = "Not available", p = l
        }
        try {
          y = c.fileName || c.filename || c.sourceURL || w.$googDebugFname || q
        }catch(L) {
          y = "Not available", p = l
        }
        k = p || !c.lineNumber || !c.fileName || !c.stack ? {message:c.message, name:c.name, lineNumber:n, fileName:y, stack:c.stack || "Not available"} : c
      }
      f = "Message: " + na(k.message) + '\nUrl: <a href="view-source:' + k.fileName + '" target="_new">' + k.fileName + "</a>\nLine: " + k.lineNumber + "\n\nBrowser stack:\n" + na(k.stack + "-> ") + "[end]\n\nJS stack traversal:\n" + na(Uc(g) + "-> ")
    }catch(Yd) {
      f = "Exception trying to expose exception! You win, we lose. " + Yd
    }
    d.zb = f
  }
  return d
};
u.H = function(a, b) {
  this.log(bd, a, b)
};
u.Z = function(a, b) {
  this.log(cd, a, b)
};
u.info = function(a, b) {
  this.log(dd, a, b)
};
function X(a, b) {
  a.log(fd, b, h)
}
var hd = {}, id = m;
function jd(a) {
  id || (id = new $c(""), hd[""] = id, id.Xb(ed));
  var b;
  if(!(b = hd[a])) {
    b = new $c(a);
    var c = a.lastIndexOf("."), d = a.substr(c + 1), c = jd(a.substr(0, c));
    c.eb || (c.eb = {});
    c.eb[d] = b;
    b.Qa = c;
    hd[a] = b
  }
  return b
}
;function kd() {
  this.q = jd("goog.net.BrowserChannel")
}
function wc(a, b, c, d) {
  a.info("XMLHTTP TEXT (" + b + "): " + Ic(a, c) + (d ? " " + d : ""))
}
kd.prototype.debug = function(a) {
  this.info(a)
};
function Bc(a, b, c) {
  a.H((c || "Exception") + b)
}
kd.prototype.info = function(a) {
  this.q.info(a)
};
kd.prototype.Z = function(a) {
  this.q.Z(a)
};
kd.prototype.H = function(a) {
  this.q.H(a)
};
function Ic(a, b) {
  if(!b || b == ld) {
    return b
  }
  try {
    var c = Nc(b);
    if(c) {
      for(var d = 0;d < c.length;d++) {
        if(x(c[d])) {
          var f = c[d];
          if(!(2 > f.length)) {
            var g = f[1];
            if(x(g) && !(1 > g.length)) {
              var k = g[0];
              if("noop" != k && "stop" != k) {
                for(var q = 1;q < g.length;q++) {
                  g[q] = ""
                }
              }
            }
          }
        }
      }
    }
    return Oc(c)
  }catch(n) {
    return a.debug("Exception parsing expected JS array - probably was not JS"), b
  }
}
;function md(a, b) {
  this.Nc = new Qc(a);
  this.O = b ? Nc : Mc
}
md.prototype.parse = function(a) {
  return this.O(a)
};
var pc = 7, qc = 8;
function nd(a) {
  P.call(this);
  this.headers = new db;
  this.ua = a || m
}
D(nd, Ub);
nd.prototype.q = jd("goog.net.XhrIo");
var od = /^https?$/i;
u = nd.prototype;
u.R = r;
u.g = m;
u.ab = m;
u.Oa = "";
u.Ib = "";
u.ka = 0;
u.p = "";
u.hb = r;
u.Ma = r;
u.lb = r;
u.ba = r;
u.Za = 0;
u.ea = m;
u.Vb = "";
u.bc = r;
u.send = function(a, b, c, d) {
  this.g && e(Error("[goog.net.XhrIo] Object is active with another request=" + this.Oa + "; newUri=" + a));
  b = b ? b.toUpperCase() : "GET";
  this.Oa = a;
  this.p = "";
  this.ka = 0;
  this.Ib = b;
  this.hb = r;
  this.R = l;
  this.g = this.ua ? zb(this.ua) : zb(xb);
  this.ab = this.ua ? this.ua.Fa || (this.ua.Fa = Bb(this.ua)) : xb.Fa || (xb.Fa = Bb(xb));
  this.g.onreadystatechange = B(this.Nb, this);
  try {
    X(this.q, Y(this, "Opening Xhr")), this.lb = l, this.g.open(b, a, l), this.lb = r
  }catch(f) {
    X(this.q, Y(this, "Error opening Xhr: " + f.message));
    pd(this, f);
    return
  }
  a = c || "";
  var g = this.headers.n();
  d && cb(d, function(a, b) {
    g.set(b, a)
  });
  d = w.FormData && a instanceof w.FormData;
  "POST" == b && (!g.ha("Content-Type") && !d) && g.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  cb(g, function(a, b) {
    this.g.setRequestHeader(b, a)
  }, this);
  this.Vb && (this.g.responseType = this.Vb);
  "withCredentials" in this.g && (this.g.withCredentials = this.bc);
  try {
    this.ea && (Wb.clearTimeout(this.ea), this.ea = m), 0 < this.Za && (X(this.q, Y(this, "Will abort after " + this.Za + "ms if incomplete")), this.ea = Wb.setTimeout(B(this.Ca, this), this.Za)), X(this.q, Y(this, "Sending request")), this.Ma = l, this.g.send(a), this.Ma = r
  }catch(k) {
    X(this.q, Y(this, "Send error: " + k.message)), pd(this, k)
  }
};
u.Ca = function() {
  "undefined" != typeof ca && this.g && (this.p = "Timed out after " + this.Za + "ms, aborting", this.ka = qc, X(this.q, Y(this, this.p)), this.dispatchEvent("timeout"), this.abort(qc))
};
function pd(a, b) {
  a.R = r;
  a.g && (a.ba = l, a.g.abort(), a.ba = r);
  a.p = b;
  a.ka = 5;
  qd(a);
  rd(a)
}
function qd(a) {
  a.hb || (a.hb = l, a.dispatchEvent("complete"), a.dispatchEvent("error"))
}
u.abort = function(a) {
  this.g && this.R && (X(this.q, Y(this, "Aborting")), this.R = r, this.ba = l, this.g.abort(), this.ba = r, this.ka = a || pc, this.dispatchEvent("complete"), this.dispatchEvent("abort"), rd(this))
};
u.u = function() {
  this.g && (this.R && (this.R = r, this.ba = l, this.g.abort(), this.ba = r), rd(this, l));
  nd.qa.u.call(this)
};
u.Nb = function() {
  !this.lb && !this.Ma && !this.ba ? this.rc() : sd(this)
};
u.rc = function() {
  sd(this)
};
function sd(a) {
  if(a.R && "undefined" != typeof ca) {
    if(a.ab[1] && 4 == U(a) && 2 == nc(a)) {
      X(a.q, Y(a, "Local request error detected and ignored"))
    }else {
      if(a.Ma && 4 == U(a)) {
        Wb.setTimeout(B(a.Nb, a), 0)
      }else {
        if(a.dispatchEvent("readystatechange"), 4 == U(a)) {
          X(a.q, Y(a, "Request complete"));
          a.R = r;
          try {
            var b = nc(a), c, d;
            a: {
              switch(b) {
                case 200:
                ;
                case 201:
                ;
                case 202:
                ;
                case 204:
                ;
                case 206:
                ;
                case 304:
                ;
                case 1223:
                  d = l;
                  break a;
                default:
                  d = r
              }
            }
            if(!(c = d)) {
              var f;
              if(f = 0 === b) {
                var g = String(a.Oa).match(Ra)[1] || m;
                if(!g && self.location) {
                  var k = self.location.protocol, g = k.substr(0, k.length - 1)
                }
                f = !od.test(g ? g.toLowerCase() : "")
              }
              c = f
            }
            if(c) {
              a.dispatchEvent("complete"), a.dispatchEvent("success")
            }else {
              a.ka = 6;
              var q;
              try {
                q = 2 < U(a) ? a.g.statusText : ""
              }catch(n) {
                X(a.q, "Can not get status: " + n.message), q = ""
              }
              a.p = q + " [" + nc(a) + "]";
              qd(a)
            }
          }finally {
            rd(a)
          }
        }
      }
    }
  }
}
function rd(a, b) {
  if(a.g) {
    var c = a.g, d = a.ab[0] ? ea : m;
    a.g = m;
    a.ab = m;
    a.ea && (Wb.clearTimeout(a.ea), a.ea = m);
    b || a.dispatchEvent("ready");
    try {
      c.onreadystatechange = d
    }catch(f) {
      a.q.H("Problem encountered resetting onreadystatechange: " + f.message)
    }
  }
}
u.isActive = function() {
  return!!this.g
};
function U(a) {
  return a.g ? a.g.readyState : 0
}
function nc(a) {
  try {
    return 2 < U(a) ? a.g.status : -1
  }catch(b) {
    return a.q.Z("Can not get status: " + b.message), -1
  }
}
function oc(a) {
  try {
    return a.g ? a.g.responseText : ""
  }catch(b) {
    return X(a.q, "Can not get responseText: " + b.message), ""
  }
}
u.Db = function() {
  return z(this.p) ? this.p : String(this.p)
};
function Y(a, b) {
  return b + " [" + a.Ib + " " + a.Oa + " " + nc(a) + "]"
}
;function td() {
  this.Ub = C()
}
new td;
td.prototype.set = t("Ub");
td.prototype.reset = function() {
  this.set(C())
};
td.prototype.get = aa("Ub");
function ud(a, b, c, d, f) {
  (new kd).debug("TestLoadImageWithRetries: " + f);
  if(0 == d) {
    c(r)
  }else {
    var g = f || 0;
    d--;
    vd(a, b, function(f) {
      f ? c(l) : w.setTimeout(function() {
        ud(a, b, c, d, g)
      }, g)
    })
  }
}
function vd(a, b, c) {
  function d(a, b) {
    return function() {
      try {
        f.debug("TestLoadImage: " + b), g.onload = m, g.onerror = m, g.onabort = m, g.ontimeout = m, w.clearTimeout(k), c(a)
      }catch(d) {
        Bc(f, d)
      }
    }
  }
  var f = new kd;
  f.debug("TestLoadImage: loading " + a);
  var g = new Image, k = m;
  g.onload = d(l, "loaded");
  g.onerror = d(r, "error");
  g.onabort = d(r, "abort");
  g.ontimeout = d(r, "timeout");
  k = w.setTimeout(function() {
    if(g.ontimeout) {
      g.ontimeout()
    }
  }, b);
  g.src = a
}
;function wd(a, b) {
  this.b = a;
  this.a = b;
  this.O = new md(m, l)
}
u = wd.prototype;
u.v = m;
u.z = m;
u.Ta = r;
u.$b = m;
u.Ja = m;
u.mb = m;
u.G = m;
u.c = m;
u.h = -1;
u.K = m;
u.va = m;
u.X = t("v");
u.Yb = t("O");
u.fb = function(a) {
  this.G = a;
  a = xd(this.b, this.G);
  V(yd);
  this.$b = C();
  var b = this.b.Bb;
  b != m ? (this.K = this.b.correctHostPrefix(b[0]), (this.va = b[1]) ? (this.c = 1, zd(this)) : (this.c = 2, Ad(this))) : (sb(a, "MODE", "init"), this.z = new T(this, this.a, h, h, h), this.z.X(this.v), kc(this.z, a, r, m, l), this.c = 0)
};
function zd(a) {
  var b = Bd(a.b, a.va, "/mail/images/cleardot.gif");
  M(b);
  ud(b.toString(), 5E3, B(a.hc, a), 3, 2E3);
  a.F(mc)
}
u.hc = function(a) {
  if(a) {
    this.c = 2, Ad(this)
  }else {
    V(Cd);
    var b = this.b;
    b.a.debug("Test Connection Blocked");
    b.h = b.T.h;
    Z(b, 9)
  }
  a && this.F(sc)
};
function Ad(a) {
  a.a.debug("TestConnection: starting stage 2");
  a.z = new T(a, a.a, h, h, h);
  a.z.X(a.v);
  var b = Dd(a.b, a.K, a.G);
  V(Ed);
  if(hc()) {
    sb(b, "TYPE", "xmlhttp"), kc(a.z, b, r, a.K, r)
  }else {
    sb(b, "TYPE", "html");
    var c = a.z;
    a = Boolean(a.K);
    c.ra = 3;
    c.S = M(b.n());
    Gc(c, a)
  }
}
u.gb = function(a) {
  return this.b.gb(a)
};
u.abort = function() {
  this.z && (this.z.cancel(), this.z = m);
  this.h = -1
};
u.Gb = ba(r);
u.Ob = function(a, b) {
  this.h = a.h;
  if(0 == this.c) {
    if(this.a.debug("TestConnection: Got data for stage 1"), b) {
      try {
        var c = this.O.parse(b)
      }catch(d) {
        Bc(this.a, d);
        Fd(this.b, this);
        return
      }
      this.K = this.b.correctHostPrefix(c[0]);
      this.va = c[1]
    }else {
      this.a.debug("TestConnection: Null responseText"), Fd(this.b, this)
    }
  }else {
    if(2 == this.c) {
      if(this.Ta) {
        V(Gd), this.mb = C()
      }else {
        if("11111" == b) {
          if(V(Hd), this.Ta = l, this.Ja = C(), c = this.Ja - this.$b, hc() || 500 > c) {
            this.h = 200, this.z.cancel(), this.a.debug("Test connection succeeded; using streaming connection"), V(Id), Jd(this.b, this, l)
          }
        }else {
          V(Kd), this.Ja = this.mb = C(), this.Ta = r
        }
      }
    }
  }
};
u.la = function() {
  this.h = this.z.h;
  if(this.z.I) {
    if(0 == this.c) {
      this.a.debug("TestConnection: request complete for initial check"), this.va ? (this.c = 1, zd(this)) : (this.c = 2, Ad(this))
    }else {
      if(2 == this.c) {
        this.a.debug("TestConnection: request complete for stage 2");
        var a = r;
        (a = hc() ? this.Ta : 200 > this.mb - this.Ja ? r : l) ? (this.a.debug("Test connection succeeded; using streaming connection"), V(Id), Jd(this.b, this, l)) : (this.a.debug("Test connection failed; not using streaming"), V(Ld), Jd(this.b, this, r))
      }
    }
  }else {
    this.a.debug("TestConnection: request failed, in state " + this.c), 0 == this.c ? V(Md) : 2 == this.c && V(Nd), Fd(this.b, this)
  }
};
u.Xa = function() {
  return this.b.Xa()
};
u.isActive = function() {
  return this.b.isActive()
};
u.F = function(a) {
  this.b.F(a)
};
function Od(a, b) {
  this.ub = a || m;
  this.c = Pd;
  this.s = [];
  this.P = [];
  this.a = new kd;
  this.O = new md(m, l);
  this.Bb = b || m
}
function Qd(a, b) {
  this.Kb = a;
  this.map = b;
  this.Ec = m
}
u = Od.prototype;
u.v = m;
u.wa = m;
u.o = m;
u.k = m;
u.G = m;
u.Ka = m;
u.tb = m;
u.K = m;
u.ec = l;
u.za = 0;
u.pc = 0;
u.Ia = r;
u.e = m;
u.D = m;
u.L = m;
u.aa = m;
u.T = m;
u.qb = m;
u.dc = l;
u.xa = -1;
u.Jb = -1;
u.h = -1;
u.U = 0;
u.fa = 0;
u.fc = 5E3;
u.Ac = 1E4;
u.jb = 2;
u.Cb = 2E4;
u.na = 0;
u.Ya = r;
u.ga = 8;
var Pd = 1, Rd = new Ub;
function Sd(a, b) {
  Q.call(this, "statevent", a);
  this.Oc = b
}
D(Sd, Q);
function Td(a, b, c, d) {
  Q.call(this, "timingevent", a);
  this.size = b;
  this.Mc = c;
  this.Lc = d
}
D(Td, Q);
var mc = 1, sc = 2, rc = 3, Jc = 4;
function Ud(a, b) {
  Q.call(this, "serverreachability", a);
  this.Kc = b
}
D(Ud, Q);
var yd = 3, Cd = 4, Ed = 5, Hd = 6, Gd = 7, Kd = 8, Md = 9, Nd = 10, Ld = 11, Id = 12, yc = 13, zc = 14, Dc = 15, Ec = 16, Fc = 17, Lc = 18, Hc = 22, ld = "y2f%";
u = Od.prototype;
u.fb = function(a, b, c, d, f) {
  this.a.debug("connect()");
  V(0);
  this.G = b;
  this.wa = c || {};
  d && f !== h && (this.wa.OSID = d, this.wa.OAID = f);
  this.a.debug("connectTest_()");
  Vd(this) && (this.T = new wd(this, this.a), this.T.X(this.v), this.T.Yb(this.O), this.T.fb(a))
};
u.disconnect = function() {
  this.a.debug("disconnect()");
  Wd(this);
  if(3 == this.c) {
    var a = this.za++, b = this.Ka.n();
    K(b, "SID", this.Y);
    K(b, "RID", a);
    K(b, "TYPE", "terminate");
    Xd(this, b);
    a = new T(this, this.a, this.Y, a, h);
    a.ra = 2;
    a.S = M(b.n());
    b = new Image;
    b.src = a.S;
    b.onload = b.onerror = B(a.kc, a);
    a.oa = C();
    lc(a)
  }
  Zd(this)
};
function Wd(a) {
  a.T && (a.T.abort(), a.T = m);
  a.k && (a.k.cancel(), a.k = m);
  a.L && (w.clearTimeout(a.L), a.L = m);
  $d(a);
  a.o && (a.o.cancel(), a.o = m);
  a.D && (w.clearTimeout(a.D), a.D = m)
}
u.X = t("v");
u.Zb = t("na");
u.Gb = function() {
  return 0 == this.c
};
u.Yb = t("O");
function ae(a) {
  !a.o && !a.D && (a.D = W(B(a.Qb, a), 0), a.U = 0)
}
u.Qb = function(a) {
  this.D = m;
  this.a.debug("startForwardChannel_");
  if(Vd(this)) {
    if(this.c == Pd) {
      if(a) {
        this.a.H("Not supposed to retry the open")
      }else {
        this.a.debug("open_()");
        this.za = Math.floor(1E5 * Math.random());
        a = this.za++;
        var b = new T(this, this.a, "", a, h);
        b.X(this.v);
        var c = be(this), d = this.Ka.n();
        K(d, "RID", a);
        this.ub && K(d, "CVER", this.ub);
        Xd(this, d);
        ic(b, d, c);
        this.o = b;
        this.c = 2
      }
    }else {
      3 == this.c && (a ? ce(this, a) : 0 == this.s.length ? this.a.debug("startForwardChannel_ returned: nothing to send") : this.o ? this.a.H("startForwardChannel_ returned: connection already in progress") : (ce(this), this.a.debug("startForwardChannel_ finished, sent request")))
    }
  }
};
function ce(a, b) {
  var c, d;
  b ? 6 < a.ga ? (a.s = a.P.concat(a.s), a.P.length = 0, c = a.za - 1, d = be(a)) : (c = b.A, d = b.W) : (c = a.za++, d = be(a));
  var f = a.Ka.n();
  K(f, "SID", a.Y);
  K(f, "RID", c);
  K(f, "AID", a.xa);
  Xd(a, f);
  c = new T(a, a.a, a.Y, c, a.U + 1);
  c.X(a.v);
  c.setTimeout(Math.round(0.5 * a.Cb) + Math.round(0.5 * a.Cb * Math.random()));
  a.o = c;
  ic(c, f, d)
}
function Xd(a, b) {
  if(a.e) {
    var c = a.e.getAdditionalParams(a);
    c && cb(c, function(a, c) {
      K(b, c, a)
    })
  }
}
function be(a) {
  var b = Math.min(a.s.length, 1E3), c = ["count=" + b], d;
  6 < a.ga && 0 < b ? (d = a.s[0].Kb, c.push("ofs=" + d)) : d = 0;
  for(var f = 0;f < b;f++) {
    var g = a.s[f].Kb, k = a.s[f].map, g = 6 >= a.ga ? f : g - d;
    try {
      cb(k, function(a, b) {
        c.push("req" + g + "_" + b + "=" + encodeURIComponent(a))
      })
    }catch(q) {
      c.push("req" + g + "_type=" + encodeURIComponent("_badmap")), a.e && a.e.badMapError(a, k)
    }
  }
  a.P = a.P.concat(a.s.splice(0, b));
  return c.join("&")
}
function de(a) {
  !a.k && !a.L && (a.sb = 1, a.L = W(B(a.Pb, a), 0), a.fa = 0)
}
function ee(a) {
  if(a.k || a.L) {
    return a.a.H("Request already in progress"), r
  }
  if(3 <= a.fa) {
    return r
  }
  a.a.debug("Going to retry GET");
  a.sb++;
  a.L = W(B(a.Pb, a), fe(a, a.fa));
  a.fa++;
  return l
}
u.Pb = function() {
  this.L = m;
  if(Vd(this)) {
    this.a.debug("Creating new HttpRequest");
    this.k = new T(this, this.a, this.Y, "rpc", this.sb);
    this.k.X(this.v);
    this.k.Zb(this.na);
    var a = this.tb.n();
    K(a, "RID", "rpc");
    K(a, "SID", this.Y);
    K(a, "CI", this.qb ? "0" : "1");
    K(a, "AID", this.xa);
    Xd(this, a);
    if(hc()) {
      K(a, "TYPE", "xmlhttp"), kc(this.k, a, l, this.K, r)
    }else {
      K(a, "TYPE", "html");
      var b = this.k, c = Boolean(this.K);
      b.ra = 3;
      b.S = M(a.n());
      Gc(b, c)
    }
    this.a.debug("New Request created")
  }
};
function Vd(a) {
  if(a.e) {
    var b = a.e.okToMakeRequest(a);
    if(0 != b) {
      return a.a.debug("Handler returned error code from okToMakeRequest"), Z(a, b), r
    }
  }
  return l
}
function Jd(a, b, c) {
  a.a.debug("Test Connection Finished");
  a.qb = a.dc && c;
  a.h = b.h;
  a.a.debug("connectChannel_()");
  a.ic(Pd, 0);
  a.Ka = xd(a, a.G);
  ae(a)
}
function Fd(a, b) {
  a.a.debug("Test Connection Failed");
  a.h = b.h;
  Z(a, 2)
}
u.Ob = function(a, b) {
  if(!(0 == this.c || this.k != a && this.o != a)) {
    if(this.h = a.h, this.o == a && 3 == this.c) {
      if(7 < this.ga) {
        var c;
        try {
          c = this.O.parse(b)
        }catch(d) {
          c = m
        }
        if(x(c) && 3 == c.length) {
          var f = c;
          if(0 == f[0]) {
            a: {
              if(this.a.debug("Server claims our backchannel is missing."), this.L) {
                this.a.debug("But we are currently starting the request.")
              }else {
                if(this.k) {
                  if(this.k.oa + 3E3 < this.o.oa) {
                    $d(this), this.k.cancel(), this.k = m
                  }else {
                    break a
                  }
                }else {
                  this.a.Z("We do not have a BackChannel established")
                }
                ee(this);
                V(19)
              }
            }
          }else {
            this.Jb = f[1], c = this.Jb - this.xa, 0 < c && (f = f[2], this.a.debug(f + " bytes (in " + c + " arrays) are outstanding on the BackChannel"), 37500 > f && (this.qb && 0 == this.fa) && !this.aa && (this.aa = W(B(this.qc, this), 6E3)))
          }
        }else {
          this.a.debug("Bad POST response data returned"), Z(this, 11)
        }
      }else {
        b != ld && (this.a.debug("Bad data returned - missing/invald magic cookie"), Z(this, 11))
      }
    }else {
      if(this.k == a && $d(this), !/^[\s\xa0]*$/.test(b)) {
        c = this.O.parse(b);
        for(var f = this.e && this.e.channelHandleMultipleArrays ? [] : m, g = 0;g < c.length;g++) {
          var k = c[g];
          this.xa = k[0];
          k = k[1];
          2 == this.c ? "c" == k[0] ? (this.Y = k[1], this.K = this.correctHostPrefix(k[2]), k = k[3], this.ga = k != m ? k : 6, this.c = 3, this.e && this.e.channelOpened(this), this.tb = Dd(this, this.K, this.G), de(this)) : "stop" == k[0] && Z(this, 7) : 3 == this.c && ("stop" == k[0] ? (f && f.length && (this.e.channelHandleMultipleArrays(this, f), f.length = 0), Z(this, 7)) : "noop" != k[0] && (f ? f.push(k) : this.e && this.e.channelHandleArray(this, k)), this.fa = 0)
        }
        f && f.length && this.e.channelHandleMultipleArrays(this, f)
      }
    }
  }
};
u.correctHostPrefix = function(a) {
  return this.ec ? this.e ? this.e.correctHostPrefix(a) : a : m
};
u.qc = function() {
  this.aa != m && (this.aa = m, this.k.cancel(), this.k = m, ee(this), V(20))
};
function $d(a) {
  a.aa != m && (w.clearTimeout(a.aa), a.aa = m)
}
u.la = function(a) {
  this.a.debug("Request complete");
  var b;
  if(this.k == a) {
    $d(this), this.k = m, b = 2
  }else {
    if(this.o == a) {
      this.o = m, b = 1
    }else {
      return
    }
  }
  this.h = a.h;
  if(0 != this.c) {
    if(a.I) {
      1 == b ? (b = C() - a.oa, Rd.dispatchEvent(new Td(Rd, a.W ? a.W.length : 0, b, this.U)), ae(this), this.P.length = 0) : de(this)
    }else {
      var c = a.Db();
      if(3 == c || 7 == c || 0 == c && 0 < this.h) {
        this.a.debug("Not retrying due to error type")
      }else {
        this.a.debug("Maybe retrying, last error: " + ec(c, this.h));
        var d;
        if(d = 1 == b) {
          this.o || this.D ? (this.a.H("Request already in progress"), d = r) : this.c == Pd || this.U >= (this.Ia ? 0 : this.jb) ? d = r : (this.a.debug("Going to retry POST"), this.D = W(B(this.Qb, this, a), fe(this, this.U)), this.U++, d = l)
        }
        if(d || 2 == b && ee(this)) {
          return
        }
        this.a.debug("Exceeded max number of retries")
      }
      this.a.debug("Error: HTTP request failed");
      switch(c) {
        case 1:
          Z(this, 5);
          break;
        case 4:
          Z(this, 10);
          break;
        case 3:
          Z(this, 6);
          break;
        case 7:
          Z(this, 12);
          break;
        default:
          Z(this, 2)
      }
    }
  }
};
function fe(a, b) {
  var c = a.fc + Math.floor(Math.random() * a.Ac);
  a.isActive() || (a.a.debug("Inactive channel"), c *= 2);
  return c * b
}
u.ic = function(a) {
  0 <= Ya(arguments, this.c) || e(Error("Unexpected channel state: " + this.c))
};
function Z(a, b) {
  a.a.info("Error code " + b);
  if(2 == b || 9 == b) {
    var c = m;
    a.e && (c = a.e.getNetworkTestImageUri(a));
    var d = B(a.Cc, a);
    c || (c = new I("//www.google.com/images/cleardot.gif"), M(c));
    vd(c.toString(), 1E4, d)
  }else {
    V(2)
  }
  ge(a, b)
}
u.Cc = function(a) {
  a ? (this.a.info("Successfully pinged google.com"), V(2)) : (this.a.info("Failed to ping google.com"), V(1), ge(this, 8))
};
function ge(a, b) {
  a.a.debug("HttpChannel: error - " + b);
  a.c = 0;
  a.e && a.e.channelError(a, b);
  Zd(a);
  Wd(a)
}
function Zd(a) {
  a.c = 0;
  a.h = -1;
  if(a.e) {
    if(0 == a.P.length && 0 == a.s.length) {
      a.e.channelClosed(a)
    }else {
      a.a.debug("Number of undelivered maps, pending: " + a.P.length + ", outgoing: " + a.s.length);
      var b = ab(a.P), c = ab(a.s);
      a.P.length = 0;
      a.s.length = 0;
      a.e.channelClosed(a, b, c)
    }
  }
}
function xd(a, b) {
  var c = Bd(a, m, b);
  a.a.debug("GetForwardChannelUri: " + c);
  return c
}
function Dd(a, b, c) {
  b = Bd(a, a.Xa() ? b : m, c);
  a.a.debug("GetBackChannelUri: " + b);
  return b
}
function Bd(a, b, c) {
  var d = c instanceof I ? c.n() : new I(c, h);
  if("" != d.ia) {
    b && hb(d, b + "." + d.ia), ib(d, d.Aa)
  }else {
    var f = window.location, d = ub(f.protocol, b ? b + "." + f.hostname : f.hostname, f.port, c)
  }
  a.wa && cb(a.wa, function(a, b) {
    K(d, b, a)
  });
  K(d, "VER", a.ga);
  Xd(a, d);
  return d
}
u.gb = function(a) {
  a && !this.Ya && e(Error("Can't create secondary domain capable XhrIo object."));
  a = new nd;
  a.bc = this.Ya;
  return a
};
u.isActive = function() {
  return!!this.e && this.e.isActive(this)
};
function W(a, b) {
  ha(a) || e(Error("Fn must not be null and must be a function"));
  return w.setTimeout(function() {
    a()
  }, b)
}
u.F = function(a) {
  Rd.dispatchEvent(new Ud(Rd, a))
};
function V(a) {
  Rd.dispatchEvent(new Sd(Rd, a))
}
u.Xa = function() {
  return this.Ya || !hc()
};
function he() {
}
u = he.prototype;
u.channelHandleMultipleArrays = m;
u.okToMakeRequest = ba(0);
u.channelOpened = s();
u.channelHandleArray = s();
u.channelError = s();
u.channelClosed = s();
u.getAdditionalParams = function() {
  return{}
};
u.getNetworkTestImageUri = ba(m);
u.isActive = ba(l);
u.badMapError = s();
u.correctHostPrefix = function(a) {
  return a
};
var $, ie, je = [].slice;
ie = {0:"Ok", 4:"User is logging out", 6:"Unknown session ID", 7:"Stopped by server", 8:"General network error", 2:"Request failed", 9:"Blocked by a network administrator", 5:"No data from server", 10:"Got bad data from the server", 11:"Got a bad response from the server"};
$ = function(a, b) {
  var c, d, f, g, k, q, n, y, p, v;
  y = this;
  a || (a = "channel");
  a.match(/:\/\//) && a.replace(/^ws/, "http");
  b || (b = {});
  if(x(b || "string" === typeof b)) {
    b = {}
  }
  q = b.reconnectTime || 3E3;
  v = function(a) {
    y.readyState = y.readyState = a
  };
  v(this.CLOSED);
  p = m;
  g = b.Jc;
  c = function() {
    var a, b;
    b = arguments[0];
    a = 2 <= arguments.length ? je.call(arguments, 1) : [];
    try {
      return"function" === typeof y[b] ? y[b].apply(y, a) : h
    }catch(c) {
      a = c, "undefined" !== typeof console && console !== m && console.error(a.stack), e(a)
    }
  };
  d = new he;
  d.channelOpened = function() {
    g = p;
    v($.OPEN);
    return c("onopen")
  };
  f = m;
  d.channelError = function(a, b) {
    var d;
    d = ie[b];
    f = b;
    v($.bb);
    try {
      return c("onerror", d, b)
    }catch(g) {
    }
  };
  n = m;
  d.channelClosed = function(a, d, g) {
    if(y.readyState !== $.CLOSED) {
      p = m;
      a = f ? ie[f] : "Closed";
      v($.CLOSED);
      try {
        c("onclose", a, d, g)
      }catch(ke) {
      }
      b.reconnect && (7 !== f && 0 !== f) && (d = 6 === f ? 0 : q, clearTimeout(n), n = setTimeout(k, d));
      return f = m
    }
  };
  d.channelHandleArray = function(a, b) {
    return c("onmessage", b)
  };
  k = function() {
    p && e(Error("Reconnect() called from invalid state"));
    v($.CONNECTING);
    c("onconnecting");
    clearTimeout(n);
    p = new Od(b.appVersion, g != m ? g.Bb : h);
    b.crossDomainXhr && (p.Ya = l);
    p.e = d;
    f = m;
    if(b.failFast) {
      var k = p;
      k.Ia = l;
      k.a.info("setFailFast: true");
      if((k.o || k.D) && k.U > (k.Ia ? 0 : k.jb)) {
        k.a.info("Retry count " + k.U + " > new maxRetries " + (k.Ia ? 0 : k.jb) + ". Fail immediately!"), k.o ? (k.o.cancel(), k.la(k.o)) : (w.clearTimeout(k.D), k.D = m, Z(k, 2))
      }
    }
    return p.fb("" + a + "/test", "" + a + "/bind", m, g != m ? g.Y : h, g != m ? g.xa : h)
  };
  this.open = function() {
    y.readyState !== y.CLOSED && e(Error("Already open"));
    return k()
  };
  this.close = function() {
    clearTimeout(n);
    f = 0;
    if(y.readyState !== $.CLOSED) {
      return v($.bb), p.disconnect()
    }
  };
  this.sendMap = function(a) {
    var b;
    ((b = y.readyState) === $.bb || b === $.CLOSED) && e(Error("Cannot send to a closed connection"));
    b = p;
    0 == b.c && e(Error("Invalid operation: sending map when state is closed"));
    1E3 == b.s.length && b.a.H("Already have 1000 queued maps upon queueing " + Oc(a));
    b.s.push(new Qd(b.pc++, a));
    (2 == b.c || 3 == b.c) && ae(b)
  };
  this.send = function(a) {
    return this.sendMap({JSON:Oc(a)})
  };
  k();
  return this
};
$.prototype.CONNECTING = $.CONNECTING = $.CONNECTING = 0;
$.prototype.OPEN = $.OPEN = $.OPEN = 1;
$.prototype.CLOSING = $.CLOSING = $.bb = 2;
$.prototype.CLOSED = $.CLOSED = $.CLOSED = 3;
("undefined" !== typeof exports && exports !== m ? exports : window).BCSocket = $;

})();

},{}],2:[function(require,module,exports){
(function(process,__dirname){var EventEmitter = require('events').EventEmitter;
var Model = require('./Model');
var util = require('./util');

module.exports = Racer;

function Racer() { EventEmitter.call(this); }

util.mergeInto(Racer.prototype, EventEmitter.prototype);

// Make classes accessible for use by plugins and tests
Racer.prototype.Model = Model;
Racer.prototype.util = util;

// Support plugins on racer instances
Racer.prototype.use = util.use;

Racer.prototype.init = function(data) {
  var racer = this;

  process.env.NODE_ENV = data.nodeEnv;

  // Init is executed async so that plugins can extend Racer even if they are
  // included after the main entry point in the bundle
  process.nextTick(function() {
    var model = new Model;

    racer.emit('model', model);

    model._createConnection(data);

    // Re-create documents for all model data
    for (var collectionName in data.collections) {
      var collection = data.collections[collectionName];
      for (var id in collection) {
        var doc = model.getOrCreateDoc(collectionName, id, collection[id]);
        if (doc.shareDoc) {
          model._loadVersions[collectionName + '.' + id] = doc.shareDoc.version;
        }
      }
    }

    // TODO: Support re-init when there are contexts other than root
    var context = data.contexts.root;
    // Re-subscribe to document subscriptions
    for (var path in context.subscribedDocs) {
      var segments = path.split('.');
      model.subscribeDoc(segments[0], segments[1]);
      model._subscribedDocs[path] = context.subscribedDocs[path];
    }
    // Init fetchedDocs counts
    for (var path in context.fetchedDocs) {
      model._fetchedDocs[path] = context.fetchedDocs[path];
    }

    var silentModel = model.silent();
    // Re-create refs
    for (var i = 0; i < data.refs.length; i++) {
      var item = data.refs[i];
      silentModel.ref(item[0], item[1]);
    }
    // Re-create refLists
    for (var i = 0; i < data.refLists.length; i++) {
      var item = data.refLists[i];
      silentModel.refList(item[0], item[1], item[2], item[3]);
    }
    // Re-create fns
    for (var i = 0; i < data.fns.length; i++) {
      var item = data.fns[i];
      silentModel.start.apply(silentModel, item);
    }
    // Re-create filters
    for (var i = 0; i < data.filters.length; i++) {
      var item = data.filters[i];
      var filter = silentModel._filters.add(item[0], item[1], item[2]);
      filter.ref(item[3]);
    }
    // Init and re-subscribe queries as appropriate
    model._initQueries(data.queries);

    racer._model = model;
    racer.emit('ready', model);
  });
  return this;
};

Racer.prototype.ready = function(cb) {
  if (this._model) {
    // Callback async in case the code depends on scripts included after in
    // the bundle and is gated by a ready
    process.nextTick(function() {
      cb(this._model);
    });
    return;
  }
  this.once('ready', cb);
};

util.serverRequire(__dirname + '/Racer.server.js');

})(require("__browserify_process"),"/node_modules/racer/lib")
},{"events":6,"./util":7,"./Model":8,"__browserify_process":5}],7:[function(require,module,exports){
(function(process){var deepIs = require('deep-is');

var isServer = process.title !== 'browser';
var isProduction = process.env.NODE_ENV === 'production';

module.exports = {
  isServer: isServer
, isProduction: isProduction

, asyncGroup: asyncGroup
, contains: contains
, copyObject: copyObject
, deepCopy: deepCopy
, deepEqual: deepIs
, equal: equal
, equalsNaN: equalsNaN
, mergeInto: mergeInto
, mayImpact: mayImpact
, mayImpactAny: mayImpactAny
, serverRequire: serverRequire
, use: use
};

function asyncGroup(cb) {
  var group = new AsyncGroup(cb);
  return function asyncGroupAdd() {
    return group.add();
  };
}

/**
 * @constructor
 * @param {Function} cb(err)
 */
function AsyncGroup(cb) {
  this.cb = cb;
  this.isDone = false;
  this.count = 0;
}
AsyncGroup.prototype.add = function() {
  this.count++;
  var self = this;
  return function(err) {
    self.count--;
    if (self.isDone) return;
    if (err) {
      self.isDone = true;
      self.cb(err);
      return;
    }
    if (self.count > 0) return;
    self.isDone = true;
    self.cb();
  };
};

function contains(segments, testSegments) {
  for (var i = 0; i < segments.length; i++) {
    if (segments[i] !== testSegments[i]) return false;
  }
  return true;
}

function copyObject(object) {
  var out = new object.constructor;
  for (var key in object) {
    if (object.hasOwnProperty(key)) {
      out[key] = object[key];
    }
  }
  return out;
}

function deepCopy(value) {
  if (value instanceof Date) return new Date(value);
  if (typeof value === 'object') {
    if (value === null) return null;
    var copy;
    if (Array.isArray(value)) {
      copy = [];
      for (var i = value.length; i--;) {
        copy[i] = deepCopy(value[i]);
      }
      return copy;
    }
    copy = new value.constructor;
    for (var key in value) {
      if (value.hasOwnProperty(key)) {
        copy[key] = deepCopy(value[key]);
      }
    }
    return copy;
  }
  return value;
}

function equal(a, b) {
  return (a === b) || (equalsNaN(a) && equalsNaN(b));
}

function equalsNaN(x) {
  return x !== x;
}

function mayImpactAny(segmentsList, testSegments) {
  for (var i = 0, len = segmentsList.length; i < len; i++) {
    if (mayImpact(segmentsList[i], testSegments)) return true;
  }
  return false;
}

function mayImpact(segments, testSegments) {
  var len = Math.min(segments.length, testSegments.length);
  for (var i = 0; i < len; i++) {
    if (segments[i] !== testSegments[i]) return false;
  }
  return true;
}

function mergeInto(to, from) {
  for (var key in from) {
    to[key] = from[key];
  }
  return to;
}

function serverRequire(name) {
  if (!isServer) return;
  // Tricks Browserify into not logging a warning
  var _require = require;
  return _require(name);
}

function use(plugin, options) {
  // Server-side plugins may be included via filename
  if (typeof plugin === 'string') {
    if (!isServer) return this;
    plugin = serverRequire(plugin);
  }

  // Don't include a plugin more than once
  var plugins = this._plugins || (this._plugins = []);
  if (plugins.indexOf(plugin) === -1) {
    plugins.push(plugin);
    plugin(this, options);
  }
  return this;
}

})(require("__browserify_process"))
},{"deep-is":9,"__browserify_process":5}],10:[function(require,module,exports){
var Model = require('./index');

exports.mixin = {};

Model.prototype._splitPath = function(subpath) {
  var path = this.path(subpath);
  return (path && path.split('.')) || [];
};

/**
 * Returns the path equivalent to the path of the current scoped model plus
 * (optionally) a suffix subpath
 *
 * @optional @param {String} subpath
 * @return {String} absolute path
 * @api public
 */
Model.prototype.path = function(subpath) {
  if (subpath == null || subpath === '') return (this._at) ? this._at : '';
  if (typeof subpath === 'string' || typeof subpath === 'number') {
    return (this._at) ? this._at + '.' + subpath : '' + subpath;
  }
  if (typeof subpath.path === 'function') return subpath.path();
};

Model.prototype.isPath = function(subpath) {
  return this.path(subpath) != null;
};

Model.prototype.scope = function(path) {
  var scoped = Object.create(this);
  scoped._at = path;
  return scoped;
};

/**
 * Create a model object scoped to a particular path.
 * Example:
 *     var user = model.at('users.1');
 *     user.set('username', 'brian');
 *     user.on('push', 'todos', function (todo) {
 *       // ...
 *     });
 *
 *  @param {String} segment
 *  @return {Model} a scoped model
 *  @api public
 */
Model.prototype.at = function(subpath) {
  var path = this.path(subpath);
  return this.scope(path);
};

/**
 * Returns a model scope that is a number of levels above the current scoped
 * path. Number of levels defaults to 1, so this method called without
 * arguments returns the model scope's parent model scope.
 *
 * @optional @param {Number} levels
 * @return {Model} a scoped model
 */
Model.prototype.parent = function(levels) {
  if (levels == null) levels = 1;
  var segments = this._splitPath();
  var len = Math.max(0, segments.length - levels);
  var path = segments.slice(0, len).join('.');
  return this.scope(path);
};

/**
 * Returns the last property segment of the current model scope path
 *
 * @optional @param {String} path
 * @return {String}
 */
Model.prototype.leaf = function(path) {
  if (!path) path = this.path();
  var i = path.lastIndexOf('.');
  return path.slice(i + 1);
};

},{"./index":8}],11:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('../util');
var Model = require('./index');

// This map determines which events get re-emitted as an 'all' event
Model.MUTATOR_EVENTS = {
  change: true
, insert: true
, remove: true
, move: true
, stringInsert: true
, stringRemove: true
, load: true
, unload: true
};

Model.INITS.push(function(model) {
  // Set max listeners to unlimited
  model.setMaxListeners(0);

  // Used in async methods to emit an error event if a callback is not supplied.
  // This will throw if there is no handler for model.on('error')
  model._defaultCallback = defaultCallback;
  function defaultCallback(err) {
    if (typeof err === 'string') err = new Error(err);
    if (err) model.emit('error', err);
  }

  model._mutatorEventQueue = null;
  model._pass = new Passed({}, {});
});

util.mergeInto(Model.prototype, EventEmitter.prototype);

// EventEmitter.prototype.on, EventEmitter.prototype.addListener, and
// EventEmitter.prototype.once return `this`. The Model equivalents return
// the listener instead, since it is made internally for method subscriptions
// and may need to be passed to removeListener.

Model.prototype._emit = EventEmitter.prototype.emit;
Model.prototype.emit = function(type) {
  if (Model.MUTATOR_EVENTS[type]) {
    if (this._silent) return this;
    var segments = arguments[1];
    var eventArgs = arguments[2];
    if (this._mutatorEventQueue) {
      this._mutatorEventQueue.push([type, segments, eventArgs]);
      return this;
    }
    this._mutatorEventQueue = [];
    this._emit(type, segments, eventArgs);
    this._emit('all', segments, [type].concat(eventArgs));
    while (this._mutatorEventQueue.length) {
      var queued = this._mutatorEventQueue.shift();
      type = queued[0];
      segments = queued[1];
      eventArgs = queued[2];
      this._emit(type, segments, eventArgs);
      this._emit('all', segments, [type].concat(eventArgs));
    }
    this._mutatorEventQueue = null;
    return this;
  }
  return this._emit.apply(this, arguments);
};

Model.prototype._on = EventEmitter.prototype.on;
Model.prototype.addListener =
Model.prototype.on = function(type, pattern, cb) {
  var listener = eventListener(this, pattern, cb);
  this._on(type, listener);
  return listener;
};

Model.prototype.once = function(type, pattern, cb) {
  var listener = eventListener(this, pattern, cb);
  function g() {
    var matches = listener.apply(null, arguments);
    if (matches) this.removeListener(type, g);
  }
  this._on(type, g);
  return g;
};

Model.prototype._removeAllListeners = EventEmitter.prototype.removeAllListeners;
Model.prototype.removeAllListeners = function(type, subpattern) {
  if (!this._events) return this;

  // If a pattern is specified without an event type, remove all model event
  // listeners under that pattern for all events
  if (!type) {
    for (var key in this._events) {
      this.removeAllListeners(key, subpattern);
    }
    return this;
  }

  var pattern = this.path(subpattern);
  // If no pattern is specified, remove all listeners like normal
  if (!pattern) {
    if (arguments.length === 0) {
      return this._removeAllListeners();
    } else {
      return this._removeAllListeners(type);
    }
  }

  // Remove all listeners for an event under a pattern
  var listeners = this.listeners(type);
  var segments = pattern.split('.');
  // Make sure to iterate in reverse, since the array might be
  // mutated as listeners are removed
  for (var i = listeners.length; i--;) {
    var listener = listeners[i];
    if (patternContained(pattern, segments, listener)) {
      this.removeListener(type, listener);
    }
  }
};

function patternContained(pattern, segments, listener) {
  var listenerSegments = listener.patternSegments;
  if (!listenerSegments) return false;
  if (pattern === listener.pattern || pattern === '**') return true;
  var len = segments.length;
  if (len > listenerSegments.length) return false;
  for (var i = 0; i < len; i++) {
    if (segments[i] !== listenerSegments[i]) return false;
  }
  return true;
}

Model.prototype.pass = function(object, invert) {
  var model = Object.create(this);
  if (invert) {
    model._pass = new Passed(object, this._pass);
  } else {
    model._pass = new Passed(this._pass, object);
  }
  return model;
};

function Passed(previous, value) {
  for (var key in previous) {
    this[key] = previous[key];
  }
  for (var key in value) {
    this[key] = value[key];
  }
}

/**
 * The returned Model will or won't trigger event handlers when the model emits
 * events, depending on `value`
 * @param {Boolean|Null} value defaults to true
 * @return {Model}
 */
Model.prototype.silent = function(value) {
  var model = Object.create(this);
  model._silent = (value == null) ? true : value;
  return model;
};

function eventListener(model, subpattern, cb) {
  if (cb) {
    // For signatures:
    // model.on('change', 'example.subpath', callback)
    // model.at('example').on('change', 'subpath', callback)
    var pattern = model.path(subpattern);
    return modelEventListener(pattern, cb);
  }
  var path = model.path();
  cb = arguments[1];
  // For signature:
  // model.at('example').on('change', callback)
  if (path) return modelEventListener(path, cb);
  // For signature:
  // model.on('normalEvent', callback)
  return cb;
}

function modelEventListener(pattern, cb) {
  var patternSegments = pattern.split('.');
  var testFn = testPatternFn(pattern, patternSegments);

  function modelListener(segments, eventArgs) {
    var captures = testFn(segments);
    if (!captures) return;

    var args = (captures.length) ? captures.concat(eventArgs) : eventArgs;
    cb.apply(null, args);
    return true;
  }

  // Used in Model#removeAllListeners
  modelListener.pattern = pattern;
  modelListener.patternSegments = patternSegments;

  return modelListener;
}

function testPatternFn(pattern, patternSegments) {
  if (pattern === '**') {
    return function testPattern(segments) {
      return [segments.join('.')];
    };
  }

  var endingRest = stripRestWildcard(patternSegments);

  return function testPattern(segments) {
    // Any pattern with more segments does not match
    var patternLen = patternSegments.length;
    if (patternLen > segments.length) return;

    // A pattern with the same number of segments matches if each
    // of the segments are wildcards or equal. A shorter pattern matches
    // if it ends in a rest wildcard and each of the corresponding
    // segments are wildcards or equal.
    if (patternLen === segments.length || endingRest) {
      var captures = [];
      for (var i = 0; i < patternLen; i++) {
        var patternSegment = patternSegments[i];
        var segment = segments[i];
        if (patternSegment === '*' || patternSegment === '**') {
          captures.push(segment);
          continue;
        }
        if (patternSegment !== segment) return;
      }
      if (endingRest) {
        var remainder = segments.slice(i).join('.');
        captures.push(remainder);
      }
      return captures;
    }
  };
}

function stripRestWildcard(segments) {
  // ['example', 'subpath**'] -> ['example', 'subpath']
  var lastIndex = segments.length - 1;
  var match = /^([^\*]+)\*\*$/.exec(segments[lastIndex]);
  if (!match) return false;
  segments[lastIndex] = match[1];
  return true;
}

},{"events":6,"../util":7,"./index":8}],12:[function(require,module,exports){
var Model = require('./index');
var LocalDoc = require('./LocalDoc');
var RemoteDoc = require('./RemoteDoc');

Model.INITS.push(function(model) {
  model.collections = new CollectionMap;
});

Model.prototype.getCollection = function(collectionName) {
  return this.collections[collectionName];
};
Model.prototype.getDoc = function(collectionName, id) {
  var collection = this.collections[collectionName];
  return collection && collection.docs[id];
};
Model.prototype.get = function(subpath) {
  var segments = this._splitPath(subpath);
  return this._get(segments);
};
Model.prototype._get = function(segments) {
  segments = this._dereference(segments);
  var collectionName = segments[0];
  if (!collectionName) {
    return getEach(this.collections);
  }
  var id = segments[1];
  if (!id) {
    var collection = this.getCollection(collectionName);
    return collection && getEach(collection.docs);
  }
  var doc = this.getDoc(collectionName, id);
  return doc && doc.get(segments.slice(2));
};
Model.prototype.getOrCreateCollection = function(name) {
  var collection = this.collections[name];
  if (collection) return collection;
  // Whether the collection is local or remote is determined by its name.
  // Collections starting with an underscore ('_') are for user-defined local
  // collections, those starting with a dollar sign ('$'') are for
  // framework-defined local collections, and all others are remote.
  var firstCharcter = name.charAt(0);
  var isLocal = (firstCharcter === '_' || firstCharcter === '$');
  var Doc = (isLocal) ? LocalDoc : RemoteDoc;
  collection = new Collection(this, name, Doc);
  this.collections[name] = collection;
  return collection;
};

/**
 * Returns an existing document with id in a collection. If the document does
 * not exist, then creates the document with id in a collection and returns the
 * new document.
 * @param {String} collectionName
 * @param {String} id
 * @param {Object} [data] data to create if doc with id does not exist in collection
 */
Model.prototype.getOrCreateDoc = function(collectionName, id, data) {
  var collection = this.getOrCreateCollection(collectionName);
  return collection.docs[id] || collection.add(id, data);
};

/**
 * @param {String} collectionName
 */
Model.prototype.destroy = function(collectionName) {
  // TODO: non-collections
  var collection = this.getCollection(collectionName);
  collection && collection.destroy();
  this.removeAllRefs(collectionName);
  this.stopAll(collectionName);
  this.removeAllFilters(collectionName);
  this.removeAllListeners(null, collectionName);
};

function CollectionMap() {}
function DocMap() {}
function Collection(model, name, Doc) {
  this.model = model;
  this.name = name;
  this.Doc = Doc;
  this.docs = new DocMap();
}

/**
 * Adds a document with `id` and `data` to `this` Collection.
 * @param {String} id
 * @param {Object} data
 * @return {LocalDoc|RemoteDoc} doc
 */
Collection.prototype.add = function(id, data) {
  var doc = new this.Doc(this.name, id, data, this.model);
  this.docs[id] = doc;
  return doc;
};
Collection.prototype.destroy = function() {
  delete this.model.collections[this.name];
};

/**
 * Removes the document with `id` from `this` Collection. If there are no more
 * documents in the Collection after the given document is removed, then this
 * also destroys the Collection.
 * @param {String} id
 */
Collection.prototype.remove = function(id) {
  delete this.docs[id];
  if (noKeys(this.docs)) this.destroy();
};

/**
 * Returns an object that maps doc ids to fully resolved documents.
 * @return {Object}
 */
Collection.prototype.get = function() {
  return getEach(this.docs);
};

function getEach(object) {
  if (!object) return;
  var result = {};
  for (var key in object) {
    result[key] = object[key].get();
  }
  return result;
}

function noKeys(object) {
  for (var key in object) {
    return false;
  }
  return true;
}

},{"./index":8,"./LocalDoc":13,"./RemoteDoc":14}],15:[function(require,module,exports){
var util = require('../util');
var Model = require('./index');

Model.prototype._mutate = function(segments, fn, cb) {
  if (!cb) cb = this._defaultCallback;
  var collectionName = segments[0];
  var id = segments[1];
  if (!collectionName || !id) {
    var message = fn.name + ' must be performed under a collection ' +
      'and document id. Invalid path: ' + segments.join('.');
    return cb(new Error(message));
  }
  var doc = this.getOrCreateDoc(collectionName, id);
  var docSegments = segments.slice(2);
  return fn(doc, docSegments, cb);
};

Model.prototype.set = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._set(segments, value, cb);
};
Model.prototype._set = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function set(doc, docSegments, fnCb) {
    var previous = doc.set(docSegments, value, fnCb);
    model.emit('change', segments, [value, previous, model._pass]);
    return previous;
  }
  return this._mutate(segments, set, cb);
};

Model.prototype.setEach = function() {
  var subpath, object, cb;
  if (arguments.length === 1) {
    object = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    object = arguments[1];
  } else {
    subpath = arguments[0];
    object = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._setEach(segments, object, cb);
};
Model.prototype._setEach = function(segments, object, cb) {
  segments = this._dereference(segments);
  var group = util.asyncGroup(cb || this._defaultCallback);
  for (var key in object) {
    var value = object[key];
    this._set(segments.concat(key), value, group());
  }
};

Model.prototype.add = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._add(segments, value, cb);
};
Model.prototype._add = function(segments, value, cb) {
  if (typeof value !== 'object') {
    var message = 'add requires an object value. Invalid value: ' + value;
    cb || (cb = this._defaultCallback);
    return cb(new Error(message));
  }
  var id = value.id || this.id();
  value.id = id;
  this._set(segments.concat(id), value, cb);
  return id;
};

Model.prototype.setNull = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._setNull(segments, value, cb);
};
Model.prototype._setNull = function(segments, value, cb) {
  segments = this._dereference(segments);
  var model = this;
  function setNull(doc, docSegments, fnCb) {
    var previous = doc.get(docSegments);
    if (previous != null) {
      fnCb();
      return previous;
    }
    doc.set(docSegments, value, fnCb);
    model.emit('change', segments, [value, previous, model._pass]);
    return value;
  }
  return this._mutate(segments, setNull, cb);
};

Model.prototype.del = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._del(segments, cb);
};
Model.prototype._del = function(segments, cb) {
  segments = this._dereference(segments);
  var model = this;
  function del(doc, docSegments, fnCb) {
    var previous = doc.del(docSegments, fnCb);
    // When deleting an entire document, also remove the reference to the
    // document object from its collection
    if (segments.length === 2) {
      var collectionName = segments[0];
      var id = segments[1];
      model.collections[collectionName].remove(id);
    }
    model.emit('change', segments, [void 0, previous, model._pass]);
    return previous;
  }
  return this._mutate(segments, del, cb);
};

Model.prototype.increment = function() {
  var subpath, byNumber, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else if (typeof arguments[0] === 'number') {
      byNumber = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      cb = arguments[1];
      if (typeof arguments[0] === 'number') {
        byNumber = arguments[0];
      } else {
        subpath = arguments[0];
      }
    } else {
      subpath = arguments[0];
      byNumber = arguments[1];
    }
  } else {
    subpath = arguments[0];
    byNumber = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._increment(segments, byNumber, cb);
};
Model.prototype._increment = function(segments, byNumber, cb) {
  segments = this._dereference(segments);
  if (byNumber == null) byNumber = 1;
  var model = this;
  function increment(doc, docSegments, fnCb) {
    var value = doc.increment(docSegments, byNumber, fnCb);
    var previous = value - byNumber;
    model.emit('change', segments, [value, previous, model._pass]);
    return value;
  }
  return this._mutate(segments, increment, cb);
};

Model.prototype.push = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._push(segments, value, cb);
};
Model.prototype._push = function(segments, value, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function push(doc, docSegments, fnCb) {
    var length = doc.push(docSegments, value, fnCb);
    model.emit('insert', segments, [length - 1, [value], model._pass]);
    return length;
  }
  return this._mutate(segments, push, cb);
};

Model.prototype.unshift = function() {
  var subpath, value, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else {
    subpath = arguments[0];
    value = arguments[1];
    cb = arguments[2];
  }
  var segments = this._splitPath(subpath);
  return this._unshift(segments, value, cb);
};
Model.prototype._unshift = function(segments, value, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function unshift(doc, docSegments, fnCb) {
    var length = doc.unshift(docSegments, value, fnCb);
    model.emit('insert', segments, [0, [value], model._pass]);
    return length;
  }
  return this._mutate(segments, unshift, cb);
};

Model.prototype.insert = function() {
  var subpath, index, values, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for insert'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    values = arguments[1];
  } else if (arguments.length === 3) {
    subpath = arguments[0];
    index = arguments[1];
    values = arguments[2];
  } else {
    subpath = arguments[0];
    index = arguments[1];
    values = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._insert(segments, index, values, cb);
};
Model.prototype._insert = function(segments, index, values, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function insert(doc, docSegments, fnCb) {
    var inserted = (Array.isArray(values)) ? values : [values];
    var length = doc.insert(docSegments, index, inserted, fnCb);
    model.emit('insert', segments, [index, inserted, model._pass]);
    return length;
  }
  return this._mutate(segments, insert, cb);
};

Model.prototype.pop = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._pop(segments, cb);
};
Model.prototype._pop = function(segments, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function pop(doc, docSegments, fnCb) {
    var arr = doc.get(docSegments);
    var length = arr && arr.length;
    if (!length) {
      fnCb();
      return;
    }
    var value = doc.pop(docSegments, fnCb);
    model.emit('remove', segments, [length - 1, [value], model._pass]);
    return value;
  }
  return this._mutate(segments, pop, cb);
};

Model.prototype.shift = function() {
  var subpath, cb;
  if (arguments.length === 1) {
    if (typeof arguments[0] === 'function') {
      cb = arguments[0];
    } else {
      subpath = arguments[0];
    }
  } else {
    subpath = arguments[0];
    cb = arguments[1];
  }
  var segments = this._splitPath(subpath);
  return this._shift(segments, cb);
};
Model.prototype._shift = function(segments, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  var model = this;
  function shift(doc, docSegments, fnCb) {
    var arr = doc.get(docSegments);
    var length = arr && arr.length;
    if (!length) {
      fnCb();
      return;
    }
    var value = doc.shift(docSegments, fnCb);
    model.emit('remove', segments, [0, [value], model._pass]);
    return value;
  }
  return this._mutate(segments, shift, cb);
};

Model.prototype.remove = function() {
  var subpath, index, howMany, cb;
  if (arguments.length === 1) {
    index = arguments[0];
  } else if (arguments.length === 2) {
    if (typeof arguments[1] === 'function') {
      cb = arguments[1];
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
      } else {
        subpath = arguments[0];
      }
    } else {
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
        howMany = arguments[1];
      } else {
        subpath = arguments[0];
        index = arguments[1];
      }
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      cb = arguments[2];
      if (typeof arguments[0] === 'number') {
        index = arguments[0];
        howMany = arguments[1];
      } else {
        subpath = arguments[0];
        index = arguments[1];
      }
    } else {
      subpath = arguments[0];
      index = arguments[1];
      howMany = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    howMany = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  if (index == null) index = +segments.pop();
  return this._remove(segments, index, howMany, cb);
};
Model.prototype._remove = function(segments, index, howMany, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  if (howMany == null) howMany = 1;
  var model = this;
  function remove(doc, docSegments, fnCb) {
    var removed = doc.remove(docSegments, index, howMany, fnCb);
    model.emit('remove', segments, [index, removed, model._pass]);
    return removed;
  }
  return this._mutate(segments, remove, cb);
};

Model.prototype.move = function() {
  var subpath, from, to, howMany, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for move'));
  } else if (arguments.length === 2) {
    from = arguments[0];
    to = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      from = arguments[0];
      to = arguments[1];
      cb = arguments[2];
    } else if (typeof arguments[0] === 'number') {
      from = arguments[0];
      to = arguments[1];
      howMany = arguments[2];
    } else {
      subpath = arguments[0];
      from = arguments[1];
      to = arguments[2];
    }
  } else if (arguments.length === 4) {
    if (typeof arguments[3] === 'function') {
      cb = arguments[3];
      if (typeof arguments[0] === 'number') {
        from = arguments[0];
        to = arguments[1];
        howMany = arguments[2];
      } else {
        subpath = arguments[0];
        from = arguments[1];
        to = arguments[2];
      }
    } else {
      subpath = arguments[0];
      from = arguments[1];
      to = arguments[2];
      howMany = arguments[3];
    }
  } else {
    subpath = arguments[0];
    from = arguments[1];
    to = arguments[2];
    howMany = arguments[3];
    cb = arguments[4];
  }
  var segments = this._splitPath(subpath);
  return this._move(segments, from, to, howMany, cb);
};
Model.prototype._move = function(segments, from, to, howMany, cb) {
  var forArrayMutator = true;
  segments = this._dereference(segments, forArrayMutator);
  if (howMany == null) howMany = 1;
  var model = this;
  function move(doc, docSegments, fnCb) {
    // Cast to numbers
    from = +from;
    to = +to;
    // Convert negative indices into positive
    if (from < 0 || to < 0) {
      var len = doc.get(docSegments).length;
      if (from < 0) from += len;
      if (to < 0) to += len;
    }
    var moved = doc.move(docSegments, from, to, howMany, fnCb);
    model.emit('move', segments, [from, to, moved.length, model._pass]);
    return moved;
  }
  return this._mutate(segments, move, cb);
};

Model.prototype.stringInsert = function() {
  var subpath, index, text, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for stringInsert'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    text = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      index = arguments[0];
      text = arguments[1];
      cb = arguments[2];
    } else {
      subpath = arguments[0];
      index = arguments[1];
      text = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    text = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._stringInsert(segments, index, text, cb);
};
Model.prototype._stringInsert = function(segments, index, text, cb) {
  segments = this._dereference(segments);
  var model = this;
  function stringInsert(doc, docSegments, fnCb) {
    var previous = doc.stringInsert(docSegments, index, text, fnCb);
    model.emit('stringInsert', segments, [index, text, model._pass]);
    var value = doc.get(docSegments);
    var pass = model.pass({$original: 'stringInsert'})._pass;
    model.emit('change', segments, [value, previous, pass]);
    return;
  }
  return this._mutate(segments, stringInsert, cb);
};

Model.prototype.stringRemove = function() {
  var subpath, index, howMany, cb;
  if (arguments.length === 1) {
    this.emit('error', new Error('Not enough arguments for stringRemove'));
  } else if (arguments.length === 2) {
    index = arguments[0];
    howMany = arguments[1];
  } else if (arguments.length === 3) {
    if (typeof arguments[2] === 'function') {
      index = arguments[0];
      howMany = arguments[1];
      cb = arguments[2];
    } else {
      subpath = arguments[0];
      index = arguments[1];
      howMany = arguments[2];
    }
  } else {
    subpath = arguments[0];
    index = arguments[1];
    howMany = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._stringRemove(segments, index, howMany, cb);
};
Model.prototype._stringRemove = function(segments, index, howMany, cb) {
  segments = this._dereference(segments);
  var model = this;
  function stringRemove(doc, docSegments, fnCb) {
    var previous = doc.stringRemove(docSegments, index, howMany, fnCb);
    model.emit('stringRemove', segments, [index, howMany, model._pass]);
    var value = doc.get(docSegments);
    var pass = model.pass({$original: 'stringRemove'})._pass;
    model.emit('change', segments, [value, previous, pass]);
    return;
  }
  return this._mutate(segments, stringRemove, cb);
};

},{"../util":7,"./index":8}],16:[function(require,module,exports){
(function(process){var util = require('../util');
var Model = require('./index');
var Query = require('./Query');

Model.INITS.push(function(model, options) {
  model.fetchOnly = options.fetchOnly;
  model.unloadDelay = options.unloadDelay || 1000;

  // Keeps track of the count of fetches (that haven't been undone by an
  // unfetch) per doc. Maps doc id to the fetch count.
  model._fetchedDocs = new FetchedDocs;

  // Keeps track of the count of subscribes (that haven't been undone by an
  // unsubscribe) per doc. Maps doc id to the subscribe count.
  model._subscribedDocs = new SubscribedDocs;

  // Maps doc path to doc version
  model._loadVersions = new LoadVersions;
});

function FetchedDocs() {}
function SubscribedDocs() {}
function LoadVersions() {}

Model.prototype.fetch = function() {
  this._forSubscribable(arguments, 'fetch');
  return this;
};
Model.prototype.unfetch = function() {
  this._forSubscribable(arguments, 'unfetch');
  return this;
};
Model.prototype.subscribe = function() {
  this._forSubscribable(arguments, 'subscribe');
  return this;
};
Model.prototype.unsubscribe = function() {
  this._forSubscribable(arguments, 'unsubscribe');
  return this;
};

/**
 * @private
 * @param {Arguments} argumentsObject can take 1 of two forms
 *   1. [[subscribableObjects...], cb]
 *   2. [subscribableObjects..., cb]
 * @param {String} method can be 'fetch', 'unfetch', 'subscribe', 'unsubscribe'
 */
Model.prototype._forSubscribable = function(argumentsObject, method) {
  if (Array.isArray(argumentsObject[0])) {
    var args = argumentsObject[0];
    var cb = argumentsObject[1] || this._defaultCallback;
  } else {
    var args = Array.prototype.slice.call(argumentsObject);
    var last = args[args.length - 1];
    var cb = (typeof last === 'function') ? args.pop() : this._defaultCallback;
  }
  // If no queries or paths are passed in, try to use this model's scope
  if (!args.length) args.push(null);
  var group = util.asyncGroup(cb);
  var docMethod = method + 'Doc';

  var finished = group();
  for (var i = 0; i < args.length; i++) {
    var item = args[i];
    if (item instanceof Query) {
      item[method](group());
    } else {
      var segments = this._dereference(this._splitPath(item));
      if (segments.length === 2) {
        // Do the appropriate method for a single document.
        this[docMethod](segments[0], segments[1], group());
      } else if (segments.length === 1) {
        // Make a query to an entire collection.
        var query = this.query(segments[0], {});
        query[method](group());
      } else if (segments.length === 0) {
        var message = 'No path specified for ' + method;
        this.emit('error', new Error(message));
      } else {
        var message = 'Cannot ' + method + ' to a path within a document: ' +
          segments.join('.');
        this.emit('error', new Error(message));
      }
    }
  }
  finished();
};

/**
 * @param {String}
 * @param {String} id
 * @param {Function} cb(err)
 * @param {Boolean} alreadyLoaded
 */
Model.prototype.fetchDoc = function(collectionName, id, cb, alreadyLoaded) {
  if (!cb) cb = this._defaultCallback;

  // Maintain a count of fetches so that we can unload the document when
  // there are no remaining fetches or subscribes for that document
  var path = collectionName + '.' + id;
  this.emit('fetchDoc', path, this._context, this._pass);
  this._fetchedDocs[path] = (this._fetchedDocs[path] || 0) + 1;

  var model = this;
  var doc = this.getOrCreateDoc(collectionName, id);
  if (alreadyLoaded) {
    process.nextTick(fetchDocCallback);
  } else {
    doc.shareDoc.fetch(fetchDocCallback);
  }
  function fetchDocCallback(err) {
    if (err) return cb(err);
    if (doc.shareDoc.version !== model._loadVersions[path]) {
      model._loadVersions[path] = doc.shareDoc.version;
      model.emit('load', [collectionName, id], [doc.get(), model._pass]);
    }
    cb();
  }
};

/**
 * @param {String} collectionName
 * @param {String} id of the document we want to subscribe to
 * @param {Function} cb(err)
 */
Model.prototype.subscribeDoc = function(collectionName, id, cb) {
  if (!cb) cb = this._defaultCallback;

  var path = collectionName + '.' + id;
  this.emit('subscribeDoc', path, this._context, this._pass);
  var count = this._subscribedDocs[path] = (this._subscribedDocs[path] || 0) + 1;
  // Already requested a subscribe, so just return
  if (count > 1) return cb();

  // Subscribe if currently unsubscribed
  var model = this;
  var doc = this.getOrCreateDoc(collectionName, id);
  if (this.fetchOnly) {
    // Only fetch if the document isn't already loaded
    if (doc.get() === void 0) {
      doc.shareDoc.fetch(subscribeDocCallback);
    } else {
      process.nextTick(subscribeDocCallback);
    }
  } else {
    doc.shareDoc.subscribe(subscribeDocCallback);
  }
  function subscribeDocCallback(err) {
    if (err) return cb(err);
    if (!doc.createdLocally && doc.shareDoc.version !== model._loadVersions[path]) {
      model._loadVersions[path] = doc.shareDoc.version;
      model.emit('load', [collectionName, id], [doc.get(), model._pass]);
    }
    cb();
  }
};

Model.prototype.unfetchDoc = function(collectionName, id, cb) {
  if (!cb) cb = this._defaultCallback;
  var path = collectionName + '.' + id;
  this.emit('unfetchDoc', path, this._context, this._pass);
  var fetchedDocs = this._fetchedDocs;

  // No effect if the document has no fetch count
  if (!fetchedDocs[path]) return cb();

  var model = this;
  if (this.unloadDelay && !this._pass.$query) {
    setTimeout(finishUnfetchDoc, this.unloadDelay);
  } else {
    finishUnfetchDoc();
  }
  function finishUnfetchDoc() {
    var count = --fetchedDocs[path];
    if (count) return cb(null, count);
    delete fetchedDocs[path];
    model._maybeUnloadDoc(collectionName, id, path);
    cb(null, 0);
  }
};

Model.prototype.unsubscribeDoc = function(collectionName, id, cb) {
  if (!cb) cb = this._defaultCallback;
  var path = collectionName + '.' + id;
  this.emit('unsubscribeDoc', path, this._context, this._pass);
  var subscribedDocs = this._subscribedDocs;

  // No effect if the document is not currently subscribed
  if (!subscribedDocs[path]) return cb();

  var model = this;
  if (this.unloadDelay && !this._pass.$query) {
    setTimeout(finishUnsubscribeDoc, this.unloadDelay);
  } else {
    finishUnsubscribeDoc();
  }
  function finishUnsubscribeDoc() {
    var count = --subscribedDocs[path];
    // If there are more remaining subscriptions, only decrement the count
    // and callback with how many subscriptions are remaining
    if (count) return cb(null, count);

    // If there is only one remaining subscription, actually unsubscribe
    delete subscribedDocs[path];
    if (model.fetchOnly) {
      unsubscribeDocCallback();
    } else {
      var shareDoc = model.shareConnection.get(collectionName, id);
      if (!shareDoc) {
        return cb(new Error('Share document not found for: ' + path));
      }
      shareDoc.unsubscribe(unsubscribeDocCallback);
    }
  }
  function unsubscribeDocCallback(err) {
    model._maybeUnloadDoc(collectionName, id, path);
    if (err) return cb(err);
    cb(null, 0);
  }
};

/**
 * Removes the document from the local model if the model no longer has any
 * remaining fetches or subscribes on path.
 * Called from Model.prototype.unfetchDoc and Model.prototype.unsubscribeDoc as
 * part of attempted cleanup.
 * @param {String} collectionName
 * @param {String} id
 * @param {String} path
 */
Model.prototype._maybeUnloadDoc = function(collectionName, id, path) {
  var doc = this.getDoc(collectionName, id);
  if (!doc) return;
  // Remove the document from the local model if it no longer has any
  // remaining fetches or subscribes
  if (this._fetchedDocs[path] || this._subscribedDocs[path]) return;
  var previous = doc.get();
  this.collections[collectionName].remove(id);
  if (doc.shareDoc) doc.shareDoc.destroy();
  delete this._loadVersions[path];
  this.emit('unload', [collectionName, id], [previous, this._pass]);
};

Model.prototype._getOrCreateShareDoc = function(collectionName, id, data) {
  var shareDoc = this.shareConnection.getOrCreate(collectionName, id, data);
  shareDoc.incremental = true;
  return shareDoc;
};

})(require("__browserify_process"))
},{"../util":7,"./index":8,"./Query":17,"__browserify_process":5}],18:[function(require,module,exports){
/**
 * Contexts are useful for keeping track of the origin of subscribes.
 */

var Model = require('./index');
var Query = require('./Query');

Model.INITS.push(function(model) {
  model._contexts = new Contexts;
  model.setContext('root');
  [ 'fetchDoc', 'subscribeDoc', 'unfetchDoc', 'unsubscribeDoc'
  , 'fetchQuery', 'subscribeQuery', 'unfetchQuery', 'unsubscribeQuery'
  ].forEach(function(event) {
    model.on(event, function(item, context, pass) {
      context[event](item, pass);
    });
  });
});

Model.prototype.context = function(id) {
  var model = Object.create(this);
  model.setContext(id);
  return model;
};

Model.prototype.setContext = function(id) {
  var context = this._contexts[id] || new Context(this, id);
  this._context = this._contexts[id] = context;
  return context;
};

Model.prototype.unload = function(id) {
  var context = (id) ? this._contexts[id] : this._context;
  context.unload();
};

function Contexts() {}

function FetchedDocs() {}
function SubscribedDocs() {}
function FetchedQueries() {}
function SubscribedQueries() {}

function Context(model, id) {
  this.model = model;
  this.id = id;
  this.fetchedDocs = new FetchedDocs;
  this.subscribedDocs = new SubscribedDocs;
  this.fetchedQueries = new FetchedQueries;
  this.subscribedQueries = new SubscribedQueries;
}

Context.prototype.toJSON = function() {
  return {
    fetchedDocs: this.fetchedDocs
  , subscribedDocs: this.subscribedDocs
  , fetchedQueries: this.fetchedQueries
  , subscribedQueries: this.subscribedQueries
  };
};

Context.prototype.fetchDoc = function(path, pass) {
  if (pass.$query) return;
  mapIncrement(this.fetchedDocs, path);
};
Context.prototype.subscribeDoc = function(path, pass) {
  if (pass.$query) return;
  mapIncrement(this.subscribedDocs, path);
};
Context.prototype.unfetchDoc = function(path, pass) {
  if (pass.$query) return;
  mapDecrement(this.fetchedDocs, path);
};
Context.prototype.unsubscribeDoc = function(path, pass) {
  if (pass.$query) return;
  mapDecrement(this.subscribedDocs, path);
};
Context.prototype.fetchQuery = function(query) {
  mapIncrement(this.fetchedQueries, query.hash);
};
Context.prototype.subscribeQuery = function(query) {
  mapIncrement(this.subscribedQueries, query.hash);
};
Context.prototype.unfetchQuery = function(query) {
  mapDecrement(this.fetchedQueries, query.hash);
};
Context.prototype.unsubscribeQuery = function(query) {
  mapDecrement(this.subscribedQueries, query.hash);
};
function mapIncrement(map, key) {
  map[key] = (map[key] || 0) + 1;
}
function mapDecrement(map, key) {
  map[key] && map[key]--;
  if (!map[key]) delete map[key];
}

Context.prototype.unload = function() {
  var model = this.model;
  for (var hash in this.fetchedQueries) {
    var query = model._queries.map[hash];
    if (!query) continue;
    var count = this.fetchedQueries[hash];
    while (count--) query.unfetch(null);
  }
  for (var hash in this.subscribedQueries) {
    var query = model._queries.map[hash];
    if (!query) continue;
    var count = this.subscribedQueries[hash];
    while (count--) query.unsubscribe(null);
  }
  for (var path in this.fetchedDocs) {
    var segments = path.split('.');
    var count = this.fetchedDocs[path];
    while (count--) model.unfetchDoc(segments[0], segments[1]);
  }
  for (var path in this.subscribedDocs) {
    var segments = path.split('.');
    var count = this.subscribedDocs[path];
    while (count--) model.unsubscribeDoc(segments[0], segments[1]);
  }
  this.model._context = this.model._contexts[this.id] =
    new Context(this.model, this.id);
};

},{"./index":8,"./Query":17}],19:[function(require,module,exports){
var util = require('../util');
var Model = require('./index');
var defaultFns = require('./defaultFns');

Model.INITS.push(function(model) {
  model._namedFns = Object.create(defaultFns);
  model._fns = new Fns(model);
  model.on('all', fnListener);
  function fnListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    var map = model._fns.fromMap;
    for (var path in map) {
      var fn = map[path];
      if (pass.$fn === fn) continue;
      if (util.mayImpactAny(fn.inputsSegments, segments)) {
        // Mutation affecting input path
        fn.onInput(pass);
      } else if (util.mayImpact(fn.fromSegments, segments)) {
        // Mutation affecting output path
        fn.onOutput(pass);
      }
    }
  }
});

Model.prototype.fn = function(name, fns) {
  this._namedFns[name] = fns;
};

function parseStartArguments(model, args, hasPath) {
  if (typeof args[0] === 'function') {
    var fns = args[0];
  } else {
    var name = args[0];
  }
  if (hasPath) {
    var path = model.path(args[1]);
    var inputPaths = Array.prototype.slice.call(args, 2);
  } else {
    var inputPaths = Array.prototype.slice.call(args, 1);
  }
  var i = inputPaths.length - 1;
  if (model.isPath(inputPaths[i])) {
    inputPaths[i] = model.path(inputPaths[i]);
  } else {
    var options = inputPaths.pop();
  }
  while (i--) {
    inputPaths[i] = model.path(inputPaths[i]);
  }
  return {
    name: name
  , path: path
  , inputPaths: inputPaths
  , fns: fns
  , options: options
  };
}

Model.prototype.evaluate = function(name) {
  var args = parseStartArguments(this, arguments, false);
  return this._fns.get(args.name, args.inputPaths, args.fns, args.options);
};

Model.prototype.start = function(name, subpath) {
  var args = parseStartArguments(this, arguments, true);
  return this._fns.start(args.name, args.path, args.inputPaths, args.fns, args.options);
};

Model.prototype.stop = function(subpath) {
  var path = this.path(subpath);
  this._fns.stop(path);
};

Model.prototype.stopAll = function(subpath) {
  var segments = this._splitPath(subpath);
  var fns = this._fns.fromMap;
  for (var from in fns) {
    if (util.contains(segments, fns[from].fromSegments)) {
      this.stop(from);
    }
  }
};

function FromMap() {}
function Fns(model) {
  this.model = model;
  this.nameMap = model._namedFns;
  this.fromMap = new FromMap;
}

Fns.prototype.get = function(name, inputPaths, fns, options) {
  fns || (fns = this.nameMap[name]);
  var fn = new Fn(this.model, name, null, inputPaths, fns, options);
  return fn.get();
};

Fns.prototype.start = function(name, path, inputPaths, fns, options) {
  fns || (fns = this.nameMap[name]);
  var fn = new Fn(this.model, name, path, inputPaths, fns, options);
  this.fromMap[path] = fn;
  return fn.onInput();
};

Fns.prototype.stop = function(path) {
  var fn = this.fromMap[path];
  delete this.fromMap[path];
  return fn;
};

Fns.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var fn = this.fromMap[from];
    // Don't try to bundle non-named functions that were started via
    // model.start directly instead of by name
    if (!fn.name) continue;
    out.push([fn.name, fn.from].concat(fn.inputPaths));
  }
  return out;
};

function Fn(model, name, from, inputPaths, fns, options) {
  this.model = model.pass({$fn: this});
  this.name = name;
  this.from = from;
  this.inputPaths = inputPaths;
  if (!fns) {
    var err = new TypeError('Model function not found: ' + name);
    model.emit('error', err);
  }
  this.getFn = fns.get || fns;
  this.setFn = fns.set;
  this.fromSegments = from && from.split('.');
  this.inputsSegments = [];
  for (var i = 0; i < this.inputPaths.length; i++) {
    var segments = this.inputPaths[i].split('.');
    this.inputsSegments.push(segments);
  }
  var copy = (options && options.copy) || 'output';
  this.copyInput = (copy === 'input' || copy === 'both');
  this.copyOutput = (copy === 'output' || copy === 'both');
}

Fn.prototype.apply = function(fn, inputs) {
  for (var i = 0, len = this.inputsSegments.length; i < len; i++) {
    var input = this.model._get(this.inputsSegments[i]);
    inputs.push(this.copyInput ? util.deepCopy(input) : input);
  }
  return fn.apply(this.model, inputs);
};

Fn.prototype.get = function() {
  return this.apply(this.getFn, []);
};

var diffOptions = {equal: util.deepEqual};
var eachDiffOptions = {each: true, equal: util.deepEqual};

Fn.prototype.set = function(value, pass) {
  if (!this.setFn) return;
  var out = this.apply(this.setFn, [value]);
  if (!out) return;
  var inputsSegments = this.inputsSegments;
  var model = this.model.pass(pass, true);
  for (var key in out) {
    if (key === 'each') {
      var each = out[key];
      for (key in each) {
        var value = (this.copyOutput) ? util.deepCopy(each[key]) : each[key];
        model._setDiff(inputsSegments[key], value, eachDiffOptions);
      }
      continue;
    }
    var value = (this.copyOutput) ? util.deepCopy(out[key]) : out[key];
    model._setDiff(inputsSegments[key], value, diffOptions);
  }
};

Fn.prototype.onInput = function(pass) {
  var value = (this.copyOutput) ? util.deepCopy(this.get()) : this.get();
  this.model.pass(pass, true)._setDiff(this.fromSegments, value, diffOptions);
  return value;
};

Fn.prototype.onOutput = function(pass) {
  var value = this.model._get(this.fromSegments);
  return this.set(value, pass);
};

},{"../util":7,"./index":8,"./defaultFns":20}],21:[function(require,module,exports){
var util = require('../util');
var Model = require('./index');

Model.INITS.push(function(model) {
  model._filters = new Filters(model);
  model.on('all', filterListener);
  function filterListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    var map = model._filters.fromMap;
    for (var path in map) {
      var filter = map[path];
      if (pass.$filter === filter) continue;
      if (util.mayImpact(filter.inputSegments, segments)) {
        filter.update(pass);
      }
    }
  }
});

Model.prototype.filter = function(input, fn) {
  var inputPath = this.path(input);
  return this._filters.add(inputPath, fn);
};

Model.prototype.sort = function(input, fn) {
  var inputPath = this.path(input);
  return this._filters.add(inputPath, null, fn || 'asc');
};

Model.prototype.removeAllFilters = function(subpath) {
  var segments = this._splitPath(subpath);
  var filters = this._filters.fromMap;
  for (var from in filters) {
    if (util.contains(segments, filters[from].fromSegments)) {
      filters[from].destroy();
    }
  }
};

function FromMap() {}
function Filters(model) {
  this.model = model;
  this.fromMap = new FromMap;
}

Filters.prototype.add = function(inputPath, filterFn, sortFn) {
  return new Filter(this, inputPath, filterFn, sortFn);
};

Filters.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var filter = this.fromMap[from];
    // Don't try to bundle if functions were passed directly instead of by name
    if (!filter.bundle) continue;
    out.push([filter.inputPath, filter.filterName, filter.sortName, from]);
  }
  return out;
};

function Filter(filters, inputPath, filterFn, sortFn) {
  this.filters = filters;
  this.model = filters.model.pass({$filter: this});
  this.inputPath = inputPath;
  this.inputSegments = inputPath.split('.');
  this.filterName = null;
  this.sortName = null;
  this.bundle = true;
  this.filterFn = null;
  this.sortFn = null;
  if (filterFn) this.filter(filterFn);
  if (sortFn) this.sort(sortFn);
  this.idsSegments = null;
  this.from = null;
  this.fromSegments = null;
}

Filter.prototype.filter = function(fn) {
  if (typeof fn === 'function') {
    this.filterFn = fn;
    this.bundle = false;
    return this;
  }
  if (typeof fn === 'string') {
    this.filterName = fn;
    this.filterFn = this.model._namedFns[fn];
    if (!this.filterFn) {
      var err = new TypeError('Filter function not found: ' + fn);
      this.model.emit('error', err);
    }
  }
  return this;
};

Filter.prototype.sort = function(fn) {
  if (!fn) fn = 'asc';
  if (typeof fn === 'function') {
    this.sortFn = fn;
    this.bundle = false;
    return this;
  }
  if (typeof fn === 'string') {
    this.sortName = fn;
    this.sortFn = this.model._namedFns[fn];
    if (!this.sortFn) {
      var err = new TypeError('Sort function not found: ' + fn);
      this.model.emit('error', err);
    }
  }
  return this;
};

Filter.prototype.ids = function() {
  var items = this.model._get(this.inputSegments);
  var ids = [];
  if (!items) return ids;
  if (Array.isArray(items)) {
    if (this.filterFn) {
      for (var i = 0; i < items.length; i++) {
        if (this.filterFn.call(this.model, items[i], i, items)) {
          ids.push(i);
        }
      }
    } else {
      for (var i = 0; i < items.length; i++) ids.push(i);
    }
  } else {
    if (this.filterFn) {
      for (var key in items) {
        if (items.hasOwnProperty(key) &&
          this.filterFn.call(this.model, items[key], key, items)
        ) {
          ids.push(key);
        }
      }
    } else {
      ids = Object.keys(items);
    }
  }
  var sortFn = this.sortFn;
  if (sortFn) {
    ids.sort(function(a, b) {
      return sortFn(items[a], items[b]);
    });
  }
  return ids;
};

Filter.prototype.get = function() {
  var items = this.model._get(this.inputSegments);
  var results = [];
  if (Array.isArray(items)) {
    if (this.filterFn) {
      for (var i = 0; i < items.length; i++) {
        if (this.filterFn.call(this.model, items[i], i, items)) {
          results.push(items[i]);
        }
      }
    } else {
      results = items.slice();
    }
  } else {
    if (this.filterFn) {
      for (var key in items) {
        if (items.hasOwnProperty(key) &&
          this.filterFn.call(this.model, items[key], key, items)
        ) {
          results.push(items[key]);
        }
      }
    } else {
      for (var key in items) {
        if (items.hasOwnProperty(key)) {
          results.push(items[key]);
        }
      }
    }
  }
  if (this.sortFn) results.sort(this.sortFn);
  return results;
};

Filter.prototype.update = function(pass) {
  var ids = this.ids();
  this.model.pass(pass, true)._setDiff(this.idsSegments, ids);
};

Filter.prototype.ref = function(from) {
  from = this.model.path(from);
  this.from = from;
  this.fromSegments = from.split('.');
  this.filters.fromMap[from] = this;
  this.idsSegments = ['$filters', from.replace(/\./g, '|')];
  this.update();
  return this.model.refList(from, this.inputPath, this.idsSegments.join('.'));
};

Filter.prototype.destroy = function() {
  delete this.filters.fromMap[this.from];
  this.model.removeRefList(this.from);
  this.model._del(this.idsSegments);
};

},{"../util":7,"./index":8}],22:[function(require,module,exports){
var util = require('../util');
var Model = require('./index');

Model.INITS.push(function(model) {
  model._refLists = new RefLists(model);
  for (var type in Model.MUTATOR_EVENTS) {
    addListener(model, type);
  }
});

function addListener(model, type) {
  model.on(type, refListListener);
  function refListListener(segments, eventArgs) {
    var pass = eventArgs[eventArgs.length - 1];
    // Check for updates on or underneath paths
    var fromMap = model._refLists.fromMap;
    for (var from in fromMap) {
      var refList = fromMap[from];
      if (pass.$refList === refList) continue;
      refList.onMutation(type, segments, eventArgs);
    }
  }
}

/**
 * @param {String} type
 * @param {Array} segments
 * @param {Array} eventArgs
 * @param {RefList} refList
 */
function patchFromEvent(type, segments, eventArgs, refList) {
  var fromLength = refList.fromSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // Mutation on the `from` output itself
  if (segmentsLength === fromLength) {
    if (type === 'insert') {
      var index = eventArgs[0];
      var values = eventArgs[1];
      var ids = setNewToValues(model, refList, values);
      model._insert(refList.idsSegments, index, ids);
      return;
    }

    if (type === 'remove') {
      var index = eventArgs[0];
      var howMany = eventArgs[1].length;
      var ids = model._remove(refList.idsSegments, index, howMany);
      // Delete the appropriate items underneath `to` if the `deleteRemoved`
      // option was set true
      if (refList.deleteRemoved) {
        for (var i = 0; i < ids.length; i++) {
          var item = refList.itemById(ids[i]);
          model._del(refList.toSegmentsByItem(item));
        }
      }
      return;
    }

    if (type === 'move') {
      var from = eventArgs[0];
      var to = eventArgs[1];
      var howMany = eventArgs[2];
      model._move(refList.idsSegments, from, to, howMany);
      return;
    }

    // Change of the entire output
    var values = (type === 'change') ?
      eventArgs[0] : model._get(refList.fromSegments);
    // Set ids to empty list if output is set to null
    if (!values) {
      model._set(refList.idsSegments, []);
      return;
    }
    // If the entire output is set, create a list of ids based on the output,
    // and update the corresponding items
    var ids = setNewToValues(model, refList, values);
    model._set(refList.idsSegments, ids);
    return;
  }

  // If mutation is on a parent of `from`, we might need to re-create the
  // entire refList output
  if (segmentsLength < fromLength) {
    model._setDiff(refList.fromSegments, refList.get());
    return;
  }

  var index = segments[fromLength];
  var value = model._get(refList.fromSegments.concat(index));
  var toSegments = refList.toSegmentsByItem(value);

  // Mutation underneath a child of the `from` object.
  if (segmentsLength > fromLength + 1) {
    var message = 'Mutation on descendant of refList `from` should have been dereferenced: ' + segments.join('.');
    model.emit('error', new Error(message));
    return;
  }

  // Otherwise, mutation of a child of the `from` object

  // If changing the item itself, it will also have to be re-set on the
  // original object
  if (type === 'change') {
    model._set(toSegments, value);
    updateIdForValue(model, refList, index, value);
    return;
  }
  // The same goes for string mutations, since strings are immutable
  if (type === 'stringInsert') {
    var stringIndex = eventArgs[0];
    var stringValue = eventArgs[1];
    model._stringInsert(toSegments, stringIndex, stringValue);
    updateIdForValue(model, refList, index, value);
    return;
  }
  if (type === 'stringRemove') {
    var stringIndex = eventArgs[0];
    var howMany = eventArgs[1];
    model._stringRemove(toSegments, stringIndex, howMany);
    updateIdForValue(model, refList, index, value);
    return;
  }
  if (type === 'insert' || type === 'remove' || type === 'move') {
    var message = 'Array mutation on child of refList `from` should have been dereferenced: ' + segments.join('.');
    model.emit('error', new Error(message));
    return;
  }
}

/**
 * @private
 * @param {Model} model
 * @param {RefList} refList
 * @param {Array} values
 */
function setNewToValues(model, refList, values, fn) {
  var ids = [];
  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    var id = refList.idByItem(value);
    if (id === void 0 && typeof value === 'object') {
      id = value.id = model.id();
    }
    var toSegments = refList.toSegmentsByItem(value);
    if (id === void 0 || toSegments === void 0) {
      var message = 'Unable to add item to refList: ' + value;
      return model.emit('error', new Error(message));
    }
    model._setDiff(toSegments, value);
    ids.push(id);
  }
  return ids;
}
function updateIdForValue(model, refList, index, value) {
  var id = refList.idByItem(value);
  var outSegments = refList.idsSegments.concat(index);
  model._setDiff(outSegments, id);
}

function patchToEvent(type, segments, eventArgs, refList) {
  var toLength = refList.toSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // Mutation on the `to` object itself
  if (segmentsLength === toLength) {
    if (type === 'insert') {
      var insertIndex = eventArgs[0];
      var values = eventArgs[1];
      for (var i = 0; i < values.length; i++) {
        var value = values[i];
        var indices = refList.indicesByItem(value);
        if (!indices) continue;
        for (var j = 0; j < indices.length; j++) {
          var outSegments = refList.fromSegments.concat(indices[j]);
          model._setDiff(outSegments, value);
        }
      }
      return;
    }

    if (type === 'remove') {
      var removeIndex = eventArgs[0];
      var values = eventArgs[1];
      var howMany = values.length;
      for (var i = removeIndex, len = removeIndex + howMany; i < len; i++) {
        var indices = refList.indicesByItem(values[i]);
        if (!indices) continue;
        for (var j = 0, indicesLen = indices.length; j < indicesLen; j++) {
          var outSegments = refList.fromSegments.concat(indices[j]);
          model._set(outSegments, void 0);
        }
      }
      return;
    }

    if (type === 'move') {
      // Moving items in the `to` object should have no effect on the output
      return;
    }
  }

  // Mutation on or above the `to` object
  if (segmentsLength <= toLength) {
    // If the entire `to` object is updated, we need to re-create the
    // entire refList output and apply what is different. This will end up
    // doing an arrayDiff
    model._setDiff(refList.fromSegments, refList.get());
    return;
  }

  // Mutation underneath a child of the `to` object. The item will already
  // be up to date, since it is under an object reference. Just re-emit
  if (segmentsLength > toLength + 1) {
    var value = model._get(segments.slice(0, toLength + 1));
    var indices = refList.indicesByItem(value);
    if (!indices) return;
    var remaining = segments.slice(toLength + 1);
    for (var i = 0; i < indices.length; i++) {
      var index = indices[i];
      var dereferenced = refList.fromSegments.concat(index, remaining);
      dereferenced = model._dereference(dereferenced, null, refList);
      eventArgs = eventArgs.slice();
      eventArgs[eventArgs.length - 1] = model._pass;
      model.emit(type, dereferenced, eventArgs);
    }
    return;
  }

  // Otherwise, mutation of a child of the `to` object

  // If changing the item itself, it will also have to be re-set on the
  // array created by the refList
  if (type === 'change' || type === 'load' || type === 'unload') {
    var value, previous;
    if (type === 'change') {
      value = eventArgs[0];
      previous = eventArgs[1];
    } else if (type === 'load') {
      value = eventArgs[0];
      previous = void 0;
    } else if (type === 'unload') {
      value = void 0;
      previous = eventArgs[0];
    }
    var newIndices = refList.indicesByItem(value);
    var oldIndices = refList.indicesByItem(previous);
    if (!newIndices && !oldIndices) return;
    if (oldIndices && !equivalentArrays(oldIndices, newIndices)) {
      // The changed item used to refer to some indices, but no longer does
      for (var i = 0; i < oldIndices.length; i++) {
        var outSegments = refList.fromSegments.concat(oldIndices[i]);
        model._set(outSegments, void 0);
      }
    }
    if (newIndices) {
      for (var i = 0; i < newIndices.length; i++) {
        var outSegments = refList.fromSegments.concat(newIndices[i]);
        model._set(outSegments, value);
      }
    }
    return;
  }

  var value = model._get(segments.slice(0, toLength + 1));
  var indices = refList.indicesByItem(value);
  if (!indices) return;

  // The same goes for string mutations, since strings are immutable
  if (type === 'stringInsert') {
    var stringIndex = eventArgs[0];
    var value = eventArgs[1];
    for (var i = 0; i < indices.length; i++) {
      var outSegments = refList.fromSegments(indices[i]);
      model._stringInsert(outSegments, stringIndex, value);
    }
    return;
  }
  if (type === 'stringRemove') {
    var stringIndex = eventArgs[0];
    var howMany = eventArgs[1];
    for (var i = 0; i < indices.length; i++) {
      var outSegments = refList.fromSegments(indices[i]);
      model._stringRemove(outSegments, stringIndex, howMany);
    }
    return;
  }
  if (type === 'insert' || type === 'remove' || type === 'move') {
    // Array mutations will have already been updated via an object
    // reference, so only re-emit
    for (var i = 0; i < indices.length; i++) {
      var dereferenced = refList.fromSegments.concat(indices[i]);
      dereferenced = model._dereference(dereferenced, null, refList);
      eventArgs = eventArgs.slice();
      eventArgs[eventArgs.length - 1] = model._pass;
      model.emit(type, dereferenced, eventArgs);
    }
  }
}
function equivalentArrays(a, b) {
  if (!a || !b) return false;
  if (a.length !== b.length) return false;
  for (var i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) return false;
  }
  return true;
}

function patchIdsEvent(type, segments, eventArgs, refList) {
  var idsLength = refList.idsSegments.length;
  var segmentsLength = segments.length;
  var pass = eventArgs[eventArgs.length - 1];
  var model = refList.model.pass(pass, true);

  // An array mutation of the ids should be mirrored with a like change in
  // the output array
  if (segmentsLength === idsLength) {
    if (type === 'insert') {
      var index = eventArgs[0];
      var inserted = eventArgs[1];
      var values = [];
      for (var i = 0; i < inserted.length; i++) {
        var value = refList.itemById(inserted[i]);
        values.push(value);
      }
      model._insert(refList.fromSegments, index, values);
      return;
    }

    if (type === 'remove') {
      var index = eventArgs[0];
      var howMany = eventArgs[1].length;
      model._remove(refList.fromSegments, index, howMany);
      return;
    }

    if (type === 'move') {
      var from = eventArgs[0];
      var to = eventArgs[1];
      var howMany = eventArgs[2];
      model._move(refList.fromSegments, from, to, howMany);
      return;
    }
  }

  // Mutation on the `ids` list itself
  if (segmentsLength <= idsLength) {
    // If the entire `ids` array is updated, we need to re-create the
    // entire refList output and apply what is different. This will end up
    // doing an arrayDiff
    model._setDiff(refList.fromSegments, refList.get());
    return;
  }

  // Otherwise, direct mutation of a child in the `ids` object or mutation
  // underneath an item in the `ids` list. Update the item for the appropriate
  // id if it has changed
  var index = segments[idsLength];
  var id = refList.idByIndex(index);
  var item = refList.itemById(id);
  var itemSegments = refList.fromSegments.concat(index);
  if (model._get(itemSegments) !== item) {
    model._set(itemSegments, item);
  }
}

Model.prototype.refList = function() {
  var from, to, ids, options;
  if (arguments.length === 2) {
    to = arguments[0];
    ids = arguments[1];
  } else if (arguments.length === 3) {
    if (this.isPath(arguments[2])) {
      from = arguments[0];
      to = arguments[1];
      ids = arguments[2];
    } else {
      to = arguments[0];
      ids = arguments[1];
      options = arguments[2];
    }
  } else {
    from = arguments[0];
    to = arguments[1];
    ids = arguments[2];
    options = arguments[3];
  }
  var fromPath = this.path(from);
  if (Array.isArray(to)) {
    var toPath = [];
    for (var i = 0; i < to.length; i++) {
      toPath.push(this.path(to[i]));
    }
  } else {
    var toPath = this.path(to);
  }
  var idsPath = this.path(ids);
  var refList = this._refLists.add(fromPath, toPath, idsPath, options);
  this.pass({$refList: refList})._setDiff(refList.fromSegments, refList.get());
  return this.scope(fromPath);
};

Model.prototype.removeRefList = function(from) {
  var fromPath = this.path(from);
  var refList = this._refLists.remove(fromPath);
  if (refList) this._del(refList.fromSegments);
};

function RefList(model, from, to, ids, options) {
  this.model = model && model.pass({$refList: this});
  this.from = from;
  this.to = to;
  this.ids = ids;
  this.fromSegments = from && from.split('.');
  this.toSegments = to && to.split('.');
  this.idsSegments = ids && ids.split('.');
  this.options = options;
  this.deleteRemoved = options && options.deleteRemoved;
}

// The default implementation assumes that the ids array is a flat list of
// keys on the to object. Ideally, this mapping could be customized via
// inheriting from RefList and overriding these methods without having to
// modify the above event handling code.
// 
// In the default refList implementation, `key` and `id` are equal.
// 
// Terms in the below methods:
//   `item`  - Object on the `to` path, which gets mirrored on the `from` path
//   `key`   - The property under `to` at which an item is located
//   `id`    - String or object in the array at the `ids` path
//   `index` - The index of an id, which corresponds to an index on `from`
RefList.prototype.get = function() {
  var ids = this.model._get(this.idsSegments);
  if (!ids) return [];
  var items = this.model._get(this.toSegments);
  var out = [];
  for (var i = 0; i < ids.length; i++) {
    var key = ids[i];
    out.push(items && items[key]);
  }
  return out;
};
RefList.prototype.dereference = function(segments, i) {
  var remaining = segments.slice(i + 1);
  var key = this.idByIndex(remaining[0]);
  if (key == null) return [];
  remaining[0] = key;
  return this.toSegments.concat(remaining);
};
RefList.prototype.toSegmentsByItem = function(item) {
  var key = this.idByItem(item);
  if (key === void 0) return;
  return this.toSegments.concat(key);
};
RefList.prototype.idByItem = function(item) {
  if (item && item.id) return item.id;
  var items = this.model._get(this.toSegments);
  for (var key in items) {
    if (item === items[key]) return key;
  }
};
RefList.prototype.indicesByItem = function(item) {
  var id = this.idByItem(item);
  var ids = this.model._get(this.idsSegments);
  if (!ids) return;
  var indices;
  var index = -1;
  while (true) {
    index = ids.indexOf(id, index + 1);
    if (index === -1) break;
    if (indices) {
      indices.push(index);
    } else {
      indices = [index];
    }
  }
  return indices;
};
RefList.prototype.itemById = function(id) {
  return this.model._get(this.toSegments.concat(id));
};
RefList.prototype.idByIndex = function(index) {
  return this.model._get(this.idsSegments.concat(index));
};
RefList.prototype.onMutation = function(type, segments, eventArgs) {
  if (util.mayImpact(this.toSegments, segments)) {
    patchToEvent(type, segments, eventArgs, this);
  } else if (util.mayImpact(this.idsSegments, segments)) {
    patchIdsEvent(type, segments, eventArgs, this);
  } else if (util.mayImpact(this.fromSegments, segments)) {
    patchFromEvent(type, segments, eventArgs, this);
  }
};

function FromMap() {}

function RefLists(model) {
  this.model = model;
  this.fromMap = new FromMap;
}

RefLists.prototype.add = function(from, to, ids, options) {
  var refList = new RefList(this.model, from, to, ids, options);
  this.fromMap[from] = refList;
  return refList;
};

RefLists.prototype.remove = function(from) {
  var refList = this.fromMap[from];
  delete this.fromMap[from];
  return refList;
};

RefLists.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var refList = this.fromMap[from];
    out.push([refList.from, refList.to, refList.ids, refList.options]);
  }
  return out;
};

},{"../util":7,"./index":8}],23:[function(require,module,exports){
var util = require('../util');
var Model = require('./index');

Model.INITS.push(function(model) {
  model._refs = new Refs;
  addArrayListeners(model);
  for (var type in Model.MUTATOR_EVENTS) {
    addListener(model, type);
  }
});

function addArrayListeners(model) {
  model.on('insert', function refInsertListener(segments, eventArgs) {
    var index = eventArgs[0];
    var howMany = eventArgs[1].length;
    function patchInsert(refIndex) {
      return (index <= refIndex) ? refIndex + howMany : refIndex;
    }
    onIndexChange(segments, patchInsert);
  });
  model.on('remove', function refRemoveListener(segments, eventArgs) {
    var index = eventArgs[0];
    var howMany = eventArgs[1].length;
    function patchRemove(refIndex) {
      return (index <= refIndex) ? refIndex - howMany : refIndex;
    }
    onIndexChange(segments, patchRemove);
  });
  model.on('move', function refMoveListener(segments, eventArgs) {
    var from = eventArgs[0];
    var to = eventArgs[1];
    var howMany = eventArgs[2];
    function patchMove(refIndex) {
      // If the index was moved itself
      if (from <= refIndex && refIndex < from + howMany) {
        return refIndex + to - from;
      }
      // Remove part of a move
      if (from <= refIndex) refIndex -= howMany;
      // Insert part of a move
      if (to <= refIndex) refIndex += howMany;
      return refIndex;
    }
    onIndexChange(segments, patchMove);
  });
  function onIndexChange(segments, patch) {
    var fromMap = model._refs.fromMap;
    for (var from in fromMap) {
      var ref = fromMap[from];
      if (!(ref.updateIndices &&
        util.contains(segments, ref.toSegments) &&
        ref.toSegments.length > segments.length)) continue;
      var index = +ref.toSegments[segments.length];
      var patched = patch(index);
      if (index === patched) continue;
      model._refs.remove(from);
      ref.toSegments[segments.length] = '' + patched;
      ref.to = ref.toSegments.join('.');
      model._refs._add(ref);
    }
  }
}

function addListener(model, type) {
  model.on(type, refListener);
  function refListener(segments, eventArgs) {
    // Find cases where an event is emitted on a path where a reference
    // is pointing. All original mutations happen on the fully dereferenced
    // location, so this detection only needs to happen in one direction
    var toMap = model._refs.toMap;
    for (var i = 0, len = segments.length; i < len; i++) {
      var subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];
      // If a ref is found pointing to a matching subpath, re-emit on the
      // place where the reference is coming from as if the mutation also
      // occured at that path
      var refs = toMap[subpath];
      if (!refs) continue;
      var remaining = segments.slice(i + 1);
      for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {
        var ref = refs[refIndex];
        var dereferenced = ref.fromSegments.concat(remaining);
        model.emit(type, dereferenced, eventArgs);
      }
    }
    // If a ref points to a child of a matching subpath, get the value in
    // case it has changed and re-emit on the place where the reference
    // is coming from
    var parentToMap = model._refs.parentToMap;
    var refs = parentToMap[subpath];
    if (!refs) return;
    var pass = eventArgs[eventArgs.length - 1];
    for (var refIndex = 0, numRefs = refs.length; refIndex < numRefs; refIndex++) {
      var ref = refs[refIndex];
      var value = model._get(ref.fromSegments);
      // TODO: Not sure how to get the previous value here. Just passing
      // undefined for now
      var previous = void 0;
      model.emit('change', ref.fromSegments, [value, previous, pass]);
    }
  }
}

Model.prototype.ref = function() {
  var from, to, options;
  if (arguments.length === 1) {
    to = arguments[0];
  } else if (arguments.length === 2) {
    if (this.isPath(arguments[1])) {
      from = arguments[0];
      to = arguments[1];
    } else {
      to = arguments[0];
      options = arguments[1];
    }
  } else {
    from = arguments[0];
    to = arguments[1];
    options = arguments[2];
  }
  var fromPath = this.path(from);
  var toPath = this.path(to);
  var fromSegments = fromPath.split('.');
  if (fromSegments.length < 2) {
    var message = 'ref must be performed under a collection ' +
      'and document id. Invalid path: ' + fromPath;
    this.emit('error', new Error(message));
  }
  var previous = this._get(fromSegments);
  this._refs.add(fromPath, toPath, options);
  var value = this._get(fromSegments);
  this.emit('change', fromSegments, [value, previous, this._pass]);
  return this.scope(fromPath);
};

Model.prototype.removeRef = function(from) {
  var fromPath = this.path(from);
  var fromSegments = fromPath.split('.');
  var previous = this._get(fromSegments);
  this._refs.remove(fromPath);
  var value = this._get(fromSegments);
  this.emit('change', fromSegments, [value, previous, this._pass]);
};

Model.prototype.removeAllRefs = function(subpath) {
  var segments = this._splitPath(subpath);
  var refs = this._refs.fromMap;
  var refLists = this._refLists.fromMap;
  for (var from in refs) {
    if (util.contains(segments, refs[from].fromSegments)) {
      this.removeRef(from);
    }
  }
  for (var from in refLists) {
    if (util.contains(segments, refLists[from].fromSegments)) {
      this.removeRefList(from);
    }
  }
};

Model.prototype.dereference = function(subpath) {
  var segments = this._splitPath(subpath);
  return this._dereference(segments).join('.');
};

Model.prototype._dereference = function(segments, forArrayMutator, ignore) {
  if (segments.length === 0) return segments;
  var refs = this._refs.fromMap;
  var refLists = this._refLists.fromMap;
  do {
    var subpath = '';
    var doAgain = false;
    for (var i = 0, len = segments.length; i < len; i++) {
      subpath = (subpath) ? subpath + '.' + segments[i] : segments[i];

      var ref = refs[subpath];
      if (ref) {
        var remaining = segments.slice(i + 1);
        segments = ref.toSegments.concat(remaining);
        doAgain = true;
        break;
      }

      var refList = refLists[subpath];
      if (refList && refList !== ignore) {
        var belowDescendant = i + 2 < len;
        var belowChild = i + 1 < len;
        if (!(belowDescendant || forArrayMutator && belowChild)) continue;
        segments = refList.dereference(segments, i);
        doAgain = true;
        break;
      }
    }
  } while (doAgain);
  // If a dereference fails, return a path that will result in a null value
  // instead of a path to everything in the model
  if (segments.length === 0) return ['$null'];
  return segments;
};

function Ref(from, to, options) {
  this.from = from;
  this.to = to;
  this.fromSegments = from.split('.');
  this.toSegments = to.split('.');
  this.parentTos = [];
  for (var i = 1, len = this.toSegments.length; i < len; i++) {
    var parentTo = this.toSegments.slice(0, i).join('.');
    this.parentTos.push(parentTo);
  }
  this.updateIndices = options && options.updateIndices;
}
function FromMap() {}
function ToMap() {}

function Refs() {
  this.fromMap = new FromMap;
  this.toMap = new ToMap;
  this.parentToMap = new ToMap;
}

Refs.prototype.add = function(from, to, options) {
  this.remove(from);
  var ref = new Ref(from, to, options);
  return this._add(ref);
};

Refs.prototype._add = function(ref) {
  this.fromMap[ref.from] = ref;
  listMapAdd(this.toMap, ref.to, ref);
  for (var i = 0, len = ref.parentTos.length; i < len; i++) {
    listMapAdd(this.parentToMap, ref.parentTos[i], ref);
  }
  return ref;
};

Refs.prototype.remove = function(from) {
  var ref = this.fromMap[from];
  if (!ref) return;
  delete this.fromMap[from];
  listMapRemove(this.toMap, ref.to, ref);
  for (var i = 0, len = ref.parentTos.length; i < len; i++) {
    listMapRemove(this.parentToMap, ref.parentTos[i], ref);
  }
  return ref;
};

Refs.prototype.toJSON = function() {
  var out = [];
  for (var from in this.fromMap) {
    var ref = this.fromMap[from];
    out.push([ref.from, ref.to]);
  }
  return out;
};

function listMapAdd(map, name, item) {
  map[name] || (map[name] = []);
  map[name].push(item);
}

function listMapRemove(map, name, item) {
  var items = map[name];
  if (!items) return;
  var index = items.indexOf(item);
  if (index === -1) return;
  items.splice(index, 1);
  if (!items.length) delete map[name];
}

},{"../util":7,"./index":8}],9:[function(require,module,exports){
var pSlice = Array.prototype.slice;
var Object_keys = typeof Object.keys === 'function'
    ? Object.keys
    : function (obj) {
        var keys = [];
        for (var key in obj) keys.push(key);
        return keys;
    }
;

var deepEqual = module.exports = function (actual, expected) {
  // enforce Object.is +0 !== -0
  if (actual === 0 && expected === 0) {
    return areZerosEqual(actual, expected);

  // 7.1. All identical values are equivalent, as determined by ===.
  } else if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  } else if (isNumberNaN(actual)) {
    return isNumberNaN(expected);

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
};

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function isNumberNaN(value) {
  // NaN === NaN -> false
  return typeof value == 'number' && value !== value;
}

function areZerosEqual(zeroA, zeroB) {
  // (1 / +0|0) -> Infinity, but (1 / -0) -> -Infinity and (Infinity !== -Infinity)
  return (1 / zeroA) === (1 / zeroB);
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;

  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b);
  }
  try {
    var ka = Object_keys(a),
        kb = Object_keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key])) return false;
  }
  return true;
}

},{}],8:[function(require,module,exports){
(function(__dirname){var uuid = require('node-uuid');
var util = require('../util');

Model.INITS = [];

module.exports = Model;

function Model(store, options) {
  this.store = store;
  var inits = Model.INITS;
  options || (options = {});
  for (var i = 0; i < inits.length; i++) {
    inits[i](this, options);
  }
}

Model.prototype.id = function() {
  return uuid.v4();
};

// Extend model on both server and client
require('./events');
require('./paths');
require('./connection');
require('./collections');
require('./mutators');
require('./setDiff');
require('./subscriptions');
require('./Query');
require('./contexts');
require('./fn');
require('./filter');
require('./refList');
// ref is at the *very* end because ref changes the effective order of events
// that event listeners see that are added after ref. So this makes it safer.
require('./ref');

// Extend model for server
util.serverRequire(__dirname + '/bundle');
util.serverRequire(__dirname + '/connection.server');

})("/node_modules/racer/lib/Model")
},{"../util":7,"./events":11,"./paths":10,"./connection":24,"./collections":12,"./mutators":15,"./setDiff":25,"./subscriptions":16,"./Query":17,"./contexts":18,"./fn":19,"./filter":21,"./refList":22,"./ref":23,"node-uuid":26}],20:[function(require,module,exports){
var defaultFns = module.exports = new DefaultFns;

defaultFns.reverse = new FnPair(getReverse, setReverse);
defaultFns.asc = asc;
defaultFns.desc = desc;

function DefaultFns() {}
function FnPair(get, set) {
  this.get = get;
  this.set = set;
}

function getReverse(array) {
  return array && array.slice().reverse();
}
function setReverse(values) {
  return {0: getReverse(values)};
}

function asc(a, b) {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}
function desc(a, b) {
  if (a > b) return -1;
  if (a < b) return 1;
  return 0;
}

},{}],27:[function(require,module,exports){
require=(function(e,t,n,r){function i(r){if(!n[r]){if(!t[r]){if(e)return e(r);throw new Error("Cannot find module '"+r+"'")}var s=n[r]={exports:{}};t[r][0](function(e){var n=t[r][1][e];return i(n?n:e)},s,s.exports)}return n[r].exports}for(var s=0;s<r.length;s++)i(r[s]);return i})(typeof require!=="undefined"&&require,{1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],2:[function(require,module,exports){
(function(){// UTILITY
var util = require('util');
var Buffer = require("buffer").Buffer;
var pSlice = Array.prototype.slice;

function objectKeys(object) {
  if (Object.keys) return Object.keys(object);
  var result = [];
  for (var name in object) {
    if (Object.prototype.hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.message = options.message;
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
};
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (value === undefined) {
    return '' + value;
  }
  if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (typeof value === 'function' || value instanceof RegExp) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (typeof s == 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

assert.AssertionError.prototype.toString = function() {
  if (this.message) {
    return [this.name + ':', this.message].join(' ');
  } else {
    return [
      this.name + ':',
      truncate(JSON.stringify(this.actual, replacer), 128),
      this.operator,
      truncate(JSON.stringify(this.expected, replacer), 128)
    ].join(' ');
  }
};

// assert.AssertionError instanceof Error

assert.AssertionError.__proto__ = Error.prototype;

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!!!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (Buffer.isBuffer(actual) && Buffer.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (typeof actual != 'object' && typeof expected != 'object') {
    return actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (expected instanceof RegExp) {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail('Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail('Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

})()
},{"util":3,"buffer":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],"q9TxCC":[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.binaryWrite = SlowBuffer.prototype.asciiWrite;

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.binarySlice = SlowBuffer.prototype.asciiSlice;

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

SlowBuffer.prototype.fill = function(value, start, end) {
  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this.parent[i + this.offset] = subject.readUInt8(i);
        }
        else {
          this.parent[i + this.offset] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1];
    }
  } else {
    val = buffer.parent[buffer.offset + offset];
    if (offset + 1 < buffer.length) {
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer.parent[buffer.offset + offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer.parent[buffer.offset + offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer.parent[buffer.offset + offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":1,"base64-js":5}],3:[function(require,module,exports){
var events = require('events');

exports.isArray = isArray;
exports.isDate = function(obj){return Object.prototype.toString.call(obj) === '[object Date]'};
exports.isRegExp = function(obj){return Object.prototype.toString.call(obj) === '[object RegExp]'};


exports.print = function () {};
exports.puts = function () {};
exports.debug = function() {};

exports.inspect = function(obj, showHidden, depth, colors) {
  var seen = [];

  var stylize = function(str, styleType) {
    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    var styles =
        { 'bold' : [1, 22],
          'italic' : [3, 23],
          'underline' : [4, 24],
          'inverse' : [7, 27],
          'white' : [37, 39],
          'grey' : [90, 39],
          'black' : [30, 39],
          'blue' : [34, 39],
          'cyan' : [36, 39],
          'green' : [32, 39],
          'magenta' : [35, 39],
          'red' : [31, 39],
          'yellow' : [33, 39] };

    var style =
        { 'special': 'cyan',
          'number': 'blue',
          'boolean': 'yellow',
          'undefined': 'grey',
          'null': 'bold',
          'string': 'green',
          'date': 'magenta',
          // "name": intentionally not styling
          'regexp': 'red' }[styleType];

    if (style) {
      return '\033[' + styles[style][0] + 'm' + str +
             '\033[' + styles[style][1] + 'm';
    } else {
      return str;
    }
  };
  if (! colors) {
    stylize = function(str, styleType) { return str; };
  }

  function format(value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (value && typeof value.inspect === 'function' &&
        // Filter out the util module, it's inspect function is special
        value !== exports &&
        // Also filter out any prototype objects using the circular check.
        !(value.constructor && value.constructor.prototype === value)) {
      return value.inspect(recurseTimes);
    }

    // Primitive types cannot have properties
    switch (typeof value) {
      case 'undefined':
        return stylize('undefined', 'undefined');

      case 'string':
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return stylize(simple, 'string');

      case 'number':
        return stylize('' + value, 'number');

      case 'boolean':
        return stylize('' + value, 'boolean');
    }
    // For some reason typeof null is "object", so special case here.
    if (value === null) {
      return stylize('null', 'null');
    }

    // Look up the keys of the object.
    var visible_keys = Object_keys(value);
    var keys = showHidden ? Object_getOwnPropertyNames(value) : visible_keys;

    // Functions without properties can be shortcutted.
    if (typeof value === 'function' && keys.length === 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        var name = value.name ? ': ' + value.name : '';
        return stylize('[Function' + name + ']', 'special');
      }
    }

    // Dates without properties can be shortcutted
    if (isDate(value) && keys.length === 0) {
      return stylize(value.toUTCString(), 'date');
    }

    var base, type, braces;
    // Determine the object type
    if (isArray(value)) {
      type = 'Array';
      braces = ['[', ']'];
    } else {
      type = 'Object';
      braces = ['{', '}'];
    }

    // Make functions say that they are functions
    if (typeof value === 'function') {
      var n = value.name ? ': ' + value.name : '';
      base = (isRegExp(value)) ? ' ' + value : ' [Function' + n + ']';
    } else {
      base = '';
    }

    // Make dates with properties first say the date
    if (isDate(value)) {
      base = ' ' + value.toUTCString();
    }

    if (keys.length === 0) {
      return braces[0] + base + braces[1];
    }

    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return stylize('' + value, 'regexp');
      } else {
        return stylize('[Object]', 'special');
      }
    }

    seen.push(value);

    var output = keys.map(function(key) {
      var name, str;
      if (value.__lookupGetter__) {
        if (value.__lookupGetter__(key)) {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Getter/Setter]', 'special');
          } else {
            str = stylize('[Getter]', 'special');
          }
        } else {
          if (value.__lookupSetter__(key)) {
            str = stylize('[Setter]', 'special');
          }
        }
      }
      if (visible_keys.indexOf(key) < 0) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (seen.indexOf(value[key]) < 0) {
          if (recurseTimes === null) {
            str = format(value[key]);
          } else {
            str = format(value[key], recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (isArray(value)) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = stylize('[Circular]', 'special');
        }
      }
      if (typeof name === 'undefined') {
        if (type === 'Array' && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    });

    seen.pop();

    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf('\n') >= 0) numLinesEst++;
      return prev + cur.length + 1;
    }, 0);

    if (length > 50) {
      output = braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];

    } else {
      output = braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    return output;
  }
  return format(obj, (typeof depth === 'undefined' ? 2 : depth));
};


function isArray(ar) {
  return ar instanceof Array ||
         Array.isArray(ar) ||
         (ar && ar !== Object.prototype && isArray(ar.__proto__));
}


function isRegExp(re) {
  return re instanceof RegExp ||
    (typeof re === 'object' && Object.prototype.toString.call(re) === '[object RegExp]');
}


function isDate(d) {
  if (d instanceof Date) return true;
  if (typeof d !== 'object') return false;
  var properties = Date.prototype && Object_getOwnPropertyNames(Date.prototype);
  var proto = d.__proto__ && Object_getOwnPropertyNames(d.__proto__);
  return JSON.stringify(proto) === JSON.stringify(properties);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

exports.log = function (msg) {};

exports.pump = null;

var Object_keys = Object.keys || function (obj) {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
};

var Object_getOwnPropertyNames = Object.getOwnPropertyNames || function (obj) {
    var res = [];
    for (var key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) res.push(key);
    }
    return res;
};

var Object_create = Object.create || function (prototype, properties) {
    // from es5-shim
    var object;
    if (prototype === null) {
        object = { '__proto__' : null };
    }
    else {
        if (typeof prototype !== 'object') {
            throw new TypeError(
                'typeof prototype[' + (typeof prototype) + '] != \'object\''
            );
        }
        var Type = function () {};
        Type.prototype = prototype;
        object = new Type();
        object.__proto__ = prototype;
    }
    if (typeof properties !== 'undefined' && Object.defineProperties) {
        Object.defineProperties(object, properties);
    }
    return object;
};

exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object_create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (typeof f !== 'string') {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(exports.inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j': return JSON.stringify(args[i++]);
      default:
        return x;
    }
  });
  for(var x = args[i]; i < len; x = args[++i]){
    if (x === null || typeof x !== 'object') {
      str += ' ' + x;
    } else {
      str += ' ' + exports.inspect(x);
    }
  }
  return str;
};

},{"events":6}],5:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],7:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],8:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            if (ev.source === window && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
(function(process){if (!process.EventEmitter) process.EventEmitter = function () {};

var EventEmitter = exports.EventEmitter = process.EventEmitter;
var isArray = typeof Array.isArray === 'function'
    ? Array.isArray
    : function (xs) {
        return Object.prototype.toString.call(xs) === '[object Array]'
    }
;
function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (x === xs[i]) return i;
    }
    return -1;
}

// By default EventEmitters will print a warning if more than
// 10 listeners are added to it. This is a useful default which
// helps finding memory leaks.
//
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
var defaultMaxListeners = 10;
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!this._events) this._events = {};
  this._events.maxListeners = n;
};


EventEmitter.prototype.emit = function(type) {
  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events || !this._events.error ||
        (isArray(this._events.error) && !this._events.error.length))
    {
      if (arguments[1] instanceof Error) {
        throw arguments[1]; // Unhandled 'error' event
      } else {
        throw new Error("Uncaught, unspecified 'error' event.");
      }
      return false;
    }
  }

  if (!this._events) return false;
  var handler = this._events[type];
  if (!handler) return false;

  if (typeof handler == 'function') {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        var args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
    return true;

  } else if (isArray(handler)) {
    var args = Array.prototype.slice.call(arguments, 1);

    var listeners = handler.slice();
    for (var i = 0, l = listeners.length; i < l; i++) {
      listeners[i].apply(this, args);
    }
    return true;

  } else {
    return false;
  }
};

// EventEmitter is defined in src/node_events.cc
// EventEmitter.prototype.emit() is also defined there.
EventEmitter.prototype.addListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('addListener only takes instances of Function');
  }

  if (!this._events) this._events = {};

  // To avoid recursion in the case that type == "newListeners"! Before
  // adding it to the listeners, first emit "newListeners".
  this.emit('newListener', type, listener);

  if (!this._events[type]) {
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  } else if (isArray(this._events[type])) {

    // Check for listener leak
    if (!this._events[type].warned) {
      var m;
      if (this._events.maxListeners !== undefined) {
        m = this._events.maxListeners;
      } else {
        m = defaultMaxListeners;
      }

      if (m && m > 0 && this._events[type].length > m) {
        this._events[type].warned = true;
        console.error('(node) warning: possible EventEmitter memory ' +
                      'leak detected. %d listeners added. ' +
                      'Use emitter.setMaxListeners() to increase limit.',
                      this._events[type].length);
        console.trace();
      }
    }

    // If we've already got an array, just append.
    this._events[type].push(listener);
  } else {
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  var self = this;
  self.on(type, function g() {
    self.removeListener(type, g);
    listener.apply(this, arguments);
  });

  return this;
};

EventEmitter.prototype.removeListener = function(type, listener) {
  if ('function' !== typeof listener) {
    throw new Error('removeListener only takes instances of Function');
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (!this._events || !this._events[type]) return this;

  var list = this._events[type];

  if (isArray(list)) {
    var i = indexOf(list, listener);
    if (i < 0) return this;
    list.splice(i, 1);
    if (list.length == 0)
      delete this._events[type];
  } else if (this._events[type] === listener) {
    delete this._events[type];
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  if (arguments.length === 0) {
    this._events = {};
    return this;
  }

  // does not use listeners(), so no side effect of creating _events[type]
  if (type && this._events && this._events[type]) this._events[type] = null;
  return this;
};

EventEmitter.prototype.listeners = function(type) {
  if (!this._events) this._events = {};
  if (!this._events[type]) this._events[type] = [];
  if (!isArray(this._events[type])) {
    this._events[type] = [this._events[type]];
  }
  return this._events[type];
};

})(require("__browserify_process"))
},{"__browserify_process":8}],4:[function(require,module,exports){
(function(){function SlowBuffer (size) {
    this.length = size;
};

var assert = require('assert');

exports.INSPECT_MAX_BYTES = 50;


function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

SlowBuffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

SlowBuffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return SlowBuffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

SlowBuffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

SlowBuffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

SlowBuffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

SlowBuffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<SlowBuffer ' + out.join(' ') + '>';
};


SlowBuffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


SlowBuffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


SlowBuffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  SlowBuffer._charsWritten = i * 2;
  return i;
};


SlowBuffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};


// slice(start, end)
SlowBuffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;

  if (end > this.length) {
    throw new Error('oob');
  }
  if (start > end) {
    throw new Error('oob');
  }

  return new Buffer(this, end - start, +start);
};

SlowBuffer.prototype.copy = function(target, targetstart, sourcestart, sourceend) {
  var temp = [];
  for (var i=sourcestart; i<sourceend; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=targetstart; i<targetstart+temp.length; i++) {
    target[i] = temp[i-targetstart];
  }
};

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}


// Buffer

function Buffer(subject, encoding, offset) {
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    this.parent = subject;
    this.offset = offset;
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    if (this.length > Buffer.poolSize) {
      // Big buffer, just alloc one.
      this.parent = new SlowBuffer(this.length);
      this.offset = 0;

    } else {
      // Small buffer.
      if (!pool || pool.length - pool.used < this.length) allocPool();
      this.parent = pool;
      this.offset = pool.used;
      pool.used += this.length;
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        this.parent[i + this.offset] = subject[i];
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    }
  }

}

function isArrayIsh(subject) {
  return Array.isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

exports.SlowBuffer = SlowBuffer;
exports.Buffer = Buffer;

Buffer.poolSize = 8 * 1024;
var pool;

function allocPool() {
  pool = new SlowBuffer(Buffer.poolSize);
  pool.used = 0;
}


// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof SlowBuffer;
};

Buffer.concat = function (list, totalLength) {
  if (!Array.isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

// Inspect
Buffer.prototype.inspect = function inspect() {
  var out = [],
      len = this.length;

  for (var i = 0; i < len; i++) {
    out[i] = toHex(this.parent[i + this.offset]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }

  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i];
};


Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this.parent[this.offset + i] = v;
};


// write(string, offset = 0, length = buffer.length-offset, encoding = 'utf8')
Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  var ret;
  switch (encoding) {
    case 'hex':
      ret = this.parent.hexWrite(string, this.offset + offset, length);
      break;

    case 'utf8':
    case 'utf-8':
      ret = this.parent.utf8Write(string, this.offset + offset, length);
      break;

    case 'ascii':
      ret = this.parent.asciiWrite(string, this.offset + offset, length);
      break;

    case 'binary':
      ret = this.parent.binaryWrite(string, this.offset + offset, length);
      break;

    case 'base64':
      // Warning: maxLength not taken into account in base64Write
      ret = this.parent.base64Write(string, this.offset + offset, length);
      break;

    case 'ucs2':
    case 'ucs-2':
      ret = this.parent.ucs2Write(string, this.offset + offset, length);
      break;

    default:
      throw new Error('Unknown encoding');
  }

  Buffer._charsWritten = SlowBuffer._charsWritten;

  return ret;
};


// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();

  if (typeof start == 'undefined' || start < 0) {
    start = 0;
  } else if (start > this.length) {
    start = this.length;
  }

  if (typeof end == 'undefined' || end > this.length) {
    end = this.length;
  } else if (end < 0) {
    end = 0;
  }

  start = start + this.offset;
  end = end + this.offset;

  switch (encoding) {
    case 'hex':
      return this.parent.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.parent.utf8Slice(start, end);

    case 'ascii':
      return this.parent.asciiSlice(start, end);

    case 'binary':
      return this.parent.binarySlice(start, end);

    case 'base64':
      return this.parent.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.parent.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


// byteLength
Buffer.byteLength = SlowBuffer.byteLength;


// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  return this.parent.fill(value,
                          start + this.offset,
                          end + this.offset);
};


// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  end || (end = this.length);
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  return this.parent.copy(target.parent,
                          target_start + target.offset,
                          start + this.offset,
                          end + this.offset);
};


// slice(start, end)
Buffer.prototype.slice = function(start, end) {
  if (end === undefined) end = this.length;
  if (end > this.length) throw new Error('oob');
  if (start > end) throw new Error('oob');

  return new Buffer(this.parent, end - start, +start + this.offset);
};


// Legacy methods for backwards compatibility.

Buffer.prototype.utf8Slice = function(start, end) {
  return this.toString('utf8', start, end);
};

Buffer.prototype.binarySlice = function(start, end) {
  return this.toString('binary', start, end);
};

Buffer.prototype.asciiSlice = function(start, end) {
  return this.toString('ascii', start, end);
};

Buffer.prototype.utf8Write = function(string, offset) {
  return this.write(string, offset, 'utf8');
};

Buffer.prototype.binaryWrite = function(string, offset) {
  return this.write(string, offset, 'binary');
};

Buffer.prototype.asciiWrite = function(string, offset) {
  return this.write(string, offset, 'ascii');
};

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  return buffer.parent[buffer.offset + offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset] << 8;
    val |= buffer.parent[buffer.offset + offset + 1];
  } else {
    val = buffer.parent[buffer.offset + offset];
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (isBigEndian) {
    val = buffer.parent[buffer.offset + offset + 1] << 16;
    val |= buffer.parent[buffer.offset + offset + 2] << 8;
    val |= buffer.parent[buffer.offset + offset + 3];
    val = val + (buffer.parent[buffer.offset + offset] << 24 >>> 0);
  } else {
    val = buffer.parent[buffer.offset + offset + 2] << 16;
    val |= buffer.parent[buffer.offset + offset + 1] << 8;
    val |= buffer.parent[buffer.offset + offset];
    val = val + (buffer.parent[buffer.offset + offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  neg = buffer.parent[buffer.offset + offset] & 0x80;
  if (!neg) {
    return (buffer.parent[buffer.offset + offset]);
  }

  return ((0xff - buffer.parent[buffer.offset + offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  buffer.parent[buffer.offset + offset] = value;
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset + 1] = value & 0x00ff;
  } else {
    buffer.parent[buffer.offset + offset + 1] = (value & 0xff00) >>> 8;
    buffer.parent[buffer.offset + offset] = value & 0x00ff;
  }
}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  if (isBigEndian) {
    buffer.parent[buffer.offset + offset] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset + 3] = value & 0xff;
  } else {
    buffer.parent[buffer.offset + offset + 3] = (value >>> 24) & 0xff;
    buffer.parent[buffer.offset + offset + 2] = (value >>> 16) & 0xff;
    buffer.parent[buffer.offset + offset + 1] = (value >>> 8) & 0xff;
    buffer.parent[buffer.offset + offset] = value & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

SlowBuffer.prototype.readUInt8 = Buffer.prototype.readUInt8;
SlowBuffer.prototype.readUInt16LE = Buffer.prototype.readUInt16LE;
SlowBuffer.prototype.readUInt16BE = Buffer.prototype.readUInt16BE;
SlowBuffer.prototype.readUInt32LE = Buffer.prototype.readUInt32LE;
SlowBuffer.prototype.readUInt32BE = Buffer.prototype.readUInt32BE;
SlowBuffer.prototype.readInt8 = Buffer.prototype.readInt8;
SlowBuffer.prototype.readInt16LE = Buffer.prototype.readInt16LE;
SlowBuffer.prototype.readInt16BE = Buffer.prototype.readInt16BE;
SlowBuffer.prototype.readInt32LE = Buffer.prototype.readInt32LE;
SlowBuffer.prototype.readInt32BE = Buffer.prototype.readInt32BE;
SlowBuffer.prototype.readFloatLE = Buffer.prototype.readFloatLE;
SlowBuffer.prototype.readFloatBE = Buffer.prototype.readFloatBE;
SlowBuffer.prototype.readDoubleLE = Buffer.prototype.readDoubleLE;
SlowBuffer.prototype.readDoubleBE = Buffer.prototype.readDoubleBE;
SlowBuffer.prototype.writeUInt8 = Buffer.prototype.writeUInt8;
SlowBuffer.prototype.writeUInt16LE = Buffer.prototype.writeUInt16LE;
SlowBuffer.prototype.writeUInt16BE = Buffer.prototype.writeUInt16BE;
SlowBuffer.prototype.writeUInt32LE = Buffer.prototype.writeUInt32LE;
SlowBuffer.prototype.writeUInt32BE = Buffer.prototype.writeUInt32BE;
SlowBuffer.prototype.writeInt8 = Buffer.prototype.writeInt8;
SlowBuffer.prototype.writeInt16LE = Buffer.prototype.writeInt16LE;
SlowBuffer.prototype.writeInt16BE = Buffer.prototype.writeInt16BE;
SlowBuffer.prototype.writeInt32LE = Buffer.prototype.writeInt32LE;
SlowBuffer.prototype.writeInt32BE = Buffer.prototype.writeInt32BE;
SlowBuffer.prototype.writeFloatLE = Buffer.prototype.writeFloatLE;
SlowBuffer.prototype.writeFloatBE = Buffer.prototype.writeFloatBE;
SlowBuffer.prototype.writeDoubleLE = Buffer.prototype.writeDoubleLE;
SlowBuffer.prototype.writeDoubleBE = Buffer.prototype.writeDoubleBE;

})()
},{"assert":2,"./buffer_ieee754":7,"base64-js":9}],9:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],26:[function(require,module,exports){
(function(Buffer){//     uuid.js
//
//     (c) 2010-2012 Robert Kieffer
//     MIT License
//     https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (_global.define && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}());

})(require("__browserify_buffer").Buffer)
},{"crypto":28,"__browserify_buffer":27}],29:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('./util');

module.exports = Channel;

function Channel(socket) {
  EventEmitter.call(this);

  this.socket = socket;
  this.messages = new Messages;

  var channel = this;
  var onmessage = socket.onmessage;
  socket.onmessage = function(data) {
    if (data && data.racer) return channel._onMessage(data);
    onmessage && onmessage.call(socket, data);
  };
}

util.mergeInto(Channel.prototype, EventEmitter.prototype);

Channel.prototype.send = function(name, data, cb) {
  var message = this.messages.add(name, data, cb);
  // Proactively call the toJSON function, since the Google Closure JSON
  // serializer doesn't check for it
  this.socket.send(message.toJSON());
};

Channel.prototype._reply = function(id, name, data) {
  var message = new Message(id, true, name, data);
  this.socket.send(message.toJSON());
};

Channel.prototype._onMessage = function(data) {
  if (data.ack) {
    var message = this.messages.remove(data.id);
    if (message && message.cb) message.cb.apply(data.data);
    return;
  }
  var name = data.racer;
  if (data.cb) {
    var channel = this;
    var hasListeners = this.emit(name, data.data, function() {
      var args = Array.prototype.slice.call(arguments);
      channel._reply(data.id, name, args);
    });
    if (!hasListeners) this._reply(data.id, name);
  } else {
    this.emit(name, data.data);
    this._reply(data.id, name);
  }
};

function MessagesMap() {}

function Messages() {
  this.map = new MessagesMap();
  this.idCount = 0;
}
Messages.prototype.id = function() {
  return (++this.idCount).toString(36);
};
Messages.prototype.add = function(name, data, cb) {
  var message = new Message(this.id(), false, name, data, cb);
  this.map[message.id] = message;
  return message;
};
Messages.prototype.remove = function(id) {
  var message = this.map[id];
  delete this.map[id];
  return message;
};

function Message(id, ack, name, data, cb) {
  this.id = id;
  this.ack = ack;
  this.name = name;
  this.data = data;
  this.cb = cb;
}
Message.prototype.toJSON = function() {
  return {
    racer: this.name
  , id: this.id
  , data: this.data
  , ack: +this.ack
  , cb: (this.cb) ? 1 : 0
  };
};

},{"events":6,"./util":7}],13:[function(require,module,exports){
var Doc = require('./Doc');

module.exports = LocalDoc;

function LocalDoc(collectionName, id, snapshot) {
  Doc.call(this, collectionName, id);
  this.snapshot = snapshot;
}

LocalDoc.prototype = new Doc;

LocalDoc.prototype.set = function(segments, value, cb) {
  function set(node, key) {
    var previous = node[key];
    node[key] = value;
    return previous;
  }
  return this._apply(segments, set, cb);
};

LocalDoc.prototype.del = function(segments, cb) {
  // Don't do anything if the value is already undefined, since
  // apply creates objects as it traverses, and the del method
  // should not create anything
  var previous = this.get(segments);
  if (previous === void 0) {
    cb();
    return;
  }
  function del(node, key) {
    delete node[key];
    return previous;
  }
  return this._apply(segments, del, cb);
};

LocalDoc.prototype.increment = function(segments, byNumber, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'number' || value == null) return;
    return new TypeError(self._errorMessage(
      'increment on non-number', segments, value
    ));
  }
  function increment(node, key) {
    var value = (node[key] || 0) + byNumber;
    node[key] = value;
    return value;
  }
  return this._validatedApply(segments, validate, increment, cb);
};

LocalDoc.prototype.push = function(segments, value, cb) {
  function push(arr) {
    return arr.push(value);
  }
  return this._arrayApply(segments, push, cb);
};

LocalDoc.prototype.unshift = function(segments, value, cb) {
  function unshift(arr) {
    return arr.unshift(value);
  }
  return this._arrayApply(segments, unshift, cb);
};

LocalDoc.prototype.insert = function(segments, index, values, cb) {
  function insert(arr) {
    arr.splice.apply(arr, [index, 0].concat(values));
    return arr.length;
  }
  return this._arrayApply(segments, insert, cb);
};

LocalDoc.prototype.pop = function(segments, cb) {
  function pop(arr) {
    return arr.pop();
  }
  return this._arrayApply(segments, pop, cb);
};

LocalDoc.prototype.shift = function(segments, cb) {
  function shift(arr) {
    return arr.shift();
  }
  return this._arrayApply(segments, shift, cb);
};

LocalDoc.prototype.remove = function(segments, index, howMany, cb) {
  function remove(arr) {
    return arr.splice(index, howMany);
  }
  return this._arrayApply(segments, remove, cb);
};

LocalDoc.prototype.move = function(segments, from, to, howMany, cb) {
  function move(arr) {
    // Remove from old location
    var values = arr.splice(from, howMany);
    // Insert in new location
    arr.splice.apply(arr, [to, 0].concat(values));
    return values;
  }
  return this._arrayApply(segments, move, cb);
};

LocalDoc.prototype.stringInsert = function(segments, index, value, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'string' || value == null) return;
    return new TypeError(self._errorMessage(
      'stringInsert on non-string', segments, value
    ));
  }
  function stringInsert(node, key) {
    var previous = node[key];
    if (previous == null) {
      node[key] = value;
      return previous;
    }
    node[key] = previous.slice(0, index) + value + previous.slice(index);
    return previous;
  }
  return this._validatedApply(segments, validate, stringInsert, cb);
};

LocalDoc.prototype.stringRemove = function(segments, index, howMany, cb) {
  var self = this;
  function validate(value) {
    if (typeof value === 'string' || value == null) return;
    return new TypeError(self._errorMessage(
      'stringRemove on non-string', segments, value
    ));
  }
  function stringRemove(node, key) {
    var previous = node[key];
    if (previous == null) return previous;
    if (index < 0) index += previous.length;
    node[key] = previous.slice(0, index) + previous.slice(index + howMany);
    return previous;
  }
  return this._validatedApply(segments, validate, stringRemove, cb);
};

LocalDoc.prototype.get = function(segments) {
  return this._get(this.snapshot, segments);
};

/**
 * @param {Array} segments is the array representing a path
 * @param {Function} fn(node, key) applies a mutation on node[key]
 * @return {Object} returns the return value of fn(node, key)
 */
LocalDoc.prototype._createImplied = function(segments, fn) {
  var node = this;
  var key = 'snapshot';
  var i = 0;
  var nextKey = segments[i++];
  while (nextKey != null) {
    // Get or create implied object or array
    node = node[key] || (node[key] = /^\d+$/.test(nextKey) ? [] : {});
    key = nextKey;
    nextKey = segments[i++];
  }
  return fn(node, key);
};

LocalDoc.prototype._apply = function(segments, fn, cb) {
  var out = this._createImplied(segments, fn);
  cb();
  return out;
};

LocalDoc.prototype._validatedApply = function(segments, validate, fn, cb) {
  return this._createImplied(segments, function(node, key) {
    var err = validate(node[key]);
    if (err) return cb(err);
    var out = fn(node, key);
    cb();
    return out;
  });
};

LocalDoc.prototype._arrayApply = function(segments, fn, cb) {
  // Lookup a pointer to the property or nested property &
  // return the current value or create a new array
  var arr = this._createImplied(segments, nodeCreateArray);

  if (!Array.isArray(arr)) {
    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);
    var err = new TypeError(message);
    return cb(err);
  }
  var out = fn(arr);
  cb();
  return out;
};

function nodeCreateArray(node, key) {
  return node[key] || (node[key] = []);
}

},{"./Doc":30}],14:[function(require,module,exports){
/**
 * RemoteDoc adapts the ShareJS operation protocol to Racer's mutator
 * interface.
 *
 * 1. It maps Racer's mutator methods to outgoing ShareJS operations.
 * 2. It maps incoming ShareJS operations to Racer events.
 */

var Doc = require('./Doc');

module.exports = RemoteDoc;

function RemoteDoc(collectionName, id, data, model) {
  Doc.call(this, collectionName, id);
  var shareDoc = this.shareDoc = model._getOrCreateShareDoc(collectionName, id, data);
  this.createdLocally = false;
  this.model = model = model.pass({$remote: true});
  this._passStringInsert = model.pass({$original: 'stringInsert'})._pass;
  this._passStringRemove = model.pass({$original: 'stringRemove'})._pass;

  var doc = this;
  shareDoc.on('op', function(op, isLocal) {
    // Don't emit on local operations, since they are emitted in the mutator
    if (isLocal) return;
    doc._onOp(op);
  });
  shareDoc.on('del', function(isLocal, previous) {
    // Calling the shareDoc.del method does not emit an operation event,
    // so we create the appropriate event here.
    if (isLocal) return;
    model.emit('change', [collectionName, id], [void 0, previous, model._pass]);
  });
  shareDoc.on('create', function(isLocal) {
    // Local creates should not emit an event, since they only happen
    // implicitly as a result of another mutation, and that operation will
    // emit the appropriate event. Remote creates can set the snapshot data
    // without emitting an operation event, so an event needs to be emitted
    // for them.
    if (isLocal) {
      // Track when a document was created by this client, so that we don't
      // emit a load event when subsequently subscribed
      doc.createdLocally = true;
      return;
    };
    var value = shareDoc.snapshot;
    model.emit('change', [collectionName, id], [value, void 0, model._pass]);
  });
}

RemoteDoc.prototype = new Doc;

RemoteDoc.prototype.set = function(segments, value, cb) {
  if (segments.length === 0 && !this.shareDoc.type) {
    this.shareDoc.create('json0', value, cb);
    return;
  }
  var previous = this._createImplied(segments);
  var lastSegment = segments[segments.length - 1];
  var op = (isArrayIndex(lastSegment)) ?
    (previous == null) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, value)] :
      [new ListReplaceOp(segments.slice(0, -1), lastSegment, previous, value)] :
    (previous == null) ?
      [new ObjectInsertOp(segments, value)] :
      [new ObjectReplaceOp(segments, previous, value)];
  this.shareDoc.submitOp(op, cb);
  return previous;
};

RemoteDoc.prototype.del = function(segments, cb) {
  if (segments.length === 0) {
    var previous = this.get();
    this.shareDoc.del(cb);
    return previous;
  }
  // Don't do anything if the value is already undefined, since
  // the del method should not create anything
  var previous = this.get(segments);
  if (previous === void 0) {
    cb();
    return;
  }
  var op = [new ObjectDeleteOp(segments, previous)];
  this.shareDoc.submitOp(op, cb);
  return previous;
};

RemoteDoc.prototype.increment = function(segments, byNumber, cb) {
  var previous = this._createImplied(segments);
  if (previous == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, byNumber)] :
      [new ObjectInsertOp(segments, byNumber)];
    this.shareDoc.submitOp(op, cb);
    return byNumber;
  }
  var op = [new IncrementOp(segments, byNumber)];
  this.shareDoc.submitOp(op, cb);
  return previous + byNumber;
};

RemoteDoc.prototype.push = function(segments, value, cb) {
  var shareDoc = this.shareDoc;
  function push(arr, fnCb) {
    var op = [new ListInsertOp(segments, arr.length, value)];
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, push, cb);
};

RemoteDoc.prototype.unshift = function(segments, value, cb) {
  var shareDoc = this.shareDoc;
  function unshift(arr, fnCb) {
    var op = [new ListInsertOp(segments, 0, value)];
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, unshift, cb);
};

RemoteDoc.prototype.insert = function(segments, index, values, cb) {
  var shareDoc = this.shareDoc;
  function insert(arr, fnCb) {
    var op = (Array.isArray(values)) ?
      eachOp(ListInsertOp, segments, index, values) :
      [new ListInsertOp(segments, index, values)];
    shareDoc.submitOp(op, fnCb);
    return arr.length;
  }
  return this._arrayApply(segments, insert, cb);
};

RemoteDoc.prototype.pop = function(segments, cb) {
  var shareDoc = this.shareDoc;
  function pop(arr, fnCb) {
    var index = arr.length - 1;
    var value = arr[index];
    var op = [new ListRemoveOp(segments, index, value)];
    shareDoc.submitOp(op, fnCb);
    return value;
  }
  return this._arrayApply(segments, pop, cb);
};

RemoteDoc.prototype.shift = function(segments, cb) {
  var shareDoc = this.shareDoc;
  function shift(arr, fnCb) {
    var value = arr[0];
    var op = [new ListRemoveOp(segments, 0, value)];
    shareDoc.submitOp(op, fnCb);
    return value;
  }
  return this._arrayApply(segments, shift, cb);
};

RemoteDoc.prototype.remove = function(segments, index, howMany, cb) {
  var shareDoc = this.shareDoc;
  function remove(arr, fnCb) {
    var values = arr.slice(index, index + howMany);
    var op = eachOp(ListRemoveOp, segments, index, values);
    shareDoc.submitOp(op, fnCb);
    return values;
  }
  return this._arrayApply(segments, remove, cb);
};

function eachOp(Constructor, segments, index, values) {
  var op = [];
  for (var i = 0, len = values.length; i < len; i++) {
    op.push(new Constructor(segments, index++, values[i]));
  }
  return op;
}

RemoteDoc.prototype.move = function(segments, from, to, howMany, cb) {
  var shareDoc = this.shareDoc;
  function move(arr, fnCb) {
    // Get the return value
    var values = arr.slice(from, from + howMany);

    // Build an op that moves each item individually
    var op = [];
    for (var i = 0; i < howMany; i++) {
      op.push(new ListMoveOp(segments, from, (from < to) ? to : to + i));
    }
    shareDoc.submitOp(op, fnCb);

    return values;
  }
  return this._arrayApply(segments, move, cb);
};

RemoteDoc.prototype.stringInsert = function(segments, index, value, cb) {
  var previous = this._createImplied(segments);
  if (previous == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, value)] :
      [new ObjectInsertOp(segments, value)];
    this.shareDoc.submitOp(op, cb);
    return previous;
  }
  var op = [new StringInsertOp(segments, index, value)];
  this.shareDoc.submitOp(op, cb);
  return previous;
};

RemoteDoc.prototype.stringRemove = function(segments, index, howMany, cb) {
  var previous = this._createImplied(segments);
  if (previous == null) return previous;
  var removed = previous.slice(index, index + howMany);
  var op = [new StringRemoveOp(segments, index, removed)];
  this.shareDoc.submitOp(op, cb);
  return previous;
};

RemoteDoc.prototype.get = function(segments) {
  return this._get(this.shareDoc.snapshot, segments);
};

RemoteDoc.prototype._createImplied = function(segments) {
  if (!this.shareDoc.type) {
    this.shareDoc.create('json0');
  }
  var parent = this.shareDoc;
  var key = 'snapshot';
  var node = parent[key];
  var i = 0;
  var nextKey = segments[i++];
  while (nextKey != null) {
    if (!node) {
      var value = isArrayIndex(nextKey) ? [] : {};
      var op = (Array.isArray(parent)) ?
        new ListInsertOp(segments.slice(0, i - 2), key, value) :
        new ObjectInsertOp(segments.slice(0, i - 1), value);
      this.shareDoc.submitOp(op);
      node = parent[key];
    }
    parent = node;
    key = nextKey;
    node = parent[key];
    nextKey = segments[i++];
  }
  return node;
};

RemoteDoc.prototype._arrayApply = function(segments, fn, cb) {
  var arr = this._createImplied(segments);
  if (arr == null) {
    var lastSegment = segments[segments.length - 1];
    var op = (isArrayIndex(lastSegment)) ?
      [new ListInsertOp(segments.slice(0, -1), lastSegment, [])] :
      [new ObjectInsertOp(segments, [])];
    this.shareDoc.submitOp(op);
    arr = this.get(segments);
  }

  if (!Array.isArray(arr)) {
    var message = this._errorMessage(fn.name + ' on non-array', segments, arr);
    var err = new TypeError(message);
    return cb(err);
  }
  return fn(arr, cb);
};

RemoteDoc.prototype._onOp = function(op) {
  var item = op[0];
  var segments = [this.collectionName, this.id].concat(item.p);
  var model = this.model;

  // ObjectReplaceOp, ObjectInsertOp, or ObjectDeleteOp
  if (defined(item.oi) || defined(item.od)) {
    var value = item.oi;
    var previous = item.od;
    model.emit('change', segments, [value, previous, model._pass]);

  // ListReplaceOp
  } else if (defined(item.li) && defined(item.ld)) {
    var value = item.li;
    var previous = item.ld;
    model.emit('change', segments, [value, previous, model._pass]);

  // ListInsertOp
  } else if (defined(item.li)) {
    var index = segments[segments.length - 1];
    var values = [item.li];
    model.emit('insert', segments.slice(0, -1), [index, values, model._pass]);

  // ListRemoveOp
  } else if (defined(item.ld)) {
    var index = segments[segments.length - 1];
    var removed = [item.ld];
    model.emit('remove', segments.slice(0, -1), [index, removed, model._pass]);

  // ListMoveOp
  } else if (defined(item.lm)) {
    var from = segments[segments.length - 1];
    var to = item.lm - 1;
    var howMany = 1;
    model.emit('move', segments.slice(0, -1), [from, to, howMany, model._pass]);

  // StringInsertOp
  } else if (defined(item.si)) {
    var index = segments[segments.length - 1];
    var text = item.si;
    segments = segments.slice(0, -1);
    model.emit('stringInsert', segments, [index, text, model._pass]);
    var value = model._get(segments);
    var previous = value.slice(0, index) + value.slice(index + text.length);
    model.emit('change', segments, [value, previous, this._passStringInsert]);

  // StringRemoveOp
  } else if (defined(item.sd)) {
    var index = segments[segments.length - 1];
    var text = item.sd;
    var howMany = text.length;
    segments = segments.slice(0, -1);
    model.emit('stringRemove', segments, [index, howMany, model._pass]);
    var value = model._get(segments);
    var previous = value.slice(0, index) + text + value.slice(index);
    model.emit('change', segments, [value, previous, this._passStringRemove]);

  // IncrementOp
  } else if (defined(item.na)) {
    var value = this.get(item.p);
    var previous = value - item.na;
    model.emit('change', segments, [value, previous, model._pass]);
  }
};

function ObjectReplaceOp(segments, before, after) {
  this.p = castSegments(segments);
  this.od = before;
  this.oi = after;
}
function ObjectInsertOp(segments, value) {
  this.p = castSegments(segments);
  this.oi = value;
}
function ObjectDeleteOp(segments, value) {
  this.p = castSegments(segments);
  this.od = value;
}
function ListReplaceOp(segments, index, before, after) {
  this.p = castSegments(segments.concat(index));
  this.ld = before;
  this.li = after;
}
function ListInsertOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.li = value;
}
function ListRemoveOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.ld = value;
}
function ListMoveOp(segments, from, to) {
  this.p = castSegments(segments.concat(from));
  this.lm = to + 1;
}
function StringInsertOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.si = value;
}
function StringRemoveOp(segments, index, value) {
  this.p = castSegments(segments.concat(index));
  this.sd = value;
}
function IncrementOp(segments, byNumber) {
  this.p = castSegments(segments);
  this.na = byNumber;
}

function defined(value) {
  return value !== void 0;
}

function castSegments(segments) {
  // Cast number path segments from strings to numbers
  for (var i = segments.length; i--;) {
    var segment = segments[i];
    if (typeof segment === 'string' && isArrayIndex(segment)) {
      segments[i] = +segment;
    }
  }
  return segments;
}

function isArrayIndex(segment) {
  return (/^[0-9]+$/).test(segment);
}

},{"./Doc":30}],24:[function(require,module,exports){
var share = require('share/lib/client');
var Channel = require('../Channel');
var Model = require('./index');

Model.prototype._createConnection = function(bundle) {
  // Model#_createSocket should be defined by the socket plugin
  this.socket = this._createSocket(bundle);

  // The Share connection will bind to the socket by defining the onopen,
  // onmessage, etc. methods
  var shareConnection = this.shareConnection = new share.Connection(this.socket);
  var segments = ['$connection', 'state'];
  var states = ['connecting', 'connected', 'disconnected', 'stopped'];
  var model = this;
  states.forEach(function(state) {
    shareConnection.on(state, function() {
      model._set(segments, state);
    });
  });
  this._set(segments, 'connected');

  // Wrap the socket methods on top of Share's methods
  this._createChannel();
};

Model.prototype.connect = function() {
  this.socket.open();
};
Model.prototype.disconnect = function() {
  this.socket.close();
};
Model.prototype.reconnect = function() {
  this.disconnect();
  this.connect();
};

Model.prototype._createChannel = function() {
  this.channel = new Channel(this.socket);
};

},{"../Channel":29,"./index":8,"share/lib/client":31}],30:[function(require,module,exports){
module.exports = Doc;

function Doc(collectionName, id) {
  this.collectionName = collectionName;
  this.id = id;
}

Doc.prototype.path = function(segments) {
  return this.collectionName + '.' + this.id + '.' + segments.join('.');
};

Doc.prototype._get = function(snapshot, segments) {
  if (!segments) return snapshot;
  var node = snapshot;
  var i = 0;
  var key = segments[i++];
  while (key != null) {
    if (node == null) return;
    node = node[key];
    key = segments[i++];
  }
  return node;
};

Doc.prototype._errorMessage = function(description, segments, value) {
  return description + ' at ' + this.path(segments) + ': ' +
    JSON.stringify(value, null, 2);
};

},{}],25:[function(require,module,exports){
var util = require('../util');
var Model = require('./index');
var arrayDiff = require('arraydiff');

Model.prototype.setDiff = function() {
  var subpath, value, options, cb;
  if (arguments.length === 1) {
    value = arguments[0];
  } else if (arguments.length === 2) {
    subpath = arguments[0];
    value = arguments[1];
  } else if (arguments.length === 3) {
    subpath = arguments[0];
    value = arguments[1];
    if (typeof arguments[2] === 'function') {
      cb = arguments[2];
    } else {
      options = arguments[2];
    }
  } else {
    subpath = arguments[0];
    value = arguments[1];
    options = arguments[2];
    cb = arguments[3];
  }
  var segments = this._splitPath(subpath);
  return this._setDiff(segments, value, options, cb);
};
Model.prototype._setDiff = function(segments, value, options, cb) {
  segments = this._dereference(segments);
  var equalFn = (options && options.equal) || util.equal;
  var isEach = options && options.each;
  var model = this;
  function setDiff(doc, docSegments, fnCb) {
    var before = doc.get(docSegments);
    if (equalFn(before, value)) return fnCb();
    var group = util.asyncGroup(fnCb);
    doDiff(model, doc, segments, before, value, equalFn, group, isEach);
  }
  return this._mutate(segments, setDiff, cb);
};

/**
 * @param {Object} doc
 * @param {String} doc.collectionName
 * @param {String} doc.id
 * @param {Object} doc.snapshot
 * @param {Array} segments
 * @param {Object} before
 * @param {Object} after
 * @param {Function} group
 * @param {Boolean} isEach
 */
function doDiff(model, doc, segments, before, after, equalFn, group, isEach) {
  if (typeof before !== 'object' || !before ||
      typeof after !== 'object' || !after) {
    // Set the entire value if not diffable
    var docSegments = segments.slice(2);
    var previous = doc.set(docSegments, after, group());
    model.emit('change', segments, [after, previous, model._pass]);
    return;
  }
  if (Array.isArray(before) && Array.isArray(after)) {
    var diff = arrayDiff(before, after, equalFn);
    if (!diff.length) return;
    // If the only change is a single item replacement, diff the item instead
    if (
      diff.length === 2 &&
      diff[0].index === diff[1].index &&
      diff[0] instanceof arrayDiff.RemoveDiff &&
      diff[0].howMany === 1 &&
      diff[1] instanceof arrayDiff.InsertDiff &&
      diff[1].values.length === 1
    ) {
      var index = diff[0].index;
      var itemSegments = segments.concat(index);
      doDiff(model, doc, itemSegments, before[index], after[index], equalFn, group);
      return;
    }
    var docSegments = segments.slice(2);
    for (var i = 0, len = diff.length; i < len; i++) {
      var item = diff[i];
      if (item instanceof arrayDiff.InsertDiff) {
        // Insert
        doc.insert(docSegments, item.index, item.values, group());
        model.emit('insert', segments, [item.index, item.values, model._pass]);
      } else if (item instanceof arrayDiff.RemoveDiff) {
        // Remove
        var removed = doc.remove(docSegments, item.index, item.howMany, group());
        model.emit('remove', segments, [item.index, removed, model._pass]);
      } else if (item instanceof arrayDiff.MoveDiff) {
        // Move
        var moved = doc.move(docSegments, item.from, item.to, item.howMany, group());
        model.emit('move', segments, [item.from, item.to, moved.length, model._pass]);
      }
    }
    return;
  }
  if (!isEach) {
    // Delete keys that were in before but not after
    for (var key in before) {
      if (key in after) continue;
      var itemSegments = segments.concat(key);
      var docSegments = segments.slice(2);
      var previous = doc.del(docSegments, group());
      model.emit('change', itemSegments, [void 0, previous, model._pass]);
    }
  }
  // Diff each property in after
  for (var key in after) {
    if (equalFn(before[key], after[key])) continue;
    var itemSegments = segments.concat(key);
    doDiff(model, doc, itemSegments, before[key], after[key], equalFn, group);
  }
}

},{"../util":7,"./index":8,"arraydiff":32}],17:[function(require,module,exports){
(function(process){var util = require('../util');
var Model = require('./index');
var arrayDiff = require('arraydiff');
var deepEquals = require('deep-is');

module.exports = Query;

Model.INITS.push(function(model) {
  model._queries = new Queries;
  if (model.fetchOnly) return;
  model.on('all', function(segments) {
    // Updated async, since this is likely the result of an operation that
    // includes creating the doc, and we would like that to happen before
    // sending the subscribe message
    process.nextTick(function() {
      var map = model._queries.map;
      for (var hash in map) {
        var query = map[hash];
        if (query.isPathQuery && query.shareQuery && util.mayImpact(query.expression, segments)) {
          var ids = pathIds(model, query.expression);
          var previousIds = model._get(query.idSegments);
          query._onChange(ids, previousIds);
        }
      }
    });
  });
});

/**
 * @param {String} collectionName
 * @param {Object} expression
 * @param {String} source
 * @return {Query}
 */
Model.prototype.query = function(collectionName, expression, source) {
  if (typeof expression.path === 'function' || typeof expression !== 'object') {
    expression = this._splitPath(expression);
  }
  var query = this._queries.get(collectionName, expression, source);
  if (query) return query;
  query = new Query(this, collectionName, expression, source);
  this._queries.add(query);
  return query;
};

/**
 * Called during initialization of the bundle on page load.
 * @param {Array} items
 * @param {Array} items[*]
 * @param {String} items[*][0] collectionName
 * @param {Object} items[*][1] expression
 * @param {String} items[*][2] source
 * @param {Number} items[*][3] subscribeCount
 * @param {Number} items[*][4] fetchCount
 * @param {Array}  items[*][5] fetchIds
 */
Model.prototype._initQueries = function(items) {
  for (var i = 0; i < items.length; i++) {
    var item = items[i];
    var query = new Query(this, item[0], item[1], item[2], item[3], item[4], item[5]);
    var count = query.fetchCount;
    while (count--) this.emit('fetchQuery', query, this._context);
    var count = query.subscribeCount;
    query.subscribeCount = 0;
    while (count--) query.subscribe();
  }
};

function QueriesMap() {}

function Queries() {
  this.map = new QueriesMap;
}
Queries.prototype.add = function(query) {
  this.map[query.hash] = query;
};
Queries.prototype.remove = function(query) {
  delete this.map[query.hash];
};
Queries.prototype.get = function(collectionName, expression, source) {
  var hash = queryHash(collectionName, expression, source);
  return this.map[hash];
};
Queries.prototype.toJSON = function() {
  var out = [];
  for (var hash in this.map) {
    var query = this.map[hash];
    if (query.subscribeCount || query.fetchCount) {
      out.push(query.serialize());
    }
  }
  return out;
};

/**
 * @private
 * @constructor
 * @param {Model} model
 * @param {Object} collectionName
 * @param {Object} expression
 * @param {String} source (e.g., 'solr')
 * @param {Number} subscribeCount
 * @param {Number} fetchCount
 * @param {Array<Array<String>>} fetchIds
 */
function Query(model, collectionName, expression, source, subscribeCount, fetchCount, fetchIds) {
  this.model = model.pass({$query: this});
  this.collectionName = collectionName;
  this.expression = expression;
  this.source = source;
  this.hash = queryHash(collectionName, expression, source);
  this.segments = ['$queries', this.hash];
  this.idSegments = ['$queries', this.hash, 'ids'];
  this.extraSegments = ['$queries', this.hash, 'extra'];
  this.isPathQuery = Array.isArray(expression);

  this._pendingSubscribeCallbacks = [];

  // These are used to help cleanup appropriately when calling unsubscribe and
  // unfetch. A query won't be fully cleaned up until unfetch and unsubscribe
  // are called the same number of times that fetch and subscribe were called.
  this.subscribeCount = subscribeCount || 0;
  this.fetchCount = fetchCount || 0;
  // The list of ids at the time of each fetch is pushed onto fetchIds, so
  // that unfetchDoc can be called the same number of times as fetchDoc
  this.fetchIds = fetchIds || [];

  this.created = false;
  this.shareQuery = null;
}

Query.prototype.create = function() {
  this.created = true;
  this.model._queries.add(this);
};

Query.prototype.destroy = function() {
  this.created = false;
  if (this.shareQuery) {
    this.shareQuery.destroy();
    this.shareQuery = null;
  }
  this.model._queries.remove(this);
  this.model._del(this.segments);
};

Query.prototype.sourceQuery = function() {
  if (this.isPathQuery) {
    var ids = pathIds(this.model, this.expression);
    return {_id: {$in: ids}};
  }
  return this.expression;
};

/**
 * @param {Function} [cb] cb(err)
 */
Query.prototype.fetch = function(cb) {
  if (!cb) cb = this.model._defaultCallback;
  this.model.emit('fetchQuery', this, this.model._context);

  this.fetchCount++;

  if (!this.created) this.create();
  var query = this;

  var model = this.model;
  var shareDocs = collectionShareDocs(this.model, this.collectionName);
  var options = {docMode: 'fetch', knownDocs: shareDocs};
  if (this.source) options.source = this.source;

  model.shareConnection.createFetchQuery(
    this.collectionName, this.sourceQuery(), options, fetchQueryCallback
  );
  function fetchQueryCallback(err, results, extra) {
    if (err) return cb(err);
    var ids = resultsIds(results);

    // Keep track of the ids at fetch time for use in unfetch
    query.fetchIds.push(ids.slice());
    // Update the results ids and extra
    model._setDiff(query.idSegments, ids);
    if (extra !== void 0) {
      model._setDiff(query.extraSegments, extra, {equal: deepEquals});
    }

    if (!ids.length) return cb();

    // Call fetchDoc for each document returned so that the proper load events
    // and internal counts are maintained. However, specify that we already
    // loaded the documents as part of the query, since we don't want to
    // actually fetch the documents again
    var alreadyLoaded = true;
    var group = util.asyncGroup(cb);
    for (var i = 0; i < ids.length; i++) {
      model.fetchDoc(query.collectionName, ids[i], group(), alreadyLoaded);
    }
  }
  return this;
};

/**
 * Sets up a subscription to `this` query.
 * @param {Function} cb(err)
 */
Query.prototype.subscribe = function(cb) {
  if (!cb) cb = this.model._defaultCallback;
  this.model.emit('subscribeQuery', this, this.model._context);

  var query = this;

  if (this.subscribeCount++) {
    process.nextTick(function () {
      var data = query.model._get(query.segments);
      if (data) cb();
      else query._pendingSubscribeCallbacks.push(cb);
    });
    return this;
  }

  if (!this.created) this.create();

  // When doing server-side rendering, we actually do a fetch the first time
  // that subscribe is called, but keep track of the state as if subscribe
  // were called for proper initialization in the client
  var shareDocs = collectionShareDocs(this.model, this.collectionName);
  var options = {docMode: 'sub', knownDocs: shareDocs};
  if (this.source) options.source = this.source;

  if (!this.model.fetchOnly) {
    this._shareSubscribe(options, cb);
    return this;
  }

  var model = this.model;
  options.docMode = 'fetch';
  model.shareConnection.createFetchQuery(
    this.collectionName, this.sourceQuery(), options, function(err, results, extra) {
      if (err) return cb(err);
      var ids = resultsIds(results);
      if (extra !== void 0) {
        model._setDiff(query.extraSegments, extra, {equal: deepEquals});
      }
      query._onChange(ids, null, cb);
      while (cb = query._pendingSubscribeCallbacks.shift()) {
        query._onChange(ids, null, cb);
      }
    }
  );
  return this;
};

/**
 * @private
 * @param {Object} options
 * @param {String} [options.source]
 * @param {Boolean} [options.poll]
 * @param {Boolean} [options.docMode = fetch or subscribe]
 * @param {Function} cb(err, results)
 */
Query.prototype._shareSubscribe = function(options, cb) {
  var query = this;
  var model = this.model;
  this.shareQuery = this.model.shareConnection.createSubscribeQuery(
    this.collectionName, this.sourceQuery(), options, function (err, results, extra) {
      if (err) return cb(err);
      var ids = resultsIds(results);
      if (extra !== void 0) {
        model._setDiff(query.extraSegments, extra, {equal: deepEquals});
      }
      query._onChange(ids, null, cb);
    }
  );
  var query = this;
  this.shareQuery.on('insert', function(shareDocs, index) {
    query._onInsert(shareDocs, index);
  });
  this.shareQuery.on('remove', function(shareDocs, index) {
    query._onRemove(shareDocs, index);
  });
  this.shareQuery.on('move', function(shareDocs, from, to) {
    query._onMove(shareDocs, from, to);
  });
  this.shareQuery.on('change', function(results, previous) {
    // Get the new and previous list of ids when the entire results set changes
    var ids = resultsIds(results);
    var previousIds = previous && resultsIds(previous);
    query._onChange(ids, previousIds);
  });
  this.shareQuery.on('extra', function (extra) {
    model._setDiff(query.extraSegments, extra, {equal: deepEquals});
  });
};

/**
 * @public
 * @param {Function} cb(err, newFetchCount)
 */
Query.prototype.unfetch = function(cb) {
  if (!cb) cb = this.model._defaultCallback;
  this.model.emit('unfetchQuery', this, this.model._context);

  // No effect if the query is not currently fetched
  if (!this.fetchCount) {
    cb();
    return this;
  }

  var ids = this.fetchIds.shift() || [];
  for (var i = 0; i < ids.length; i++) {
    this.model.unfetchDoc(this.collectionName, ids[i]);
  }

  var query = this;
  if (this.model.unloadDelay) {
    setTimeout(finishUnfetchQuery, this.model.unloadDelay);
  } else {
    finishUnfetchQuery();
  }
  function finishUnfetchQuery() {
    var count = --query.fetchCount;
    if (count) return cb(null, count);
    // Cleanup when no fetches or subscribes remain
    if (!query.subscribeCount) query.destroy();
    cb(null, 0);
  }
  return this;
};

Query.prototype.unsubscribe = function(cb) {
  if (!cb) cb = this.model._defaultCallback;
  this.model.emit('unsubscribeQuery', this, this.model._context);

  // No effect if the query is not currently subscribed
  if (!this.subscribeCount) {
    cb();
    return this;
  }

  var query = this;
  if (this.model.unloadDelay) {
    setTimeout(finishUnsubscribeQuery, this.model.unloadDelay);
  } else {
    finishUnsubscribeQuery();
  }
  function finishUnsubscribeQuery() {
    var count = --query.subscribeCount;
    if (count) return cb(null, count);

    if (query.shareQuery) {
      var ids = resultsIds(query.shareQuery.results);
      query.shareQuery.destroy();
      query.shareQuery = null;
    }

    if (!query.model.fetchOnly && ids && ids.length) {
      // Unsubscribe all documents that this query currently has in results
      var group = util.asyncGroup(unsubscribeQueryCallback);
      for (var i = 0; i < ids.length; i++) {
        query.model.unsubscribeDoc(query.collectionName, ids[i], group());
      }
    }
    unsubscribeQueryCallback();
  }
  function unsubscribeQueryCallback(err) {
    if (err) return cb(err);
    // Cleanup when no fetches or subscribes remain
    if (!query.fetchCount) query.destroy();
    cb(null, 0);
  }
  return this;
};

Query.prototype._onInsert = function(shareDocs, index) {
  var ids = [];
  for (var i = 0; i < shareDocs.length; i++) {
    var id = shareDocs[i].name;
    ids.push(id);
    this.model.subscribeDoc(this.collectionName, id);
  }
  this.model._insert(this.idSegments, index, ids);
};
Query.prototype._onRemove = function(shareDocs, index) {
  this.model._remove(this.idSegments, index, shareDocs.length);
  for (var i = 0; i < shareDocs.length; i++) {
    this.model.unsubscribeDoc(this.collectionName, shareDocs[i].name);
  }
};
Query.prototype._onMove = function(shareDocs, from, to) {
  this.model._move(this.idSegments, from, to, shareDocs.length);
};

Query.prototype._onChange = function(ids, previousIds, cb) {
  // Diff the new and previous list of ids, subscribing to documents for
  // inserted ids and unsubscribing from documents for removed ids
  var diff = (previousIds) ?
    arrayDiff(previousIds, ids) :
    [new arrayDiff.InsertDiff(0, ids)];
  var previousCopy = previousIds && previousIds.slice();

  // The results are updated via a different diff, since they might already
  // have a value from a fetch or previous shareQuery instance
  this.model._setDiff(this.idSegments, ids);

  if (cb) {
    var group = util.asyncGroup(cb);
    var finished = group();
  }
  for (var i = 0; i < diff.length; i++) {
    var item = diff[i];
    if (item instanceof arrayDiff.InsertDiff) {
      // Subscribe to the document for each inserted id
      var values = item.values;
      for (var j = 0; j < values.length; j++) {
        this.model.subscribeDoc(this.collectionName, values[j], cb && group());
      }
    } else if (item instanceof arrayDiff.RemoveDiff) {
      var values = previousCopy.splice(item.index, item.howMany);
      // Unsubscribe from the document for each removed id
      for (var j = 0; j < values.length; j++) {
        this.model.unsubscribeDoc(this.collectionName, values[j], cb && group());
      }
    }
    // Moving doesn't change document subscriptions, so that is ignored.
  }
  // Make sure that the callback gets called if the diff is empty or it
  // contains no inserts or removes
  finished && finished();
};

Query.prototype.get = function() {
  var results = [];
  var data = this.model._get(this.segments);
  if (!data) {
    console.warn('You must fetch or subscribe to a query before getting its results.');
    return results;
  }
  var ids = data.ids;
  if (!ids) return results;

  var collection = this.model.getCollection(this.collectionName);
  for (var i = 0, l = ids.length; i < l; i++) {
    var id = ids[i];
    var doc = collection && collection.docs[id];
    results.push(doc && doc.get());
  }
  return (data.extra === void 0) ?
    results :
    {results: results, extra: data.extra};
};

/**
 * Lazily creates or gets a ref to our resultset's results.
 */
Query.prototype.ref = function(from) {
  var idsPath = this.idSegments.join('.');
  return this.model.refList(from, this.collectionName, idsPath);
};

/**
 * Lazily creates or gets a ref to our resultset's extra data.
 */
Query.prototype.extraRef = function(from, relPath) {
  var extraPath = this.extraSegments.join('.') + (relPath ? '.' + relPath : '');
  return this.model.ref(from, extraPath);
};

Query.prototype.serialize = function() {
  return [
    this.collectionName
  , this.expression
  , this.source
  , this.subscribeCount
  , this.fetchCount
  , this.fetchIds
  ];
};

function queryHash(collectionName, expression, source) {
  var args = [collectionName, expression, source];
  return JSON.stringify(args).replace(/\./g, '|');
}

function resultsIds(results) {
  var ids = [];
  for (var i = 0; i < results.length; i++) {
    var shareDoc = results[i];
    ids.push(shareDoc.name);
  }
  return ids;
}

function pathIds(model, segments) {
  var value = model._get(segments);
  return (typeof value === 'string') ? [value] :
    (Array.isArray(value)) ? value.slice() : [];
}

function collectionShareDocs(model, collectionName) {
  var collection = model.getCollection(collectionName);
  if (!collection) return;

  var results = [];
  for (var name in collection.docs) {
    results.push(collection.docs[name].shareDoc);
  }

  return results;
}


})(require("__browserify_process"))
},{"../util":7,"./index":8,"arraydiff":32,"deep-is":9,"__browserify_process":5}],28:[function(require,module,exports){
var sha = require('./sha')
var rng = require('./rng')
var md5 = require('./md5')

var algorithms = {
  sha1: {
    hex: sha.hex_sha1,
    binary: sha.b64_sha1,
    ascii: sha.str_sha1
  },
  md5: {
    hex: md5.hex_md5,
    binary: md5.b64_md5,
    ascii: md5.any_md5
  }
}

function error () {
  var m = [].slice.call(arguments).join(' ')
  throw new Error([
    m,
    'we accept pull requests',
    'http://github.com/dominictarr/crypto-browserify'
    ].join('\n'))
}

exports.createHash = function (alg) {
  alg = alg || 'sha1'
  if(!algorithms[alg])
    error('algorithm:', alg, 'is not yet supported')
  var s = ''
  var _alg = algorithms[alg]
  return {
    update: function (data) {
      s += data
      return this
    },
    digest: function (enc) {
      enc = enc || 'binary'
      var fn
      if(!(fn = _alg[enc]))
        error('encoding:', enc , 'is not yet supported for algorithm', alg)
      var r = fn(s)
      s = null //not meant to use the hash after you've called digest.
      return r
    }
  }
}

exports.randomBytes = function(size, callback) {
  if (callback && callback.call) {
    try {
      callback.call(this, undefined, rng(size));
    } catch (err) { callback(err); }
  } else {
    return rng(size);
  }
}

// the least I can do is make error messages for the rest of the node.js/crypto api.
;['createCredentials'
, 'createHmac'
, 'createCypher'
, 'createCypheriv'
, 'createDecipher'
, 'createDecipheriv'
, 'createSign'
, 'createVerify'
, 'createDeffieHellman'
, 'pbkdf2'].forEach(function (name) {
  exports[name] = function () {
    error('sorry,', name, 'is not implemented yet')
  }
})

},{"./sha":33,"./rng":34,"./md5":35}],32:[function(require,module,exports){
module.exports = arrayDiff;

// Based on some rough benchmarking, this algorithm is about O(2n) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

arrayDiff.InsertDiff = InsertDiff;
arrayDiff.RemoveDiff = RemoveDiff;
arrayDiff.MoveDiff = MoveDiff;

function InsertDiff(index, values) {
  this.index = index;
  this.values = values;
}
InsertDiff.prototype.type = 'insert';
InsertDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , index: this.index
  , values: this.values
  };
};

function RemoveDiff(index, howMany) {
  this.index = index;
  this.howMany = howMany;
}
RemoveDiff.prototype.type = 'remove';
RemoveDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , index: this.index
  , howMany: this.howMany
  };
};

function MoveDiff(from, to, howMany) {
  this.from = from;
  this.to = to;
  this.howMany = howMany;
}
MoveDiff.prototype.type = 'move';
MoveDiff.prototype.toJSON = function() {
  return {
    type: this.type
  , from: this.from
  , to: this.to
  , howMany: this.howMany
  };
};

function strictEqual(a, b) {
  return a === b;
}

function arrayDiff(before, after, equalFn) {
  if (!equalFn) equalFn = strictEqual;

  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  // 
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (!equalFn(beforeItem, after[afterIndex])) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var howMany = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        howMany++;
      } while (
        beforeIndex < beforeLength &&
        afterIndex < afterLength &&
        equalFn(before[beforeIndex], after[afterIndex]) &&
        !afterMarked[afterIndex]
      );
      moves.push(new MoveDiff(from, to, howMany));
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var howMany = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      howMany++;
    }
    removes.push(new RemoveDiff(index, howMany));
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var howMany = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      howMany++;
    }
    var values = after.slice(index, index + howMany);
    inserts.push(new InsertDiff(index, values));
  }

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.howMany;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.howMany;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var howMany = insert.values.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= howMany;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.howMany;
      if (earlier.to >= move.from) earlier.to += move.howMany;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.howMany;
      if (later.from >= move.to) later.from += move.howMany;
    }
  }

  return removes.concat(outputMoves, inserts);
}

},{}],33:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

exports.hex_sha1 = hex_sha1;
exports.b64_sha1 = b64_sha1;
exports.str_sha1 = str_sha1;
exports.hex_hmac_sha1 = hex_hmac_sha1;
exports.b64_hmac_sha1 = b64_hmac_sha1;
exports.str_hmac_sha1 = str_hmac_sha1;

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1("abc") == "a9993e364706816aba3e25717850c26c9cd0d89d";
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << (24 - len % 32);
  x[((len + 64 >> 9) << 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j < 80; j++)
    {
      if(j < 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t < 20) return (b & c) | ((~b) & d);
  if(t < 40) return b ^ c ^ d;
  if(t < 60) return (b & c) | (b & d) | (c & d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :
         (t < 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length > 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < str.length * chrsz; i += chrsz)
    bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = "";
  var mask = (1 << chrsz) - 1;
  for(var i = 0; i < bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i>>5] >>> (32 - chrsz - i%32)) & mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
           hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var str = "";
  for(var i = 0; i < binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   >> 2] >> 8 * (3 -  i   %4)) & 0xFF) << 16)
                | (((binarray[i+1 >> 2] >> 8 * (3 - (i+1)%4)) & 0xFF) << 8 )
                |  ((binarray[i+2 >> 2] >> 8 * (3 - (i+2)%4)) & 0xFF);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet >> 6*(3-j)) & 0x3F);
    }
  }
  return str;
}


},{}],34:[function(require,module,exports){
// Original code adapted from Robert Kieffer.
// details at https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  var mathRNG, whatwgRNG;

  // NOTE: Math.random() does not guarantee "cryptographic quality"
  mathRNG = function(size) {
    var bytes = new Array(size);
    var r;

    for (var i = 0, r; i < size; i++) {
      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;
      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return bytes;
  }

  // currently only available in webkit-based browsers.
  if (_global.crypto && crypto.getRandomValues) {
    var _rnds = new Uint32Array(4);
    whatwgRNG = function(size) {
      var bytes = new Array(size);
      crypto.getRandomValues(_rnds);

      for (var c = 0 ; c < size; c++) {
        bytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;
      }
      return bytes;
    }
  }

  module.exports = whatwgRNG || mathRNG;

}())
},{}],35:[function(require,module,exports){
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}


exports.hex_md5 = hex_md5;
exports.b64_md5 = b64_md5;
exports.any_md5 = any_md5;

},{}],31:[function(require,module,exports){

exports.Connection = require('./connection').Connection;
exports.Doc = require('./doc').Doc;

},{"./connection":36,"./doc":37}],38:[function(require,module,exports){
// This is a simple rewrite of microevent.js. I've changed the
// function names to be consistent with node.js EventEmitter.
//
// microevent.js is copyright Jerome Etienne, and licensed under the MIT license:
// https://github.com/jeromeetienne/microevent.js

var MicroEvent = function() {};

MicroEvent.prototype.on = function(event, fn) {
  var events = this._events = this._events || {};
  (events[event] = events[event] || []).push(fn);
};

MicroEvent.prototype.removeListener = function(event, fn) {
  var events = this._events = this._events || {};
  var listeners = events[event] = events[event] || [];

  // Sadly, no IE8 support for indexOf.
  var i = 0;
  while (i < listeners.length) {
    if (listeners[i] === fn) {
      listeners[i] = undefined;
    }
    i++;
  }

  // Compact the list when no event handler is actually running.
  setTimeout(function() {
    events[event] = [];
    var fn;
    for (var i = 0; i < listeners.length; i++) {
      // Only add back event handlers which exist.
      if ((fn = listeners[i])) events[event].push(fn);
    }
  }, 0);
};

MicroEvent.prototype.emit = function(event) {
  var events = this._events;
  var args = Array.prototype.splice.call(arguments, 1);

  if (!events || !events[event]) {
    if (event == 'error') {
      if (console) {
        console.error.apply(console, args);
      }
    }
    return;
  }

  var listeners = events[event];
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i]) {
      listeners[i].apply(this, args);
    }
  }
};

MicroEvent.prototype.once = function(event, fn) {
  var listener, _this = this;
  this.on(event, listener = function() {
    _this.removeListener(event, listener);
    fn.apply(_this, arguments);
  });
};

MicroEvent.mixin = function(obj) {
  var proto = obj.prototype || obj;
  proto.on = MicroEvent.prototype.on;
  proto.removeListener = MicroEvent.prototype.removeListener;
  proto.emit = MicroEvent.prototype.emit;
  proto.once = MicroEvent.prototype.once;
  return obj;
};

if (typeof module !== "undefined") module.exports = MicroEvent;


},{}],39:[function(require,module,exports){
var Doc;
if (typeof require !== 'undefined') {
  Doc = require('./doc').Doc;
}

// Queries are live requests to the database for particular sets of fields.
//
// The server actively tells the client when there's new data that matches
// a set of conditions.
var Query = exports.Query = function(type, connection, id, collection, query, options, callback) {
  // 'fetch' or 'sub'
  this.type = type;

  this.connection = connection;
  this.id = id;
  this.collection = collection;

  // The query itself. For mongo, this should look something like {"data.x":5}
  this.query = query;

  // Resultant document action for the server. Fetch mode will automatically
  // fetch all results. Subscribe mode will automatically subscribe all
  // results. Results are never unsubscribed.
  this.docMode = options.docMode; // undefined, 'fetch' or 'sub'.
  if (this.docMode === 'subscribe') this.docMode = 'sub';

  // Do we repoll the entire query whenever anything changes? (As opposed to
  // just polling the changed item). This needs to be enabled to be able to use
  // ordered queries (sortby:) and paginated queries. Set to undefined, it will
  // be enabled / disabled automatically based on the query's properties.
  this.poll = options.poll;

  // The backend we actually hit. If this isn't defined, it hits the snapshot
  // database. Otherwise this can be used to hit another configured query
  // index.
  this.backend = options.backend || options.source;

  // A list of resulting documents. These are actual documents, complete with
  // data and all the rest. If fetch is false, these documents will not
  // have any data. You should manually call fetch() or subscribe() on them.
  //
  // Calling subscribe() might be a good idea anyway, as you won't be
  // subscribed to the documents by default.
  this.knownDocs = options.knownDocs || [];
  this.results = [];

  // Do we have some initial data?
  this.ready = false;

  this.callback = callback;
};
Query.prototype.action = 'qsub';

// Helper for subscribe & fetch, since they share the same message format.
//
// This function actually issues the query.
Query.prototype._execute = function() {
  if (!this.connection.canSend) return;

  if (this.docMode) {
    var collectionVersions = {};
    // Collect the version of all the documents in the current result set so we
    // don't need to be sent their snapshots again.
    for (var i = 0; i < this.knownDocs.length; i++) {
      var doc = this.knownDocs[i];
      var c = collectionVersions[doc.collection] = collectionVersions[doc.collection] || {};
      c[doc.name] = doc.version;
    }
  }

  var msg = {
    a: 'q' + this.type,
    id: this.id,
    c: this.collection,
    o: {},
    q: this.query,
  };

  if (this.docMode) {
    msg.o.m = this.docMode;
    // This should be omitted if empty, but whatever.
    msg.o.vs = collectionVersions;
  }
  if (this.backend != null) msg.o.b = this.backend;
  if (this.poll !== undefined) msg.o.p = this.poll;

  this.connection.send(msg);
};

// Make a list of documents from the list of server-returned data objects
Query.prototype._dataToDocs = function(data) {
  var results = [];
  var lastType;
  for (var i = 0; i < data.length; i++) {
    var docData = data[i];

    // Types are only put in for the first result in the set and every time the type changes in the list.
    if (docData.type) {
      lastType = docData.type;
    } else {
      docData.type = lastType;
    }

    var doc = this.connection.getOrCreate(docData.c || this.collection, docData.d, docData);
    // Force the document to know its subscribed if we're in docmode:subscribe.
    if (this.docMode === 'sub') {
      doc.subscribed = true; // Set before setWantSubscribe() so flush doesn't send a subscribe request.
      doc._setWantSubscribe(true); // this will call any subscribe callbacks or whatever.
      doc.emit('subscribe');
      doc._finishSub(true); // this doesn't actually do anything here, but its more correct to have it.
    }
    results.push(doc);
  }
  return results;
};

// Destroy the query object. Any subsequent messages for the query will be
// ignored by the connection. You should unsubscribe from the query before
// destroying it.
Query.prototype.destroy = function() {
  if (this.connection.canSend && this.type === 'sub') {
    this.connection.send({a:'qunsub', id:this.id});
  }

  this.connection._destroyQuery(this);
};

Query.prototype._onConnectionStateChanged = function(state, reason) {
  if (this.connection.state === 'connecting') {
    this._execute();
  }
};

// Internal method called from connection to pass server messages to the query.
Query.prototype._onMessage = function(msg) {
  if ((msg.a === 'qfetch') !== (this.type === 'fetch')) {
    if (console) console.warn('Invalid message sent to query', msg, this);
    return;
  }

  if (msg.error) this.emit('error', msg.error);

  switch (msg.a) {
    case 'qfetch':
      var results = msg.data ? this._dataToDocs(msg.data) : undefined;
      if (this.callback) this.callback(msg.error, results, msg.extra);
      // Once a fetch query gets its data, it is destroyed.
      this.connection._destroyQuery(this);
      break;

    case 'q':
      // Query diff data (inserts and removes)
      if (msg.diff) {
        // We need to go through the list twice. First, we'll injest all the
        // new documents and set them as subscribed.  After that we'll emit
        // events and actually update our list. This avoids race conditions
        // around setting documents to be subscribed & unsubscribing documents
        // in event callbacks.
        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          if (d.type === 'insert') d.values = this._dataToDocs(d.values);
        }

        for (var i = 0; i < msg.diff.length; i++) {
          var d = msg.diff[i];
          switch (d.type) {
            case 'insert':
              var newDocs = d.values;
              Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));
              this.emit('insert', newDocs, d.index);
              break;
            case 'remove':
              var howMany = d.howMany || 1;
              var removed = this.results.splice(d.index, howMany);
              this.emit('remove', removed, d.index);
              break;
            case 'move':
              var howMany = d.howMany || 1;
              var docs = this.results.splice(d.from, howMany);
              Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));
              this.emit('move', docs, d.from, d.to);
              break;
          }
        }
      }

      if (msg.extra) {
        this.emit('extra', msg.extra);
      }
      break;
    case 'qsub':
      // This message replaces the entire result set with the set passed.
      if (!msg.error) {
        var previous = this.results;

        // Then add everything in the new result set.
        this.results = this.knownDocs = this._dataToDocs(msg.data);
        this.extra = msg.extra;

        this.ready = true;
        this.emit('change', this.results, previous);
      }
      if (this.callback) {
        this.callback(msg.error, this.results, this.extra);
        delete this.callback;
      }
      break;
  }
};

// Change the thing we're searching for. This isn't fully supported on the
// backend (it destroys the old query and makes a new one) - but its
// programatically useful and I might add backend support at some point.
Query.prototype.setQuery = function(q) {
  if (this.type !== 'sub') throw new Error('cannot change a fetch query');

  this.query = q;
  if (this.connection.canSend) {
    // There's no 'change' message to send to the server. Just resubscribe.
    this.connection.send({a:'qunsub', id:this.id});
    this._execute();
  }
};

var MicroEvent;
if (typeof require !== 'undefined') {
  MicroEvent = require('./microevent');
}

MicroEvent.mixin(Query);


},{"./microevent":38,"./doc":37}],36:[function(require,module,exports){
// A Connection wraps a persistant BC connection to a sharejs server.
//
// This class implements the client side of the protocol defined here:
// https://github.com/josephg/ShareJS/wiki/Wire-Protocol
//
// The equivalent server code is in src/server/session.
//
// This file is a bit of a mess. I'm dreadfully sorry about that. It passes all the tests,
// so I have hope that its *correct* even if its not clean.
//
// To make a connection, use:
//  new sharejs.Connection(socket)
//
// The socket should look like a websocket connection. It should have the following properties:
//  send(msg): Send the given message. msg may be an object - if so, you might need to JSON.stringify it.
//  close(): Disconnect the session
//
//  onmessage = function(msg){}: Event handler which is called whenever a message is received. The message
//     passed in should already be an object. (It may need to be JSON.parsed)
//  onclose
//  onerror
//  onopen
//  onconnecting
//
// The socket should probably automatically reconnect. If so, it should emit the appropriate events as it
// disconnects & reconnects. (onclose(), onconnecting(), onopen()).

var types, Doc;
if (typeof require !== 'undefined') {
  types = require('ottypes');
  Doc = require('./doc').Doc;
  Query = require('./query').Query;
} else {
  types = window.ottypes;
  Doc = exports.Doc;
}

var Connection = exports.Connection = function (socket) {
  this.socket = socket;

  // Map of collection -> docName -> doc object for created documents.
  // (created documents MUST BE UNIQUE)
  this.collections = {};

  // Each query is created with an id that the server uses when it sends us
  // info about the query (updates, etc).
  //this.nextQueryId = (Math.random() * 1000) |0;
  this.nextQueryId = 1;

  // Map from query ID -> query object.
  this.queries = {};

  // Connection state.
  // 
  // States:
  // - 'connecting': The connection has been established, but we don't have our client ID yet
  // - 'connected': We have connected and recieved our client ID. Ready for data.
  // - 'disconnected': The connection is closed, but it will reconnect automatically.
  // - 'stopped': The connection is closed, and should not reconnect.
  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';

  // This is a helper variable the document uses to see whether we're currently
  // in a 'live' state. It is true if the state is 'connecting' or 'connected'.
  this.canSend = this.state === 'connecting';

  // Reset some more state variables.
  this.reset();

  this.debug = false;

  var connection = this;

  // Attach event handlers to the socket.
  socket.onmessage = function(msg) {
    if (connection.debug) console.log('RECV', JSON.stringify(msg));

    // Switch on the message action. Most messages are for documents and are
    // handled in the doc class.
    switch (msg.a) {
      case 'init':
        // Client initialization packet. This bundle of joy contains our client
        // ID.
        if (msg.protocol !== 0) throw new Error('Invalid protocol version');
        if (typeof msg.id != 'string') throw new Error('Invalid client id');

        connection.id = msg.id;
        connection._setState('connected');
        break;

      case 'qfetch':
      case 'qsub':
      case 'q':
      case 'qunsub':
        // Query message. Pass this to the appropriate query object.
        var query = connection.queries[msg.id];
        if (query) query._onMessage(msg);
        break;

      default:
        // Document message. Pull out the referenced document and forward the
        // message.
        var collection, docName, doc;
        if (msg.d) {
          collection = this._lastReceivedCollection = msg.c;
          docName = this._lastReceivedDoc = msg.d;
        } else {
          collection = msg.c = this._lastReceivedCollection;
          docName = msg.d = this._lastReceivedDoc;
        }

        doc = connection.get(collection, docName);
        if (!doc) {
          if (console) console.error('Message for unknown doc. Ignoring.', msg);
          break;
        }
        doc._onMessage(msg);
    }
  };

  socket.onopen = function() {
    connection._setState('connecting');
  };

  socket.onerror = function(e) {
    // This isn't the same as a regular error, because it will happen normally
    // from time to time. Your connection should probably automatically
    // reconnect anyway, but that should be triggered off onclose not onerror.
    // (onclose happens when onerror gets called anyway).
    connection.emit('connection error', e);
  };

  socket.onclose = function(reason) {
    connection._setState('disconnected', reason);
    if (reason === 'Closed' || reason === 'Stopped by server') {
      connection._setState('stopped', reason);
    }
  };
}

/* Why does this function exist? Is it important?
Connection.prototype._error = function(e) {
  this._setState('stopped', e);
  return this.disconnect(e);
};
*/

Connection.prototype.reset = function() {
  this.id = this.lastError =
    this._lastReceivedCollection = this._lastReceivedDoc =
    this._lastSentCollection = this._lastSentDoc = null;

  this.seq = 1;
};

// Set the connection's state. The connection is basically a state machine.
Connection.prototype._setState = function(newState, data) {
  if (this.state === newState) return;

  // I made a state diagram. The only invalid transitions are getting to
  // 'connecting' from anywhere other than 'disconnected' and getting to
  // 'connected' from anywhere other than 'connecting'.
  if ((newState === 'connecting' && (this.state !== 'disconnected' && this.state !== 'stopped'))
      || (newState === 'connected' && this.state !== 'connecting')) {
    throw new Error("Cannot transition directly from " + this.state + " to " + newState);
  }

  this.state = newState;
  this.canSend = newState === 'connecting' || newState === 'connected';

  if (newState === 'disconnected') this.reset();

  this.emit(newState, data);

  // & Emit the event to all documents & queries. It might make sense for
  // documents to just register for this stuff using events, but that couples
  // connections and documents a bit much. Its not a big deal either way.
  this.opQueue = [];
  for (var c in this.collections) {
    var collection = this.collections[c];
    for (var docName in collection) {
      collection[docName]._onConnectionStateChanged(newState, data);
    }
  }

  this.opQueue.sort(function(a, b) { return a.seq - b.seq; });
  for (var i = 0; i < this.opQueue.length; i++) {
    this.send(this.opQueue[i]);
  }
  this.opQueue = null;
  
  for (var id in this.queries) {
    this.queries[id]._onConnectionStateChanged(newState, data);
  }
};

// So, there's an awful error case where the client sends two requests (which
// fail), then reconnects. The documents could have _onConnectionStateChanged
// called in the wrong order and the operations then get sent with reversed
// sequence numbers. This causes the server to incorrectly reject the second
// sent op. So we need to queue the operations while we're reconnecting and
// resend them in the correct order.
Connection.prototype.sendOp = function(data) {
  if (this.opQueue) {
    this.opQueue.push(data);
  } else {
    this.send(data);
  }
};

// Send a message to the connection.
Connection.prototype.send = function(msg) {
  if (this.debug) console.log("SEND", JSON.stringify(msg));

  if (msg.d) { // The document the message refers to. Not set for queries.
    var collection = msg.c;
    var docName = msg.d;
    if (collection === this._lastSentCollection && docName === this._lastSentDoc) {
      delete msg.c;
      delete msg.d;
    } else {
      this._lastSentCollection = collection;
      this._lastSentDoc = docName;
    }
  }

  this.socket.send(msg);
};

Connection.prototype.disconnect = function() {
  // This will call @socket.onclose(), which in turn will emit the 'disconnected' event.
  this.socket.close();
};


// ***** Document management

Connection.prototype.get = function(collection, name) {
  if (this.collections[collection]) return this.collections[collection][name];
};

// Create a document if it doesn't exist. Returns the document synchronously.
Connection.prototype.getOrCreate = function(collection, name, data) {
  var doc = this.get(collection, name);

  if (!doc) {
    // Create it.
    doc = new Doc(this, collection, name);

    var collectionObject = this.collections[collection] =
      (this.collections[collection] || {});
    collectionObject[name] = doc;
  }

  // Even if the document isn't new, its possible the document was created
  // manually and then tried to be re-created with data (suppose a query
  // returns with data for the document). We should hydrate the document
  // immediately if we can because the query callback will expect the document
  // to have data.
  if (data && data.snapshot !== undefined && !doc.state) {
    doc.injestData(data);
  }

  return doc;
};

// Call doc.destroy()
Connection.prototype._destroyDoc = function(doc) {
  var collectionObject = this.collections[doc.collection];
  if (!collectionObject) return;

  delete collectionObject[doc.name];

  // Delete the collection container if its empty. This could be a source of
  // memory leaks if you slowly make a billion collections, which you probably
  // won't do anyway, but whatever.
  if (!hasKeys(collectionObject))
    delete this.collections[doc.collection];
};
 
function hasKeys(object) {
  for (var key in object) return true;
  return false;
};

// **** Queries.

// Helper for createFetchQuery and createSubscribeQuery, below.
Connection.prototype._createQuery = function(type, collection, q, options, callback) {
  if (type !== 'fetch' && type !== 'sub')
    throw new Error('Invalid query type: ' + type);

  if (!options) options = {};
  var id = this.nextQueryId++;
  var query = new Query(type, this, id, collection, q, options, callback);
  this.queries[id] = query;
  query._execute();
  return query;
};

// Internal function. Use query.destroy() to remove queries.
Connection.prototype._destroyQuery = function(query) {
  delete this.queries[query.id];
};

// The query options object can contain the following fields:
//
// docMode: What to do with documents that are in the result set. Can be
//   null/undefined (default), 'fetch' or 'subscribe'. Fetch mode indicates
//   that the server should send document snapshots to the client for all query
//   results. These will be hydrated into the document objects before the query
//   result callbacks are returned. Subscribe mode gets document snapshots and
//   automatically subscribes the client to all results. Note that the
//   documents *WILL NOT* be automatically unsubscribed when the query is
//   destroyed. (ShareJS doesn't have enough information to do that safely).
//   Beware of memory leaks when using this option.
//
// poll: Forcably enable or disable polling mode. Polling mode will reissue the query
//   every time anything in the collection changes (!!) so, its quite
//   expensive.  It is automatically enabled for paginated and sorted queries.
//   By default queries run with polling mode disabled; which will only check
//   changed documents to test if they now match the specified query.
//   Set to false to disable polling mode, or true to enable it. If you don't
//   specify a poll option, polling mode is enabled or disabled automatically
//   by the query's backend.
//
// backend: Set the backend source for the query. You can attach different
//   query backends to livedb and pick which one the query should hit using
//   this parameter.
//
// results: (experimental) Initial list of resultant documents. This is
//   useful for rehydrating queries when you're using autoFetch / autoSubscribe
//   so the server doesn't have to send over snapshots for documents the client
//   already knows about. This is experimental - the API may change in upcoming
//   versions.

// Create a fetch query. Fetch queries are only issued once, returning the
// results directly into the callback.
//
// The index is specific to the source, but if you're using mongodb it'll be
// the collection to which the query is made.
// The callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createFetchQuery = function(index, q, options, callback) {
  return this._createQuery('fetch', index, q, options, callback);
};

// Create a subscribe query. Subscribe queries return with the initial data
// through the callback, then update themselves whenever the query result set
// changes via their own event emitter.
//
// If present, the callback should have the signature function(error, results, extraData)
// where results is a list of Doc objects.
Connection.prototype.createSubscribeQuery = function(index, q, options, callback) {
  return this._createQuery('sub', index, q, options, callback);
};

if (typeof require !== 'undefined') {
  MicroEvent = require('./microevent');
}

MicroEvent.mixin(Connection);


},{"./doc":37,"./query":39,"./microevent":38,"ottypes":40}],37:[function(require,module,exports){
var types, MicroEvent;

if (typeof require !== "undefined") {
  types = require('ottypes');
  MicroEvent = require('./microevent');
} else {
  types = window.ottypes;
}

/*
 * A Doc is a client's view on a sharejs document.
 *
 * Documents should not be created directly. Create them by calling the
 * document getting functions in connection.
 *
 * Documents are event emitters. Use doc.on(eventname, fn) to subscribe.
 *
 * Documents currently get mixed in with their type's API methods. So, you can
 * .insert('foo', 0) into a text document and stuff like that.
 *
 * Events:
 * - before op (op, localSite): Fired before an operation is applied to the
 *   document.
 * - op (op, localSite): Fired right after an operation (or part of an
 *   operation) has been applied to the document. Submitting another op here is
 *   invalid - wait until 'after op' if you want to submit more operations.  -
 *   changed (op)
 * - after op (op, localSite): Fired after an operation has been applied. You
 *   can submit more ops here.
 * - subscribed (error): The document was subscribed
 * - unsubscribed (error): The document was unsubscribed
 * - created: The document was created. That means its type was set and it has
 *   some initial data.
 * - error
 */
var Doc = exports.Doc = function(connection, collection, name) {
  this.connection = connection;

  this.collection = collection;
  this.name = name;

  this.version = this.type = null;

  // **** State in document:
 
  // Action. This is either null, or one of the actions (subscribe,
  // unsubscribe, fetch, submit). Only one action can be happening at a time to
  // prevent me from going mad.
  //
  // Possible values:
  // - subscribe
  // - unsubscribe
  // - fetch
  // - submit
  this.action = null;
 
  // The data the document object stores can be in one of the following three states:
  //   - No data. (null) We honestly don't know whats going on.
  //   - Floating ('floating'): we have a locally created document that hasn't
  //     been created on the server yet)
  //   - Live ('ready') (we have data thats current on the server at some version).
  this.state = null;

  // Our subscription status. Either we're subscribed on the server, or we aren't.
  this.subscribed = false;
  // Either we want to be subscribed (true), we want a new snapshot from the
  // server ('fetch'), or we don't care (false).  This is also used when we
  // disconnect & reconnect to decide what to do.
  this.wantSubscribe = false;
  // This list is used for subscribe and unsubscribe, since we'll only want to
  // do one thing at a time.
  this._subscribeCallbacks = [];


  // *** end state stuff.

  // This doesn't provide any standard API access right now.
  this.provides = {};

  // The editing contexts. These are usually instances of the type API when the
  // document is ready for edits.
  this.editingContexts = [];
  
  // The op that is currently roundtripping to the server, or null.
  //
  // When the connection reconnects, the inflight op is resubmitted.
  //
  // This has the same format as an entry in pendingData, which is:
  // {[create:{...}], [del:true], [op:...], callbacks:[...], src:, seq:}
  this.inflightData = null;

  // All ops that are waiting for the server to acknowledge @inflightData
  // This used to just be a single operation, but creates & deletes can't be composed with
  // regular operations.
  //
  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}
  this.pendingData = [];
};

MicroEvent.mixin(Doc);

Doc.prototype.destroy = function(callback) {
  var doc = this;
  this.unsubscribe(function() {
    // Don't care if there's an error unsubscribing.

    setTimeout(function() {
      // There'll probably be nothing here seeing as how we just unsubscribed.
      for (var i = 0; i < doc._subscribeCallbacks.length; i++) {
        doc._subscribeCallbacks[i]('Document destroyed');
      }
      doc._subscribeCallbacks.length = 0;
    }, 0);

    doc.connection._destroyDoc(doc);
    doc.removeContexts();
    if (callback) callback();
  });
};


// ****** Manipulating the document snapshot, version and type.

// Set the document's type, and associated properties. Most of the logic in
// this function exists to update the document based on any added & removed API
// methods.
Doc.prototype._setType = function(newType) {
  if (typeof newType === 'string') {
    if (!types[newType]) throw new Error("Missing type " + newType);
    newType = types[newType];
  }
  this.removeContexts();

  // Set the new type
  this.type = newType;

  // If we removed the type from the object, also remove its snapshot.
  if (!newType) {
    this.provides = {};
  } else if (newType.api) {
    // Register the new type's API.
    this.provides = newType.api.provides;
  }
};

// Injest snapshot data. This data must include a version, snapshot and type.
// This is used both to injest data that was exported with a webpage and data
// that was received from the server during a fetch.
Doc.prototype.injestData = function(data) {
  if (this.state) {
    if (typeof console !== "undefined") console.warn('Ignoring attempt to injest data in state', this.state);
    return;
  }
  if (typeof data.v !== 'number') throw new Error('Missing version in injested data');


  this.version = data.v;
  this.snapshot = data.snapshot;
  this._setType(data.type);

  this.state = 'ready';
  this.emit('ready');
};

// Get and return the current document snapshot.
Doc.prototype.getSnapshot = function() {
  return this.snapshot;
};

// The callback will be called at a time when the document has a snapshot and
// you can start applying operations. This may be immediately.
Doc.prototype.whenReady = function(fn) {
  if (this.state === 'ready') {
    fn();
  } else {
    this.on('ready', fn);
  }
};

Doc.prototype.hasPending = function() {
  return this.inflightData != null || !!this.pendingData.length;
};


// **** Helpers for network messages

// Send a message to the connection from this document.
Doc.prototype._send = function(message) {
  message.c = this.collection;
  message.d = this.name;
  this.connection.send(message);
};

// This is called by the connection when it receives a message for the document.
Doc.prototype._onMessage = function(msg) {
  if (!(msg.c === this.collection && msg.d === this.name)) {
    // This should never happen - its a sanity check for bugs in the connection code.
    throw new Error("Got message for wrong document.");
  }

  // msg.a = the action.
  switch (msg.a) {
    case 'fetch':
      // We're done fetching. This message has no other information.
      if (msg.data) this.injestData(msg.data);
      this._finishSub('fetch', msg.error);
      if (this.wantSubscribe === 'fetch') this.wantSubscribe = false;
      this._clearAction('fetch');
      break;

    case 'sub':
      // Subscribe reply.
      if (msg.error && msg.error !== 'Already subscribed') {
        if (console) console.error("Could not subscribe: " + msg.error);
        this.emit('error', msg.error);
        // There's probably a reason we couldn't subscribe. Don't retry.
        this._setWantSubscribe(false, null, msg.error)
      } else {
        if (msg.data) this.injestData(msg.data);
        this.subscribed = true;
        this.emit('subscribe');
        this._finishSub(true);
      }

      this._clearAction('subscribe');
      break;

    case 'unsub':
      // Unsubscribe reply
      this.subscribed = false;
      this.emit('unsubscribe');

      this._finishSub(false, msg.error);
      this._clearAction('unsubscribe');
      break;

    case 'ack':
      // Acknowledge a locally submitted operation.
      //
      // Usually we do nothing here - all the interesting logic happens when we
      // get sent our op back in the op stream (which happens even if we aren't
      // subscribed). However, if the op doesn't get accepted, we still need to
      // clear some state.
      //
      // If the message error is 'Op already submitted', that means we've
      // resent an op that the server already got. It will also be confirmed
      // normally.
      if (msg.error && msg.error !== 'Op already submitted') {
        // The server has rejected an op from the client for some reason.
        // We'll send the error message to the user and try to roll back the change.
        if (this.inflightData) {
          this._tryRollback(this.inflightData);
        } else {
          // I managed to get into this state once. I'm not sure how it happened.
          // The op was maybe double-acknowledged?
          if (console) console.warn('Second acknowledgement message (error) received', msg, this);
        }
          
        this._clearInflightOp(msg.error);
      }
      break;

    case 'op':
      if (this.inflightData &&
          msg.src === this.inflightData.src &&
          msg.seq === this.inflightData.seq) {
        // This one is mine. Accept it as acknowledged.
        this._opAcknowledged(msg);
        break;
      }

      if (msg.v !== this.version) {
        this.emit('error', "Expected version " + this.version + " but got " + msg.v);
        break;
      }

      if (this.inflightData) xf(this.inflightData, msg);

      for (var i = 0; i < this.pendingData.length; i++) {
        xf(this.pendingData[i], msg);
      }

      this.version++;
      this._otApply(msg, false);
      this._afterOtApply(msg, false);
      //console.log('applied', JSON.stringify(msg));
      break;

    case 'meta':
      if (console) console.warn('Unhandled meta op:', msg);
      break;

    default:
      if (console) console.warn('Unhandled document message:', msg);
      break;
  }
};

// Called whenever (you guessed it!) the connection state changes. This will
// happen when we get disconnected & reconnect.
Doc.prototype._onConnectionStateChanged = function(state, reason) {
  if (state === 'connecting') {
    if (this.inflightData) {
      this._sendOpData();
    } else {
      this.flush();
    }
  } else if (state === 'connected') {
    // We go into the connected state once we have a sessionID. We can't send
    // new ops until then, so we need to flush again.
    this.flush();
  } else if (state === 'disconnected') {
    this.action = null;
    this.subscribed = false;
    if (this.subscribed) this.emit('unsubscribed');
  }
};




// ****** Dealing with actions

Doc.prototype._clearAction = function(expectedAction) {
  if (this.action !== expectedAction) {
    console.warn('Unexpected action ' + this.action + ' expected: ' + expectedAction);
  }
  this.action = null;
  this.flush();
};



// Send the next pending op to the server, if we can.
//
// Only one operation can be in-flight at a time. If an operation is already on
// its way, or we're not currently connected, this method does nothing.
Doc.prototype.flush = function() {
  if (!this.connection.canSend || this.action) return;

  var opData;
  // Pump and dump any no-ops from the front of the pending op list.
  while (this.pendingData.length && isNoOp(opData = this.pendingData[0])) {
    var callbacks = opData.callbacks;
    for (var i = 0; i < callbacks.length; i++) {
      callbacks[i](opData.error);
    }
    this.pendingData.shift();
  }

  // First consider changing state
  if (this.subscribed && !this.wantSubscribe) {
    this.action = 'unsubscribe';
    this._send({a:'unsub'});
  } else if (!this.subscribed && this.wantSubscribe === 'fetch') {
    this.action = 'fetch';
    this._send(this.state === 'ready' ? {a:'fetch', v:this.version} : {a:'fetch'});
  } else if (!this.subscribed && this.wantSubscribe) {
    this.action = 'subscribe';
    this._send(this.state === 'ready' ? {a:'sub', v:this.version} : {a:'sub'});
  } else if (!this.paused && this.pendingData.length && this.connection.state === 'connected') {
    // Try and send any pending ops. We can't send ops while in 
    this.inflightData = this.pendingData.shift();

    // Delay for debugging.
    //var that = this;
    //setTimeout(function() { that._sendOpData(); }, 1000);

    // This also sets action to 'submit'.
    this._sendOpData();
  }
};


// ****** Subscribing, unsubscribing and fetching

// These functions iare copied into the query class as well, so be careful making
// changes here.

// Value is true, false or 'fetch'.
Doc.prototype._setWantSubscribe = function(value, callback, err) {
  if (this.subscribed === this.wantSubscribe &&
      (this.subscribed === value || value === 'fetch' && this.subscribed)) {
    if (callback) callback(err);
    return;
  }
  
  if (!this.wantSubscribe !== !value) {
    // Call all the current subscribe/unsubscribe callbacks.
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      // Should I return an error here? What happened is the user unsubcribed
      // with a callback then resubscribed straight after. Does that mean the
      // unsubscribe failed?
      this._subscribeCallbacks[i](err);
    }
    this._subscribeCallbacks.length = 0;
  }

  // If we want to subscribe, don't weaken it to a fetch.
  if (value !== 'fetch' || this.wantSubscribe !== true)
    this.wantSubscribe = value;

  if (callback) this._subscribeCallbacks.push(callback);
  this.flush();
};

// Open the document. There is no callback and no error handling if you're
// already connected.
//
// Only call this once per document.
Doc.prototype.subscribe = function(callback) {
  this._setWantSubscribe(true, callback);
};

Doc.prototype.unsubscribe = function(callback) {
  this._setWantSubscribe(false, callback);
};

// Call to request fresh data from the server.
Doc.prototype.fetch = function(callback) {
  this._setWantSubscribe('fetch', callback);
};

// Called when our subscribe, fetch or unsubscribe messages are acknowledged.
Doc.prototype._finishSub = function(value, error) {
  if (value === this.wantSubscribe) {
    for (var i = 0; i < this._subscribeCallbacks.length; i++) {
      this._subscribeCallbacks[i](error);
    }
    this._subscribeCallbacks.length = 0;
  }
};


// Operations


// ************ Dealing with operations.

// Helper function to set opData to contain a no-op.
var setNoOp = function(opData) {
  delete opData.op;
  delete opData.create;
  delete opData.del;
};

var isNoOp = function(opData) {
  return !opData.op && !opData.create && !opData.del;
}

// Try to compose data2 into data1. Returns truthy if it succeeds, otherwise falsy.
var tryCompose = function(type, data1, data2) {
  if (data1.create && data2.del) {
    setNoOp(data1);
  } else if (data1.create && data2.op) {
    // Compose the data into the create data.
    var data = (data1.create.data === undefined) ? type.create() : data1.create.data;
    data1.create.data = type.apply(data, data2.op);
  } else if (isNoOp(data1)) {
    data1.create = data2.create;
    data1.del = data2.del;
    data1.op = data2.op;
  } else if (data1.op && data2.op && type.compose) {
    data1.op = type.compose(data1.op, data2.op);
  } else {
    return false;
  }
  return true;
};

// Transform server op data by a client op, and vice versa. Ops are edited in place.
var xf = function(client, server) {
  // In this case, we're in for some fun. There are some local operations
  // which are totally invalid - either the client continued editing a
  // document that someone else deleted or a document was created both on the
  // client and on the server. In either case, the local document is way
  // invalid and the client's ops are useless.
  //
  // The client becomes a no-op, and we keep the server op entirely.
  if (server.create || server.del) return setNoOp(client);
  if (client.create) throw new Error('Invalid state. This is a bug.');

  // The client has deleted the document while the server edited it. Kill the
  // server's op.
  if (client.del) return setNoOp(server);

  // We only get here if either the server or client ops are no-op. Carry on,
  // nothing to see here.
  if (!server.op || !client.op) return;

  // They both edited the document. This is the normal case for this function -
  // as in, most of the time we'll end up down here.
  //
  // You should be wondering why I'm using client.type instead of this.type.
  // The reason is, if we get ops at an old version of the document, this.type
  // might be undefined or a totally different type. By pinning the type to the
  // op data, we make sure the right type has its transform function called.
  if (client.type.transformX) {
    var result = client.type.transformX(client.op, server.op);
    client.op = result[0];
    server.op = result[1];
  } else {
    //console.log('xf', JSON.stringify(client.op), JSON.stringify(server.op));
    var _c = client.type.transform(client.op, server.op, 'left');
    var _s = client.type.transform(server.op, client.op, 'right');
    client.op = _c; server.op = _s;
    //console.log('->', JSON.stringify(client.op), JSON.stringify(server.op));
  }
};

// Internal method to actually apply the given op data to our local model.
//
// _afterOtApply() should always be called synchronously afterwards.
Doc.prototype._otApply = function(opData, context) {
  // Lock the document. Nobody is allowed to call submitOp() until _afterOtApply is called.
  this.locked = true;

  if (opData.create) {
    // If the type is currently set, it means we tried creating the document
    // and someone else won. client create x server create = server create.
    var create = opData.create;
    this._setType(create.type);
    this.snapshot = this.type.create(create.data);

    // This is a bit heavyweight, but I want the created event to fire outside of the lock.
    this.once('unlock', function() {
      this.emit('create', context);
    });
  } else if (opData.del) {
    // The type should always exist in this case. del x _ = del
    var oldSnapshot = this.snapshot;
    this._setType(null);
    this.once('unlock', function() {
      this.emit('del', context, oldSnapshot);
    });
  } else if (opData.op) {
    if (!this.type) throw new Error('Document does not exist');

    var type = this.type;

    var op = opData.op;
    
    // The context needs to be told we're about to edit, just in case it needs
    // to store any extra data. (text-tp2 has this constraint.)
    for (var i = 0; i < this.editingContexts.length; i++) {
      var c = this.editingContexts[i];
      if (c != context && c._beforeOp) c._beforeOp(opData.op);
    }

    this.emit('before op', op, context);

    // This exists so clients can pull any necessary data out of the snapshot
    // before it gets changed.  Previously we kept the old snapshot object and
    // passed it to the op event handler. However, apply no longer guarantees
    // the old object is still valid.
    //
    // Because this could be totally unnecessary work, its behind a flag. set
    // doc.incremental to enable.
    if (this.incremental && type.incrementalApply) {
      var _this = this;
      type.incrementalApply(this.snapshot, op, function(o, snapshot) {
        _this.snapshot = snapshot;
        _this.emit('op', o, context);
      });
    } else {
      // This is the most common case, simply applying the operation to the local snapshot.
      this.snapshot = type.apply(this.snapshot, op);
      this.emit('op', op, context);
    }
  }
  // Its possible for none of the above cases to match, in which case the op is
  // a no-op. This will happen when a document has been deleted locally and
  // remote ops edit the document.
};

// This should be called right after _otApply.
Doc.prototype._afterOtApply = function(opData, context) {
  this.locked = false;
  this.emit('unlock');
  if (opData.op) {
    var contexts = this.editingContexts;
    // Notify all the contexts about the op (well, all the contexts except
    // the one which initiated the submit in the first place).
    for (var i = 0; i < contexts.length; i++) {
      var c = contexts[i];
      if (c != context && c._onOp) c._onOp(opData.op);
    }
    for (var i = 0; i < contexts.length; i++) {
      if (contexts.remove) contexts.splice(i--, 1);
    }

    return this.emit('after op', opData.op, context);
  }
};



// ***** Sending operations


// Actually send op data to the server.
Doc.prototype._sendOpData = function() {
  var d = this.inflightData;

  if (this.action) throw new Error('invalid state ' + this.action + ' for sendOpData');
  this.action = 'submit';

  var msg = {a: 'op', v: this.version};
  if (d.src) {
    msg.src = d.src;
    msg.seq = d.seq;
  }

  // The server autodetects this.
  //if (this.state === 'unsubscribed') msg.f = true; // fetch intermediate ops

  if (d.op) msg.op = d.op;
  if (d.create) msg.create = d.create;
  if (d.del) msg.del = d.del;

  msg.c = this.collection;
  msg.d = this.name;

  this.connection.sendOp(msg);
   
  // The first time we send an op, its id and sequence number is implicit.
  if (!d.src) {
    d.src = this.connection.id;
    d.seq = this.connection.seq++;
  }
};


// Internal method called to do the actual work for submitOp(), create() and del().
//
// context is optional.
Doc.prototype._submitOpData = function(opData, context, callback) {
  //console.log('submit', JSON.stringify(opData), 'v=', this.version);

  if (typeof context === 'function') {
    callback = context;
    context = true; // The default context is true.
  }
  if (context == null) context = true;

  var error = function(err) {
    if (callback) callback(err);
    else if (console) console.warn('Failed attempt to submitOp:', err);
  };

  if (this.locked) {
    return error("Cannot call submitOp from inside an 'op' event handler");
  }

  // The opData contains either op, create, delete, or none of the above (a no-op).

  if (opData.op) {
    if (!this.type) return error('Document has not been created');

    // Try to normalize the op. This removes trailing skip:0's and things like that.
    if (this.type.normalize) opData.op = this.type.normalize(opData.op);
  }

  if (!this.state) {
    this.state = 'floating';
  }

  // Actually apply the operation locally.
  this._otApply(opData, context);

  // If the type supports composes, try to compose the operation onto the end
  // of the last pending operation.
  var entry = this.pendingData[this.pendingData.length - 1];

  if (this.pendingData.length &&
      (entry = this.pendingData[this.pendingData.length - 1],
       tryCompose(this.type, entry, opData))) {
  } else {
    entry = opData;
    opData.type = this.type;
    opData.callbacks = [];
    this.pendingData.push(opData);
  }

  if (callback) entry.callbacks.push(callback);

  this._afterOtApply(opData, context);

  var _this = this;
  setTimeout((function() { _this.flush(); }), 0);
};


// *** Client OT entrypoints.

// Submit an operation to the document. The op must be valid given the current OT type.
Doc.prototype.submitOp = function(op, context, callback) {
  this._submitOpData({op: op}, context, callback);
};

// Create the document, which in ShareJS semantics means to set its type. Every
// object implicitly exists in the database but has no data and no type. Create
// sets the type of the object and can optionally set some initial data on the
// object, depending on the type.
Doc.prototype.create = function(type, data, context, callback) {
  if (typeof data === 'function') {
    // Setting the context to be the callback function in this case so _submitOpData
    // can handle the default value thing.
    context = data;
    data = undefined;
  }
  if (this.type) {
    if (callback) callback('Document already exists');
    return 
  }

  this._submitOpData({create: {type:type, data:data}}, context, callback);
};

// Delete the document. This creates and submits a delete operation to the
// server. Deleting resets the object's type to null and deletes its data. The
// document still exists, and still has the version it used to have before you
// deleted it (well, old version +1).
Doc.prototype.del = function(context, callback) {
  if (!this.type) {
    if (callback) callback('Document does not exist');
    return;
  }

  this._submitOpData({del: true}, context, callback);
};


// Pausing stops the document from sending any operations to the server.
Doc.prototype.pause = function() {
  this.paused = true;
};

Doc.prototype.resume = function() {
  this.paused = false;
  this.flush();
};


// *** Receiving operations


// This will be called when the server rejects our operations for some reason.
// There's not much we can do here if the OT type is noninvertable, but that
// shouldn't happen too much in real life because readonly documents should be
// flagged as such. (I should probably figure out a flag for that).
//
// This does NOT get called if our op fails to reach the server for some reason
// - we optimistically assume it'll make it there eventually.
Doc.prototype._tryRollback = function(opData) {
  // This is probably horribly broken.
  if (opData.create) {
    this._setType(null);

    // I don't think its possible to get here if we aren't in a floating state.
    if (this.state === 'floating')
      this.state = null;
    else
      console.warn('Rollback a create from state ' + this.state);

  } else if (opData.op && opData.type.invert) {
    var undo = opData.type.invert(opData.op);

    // Transform the undo operation by any pending ops.
    for (var i = 0; i < this.pendingData.length; i++) {
      xf(this.pendingData[i], undo);
    }

    // ... and apply it locally, reverting the changes.
    // 
    // This operation is applied to look like it comes from a remote context.
    // I'm still not 100% sure about this functionality, because its really a
    // local op. Basically, the problem is that if the client's op is rejected
    // by the server, the editor window should update to reflect the undo.
    this._otApply(undo, false);
    this._afterOtApply(undo, false);
  } else if (opData.op || opData.del) {
    // This is where an undo stack would come in handy.
    this._setType(null);
    this.version = null;
    this.state = null;
    this.subscribed = false;
    this.emit('error', "Op apply failed and the operation could not be reverted");

    // Trigger a fetch. In our invalid state, we can't really do anything.
    this.fetch();
    this.flush();
  }
};

Doc.prototype._clearInflightOp = function(error) {
  var callbacks = this.inflightData.callbacks;
  for (var i = 0; i < callbacks.length; i++) {
    callbacks[i](error || this.inflightData.error);
  }

  this.inflightData = null;
  this._clearAction('submit');

  if (!this.pendingData.length) {
    // This isn't a very good name.
    this.emit('nothing pending');
  }
};

// This is called when the server acknowledges an operation from the client.
Doc.prototype._opAcknowledged = function(msg) {
  // Our inflight op has been acknowledged, so we can throw away the inflight data.
  // (We were only holding on to it incase we needed to resend the op.)
  if (!this.state) {
    throw new Error('opAcknowledged called from a null state. This should never happen.');
  } else if (this.state === 'floating') {
    if (!this.inflightData.create) throw new Error('Cannot acknowledge an op.');

    // Our create has been acknowledged. This is the same as injesting some data.
    this.version = msg.v;
    this.state = 'ready';
    var _this = this;
    setTimeout(function() { _this.emit('ready'); }, 0);
  } else {
    // We already have a snapshot. The snapshot should be at the acknowledged
    // version, because the server has sent us all the ops that have happened
    // before acknowledging our op.

    // This should never happen - something is out of order.
    if (msg.v !== this.version)
      throw new Error('Invalid version from server. Please file an issue, this is a bug.');
  }
  
  // The op was committed successfully. Increment the version number
  this.version++;

  this._clearInflightOp();
};


// API Contexts

// This creates and returns an editing context using the current OT type.
Doc.prototype.createContext = function() {
  var type = this.type;
  if (!type) throw new Error('Missing type');

  // I could use the prototype chain to do this instead, but Object.create
  // isn't defined on old browsers. This will be fine.
  var doc = this;
  var context = {
    getSnapshot: function() {
      return doc.snapshot;
    },
    submitOp: function(op, callback) {
      doc.submitOp(op, context, callback);
    },
    destroy: function() {
      if (this.detach) {
        this.detach();
        // Don't double-detach.
        delete this.detach;
      }
      // It will be removed from the actual editingContexts list next time
      // we receive an op on the document (and the list is iterated through).
      //
      // This is potentially dodgy, allowing a memory leak if you create &
      // destroy a whole bunch of contexts without receiving or sending any ops
      // to the document.
      delete this._onOp;
      this.remove = true;
    },

    // This is dangerous, but really really useful for debugging. I hope people
    // don't depend on it.
    _doc: this,
  };

  if (type.api) {
    // Copy everything else from the type's API into the editing context.
    for (var k in type.api) {
      context[k] = type.api[k];
    }
  } else {
    context.provides = {};
  }

  this.editingContexts.push(context);

  return context;
};

Doc.prototype.removeContexts = function() {
  for (var i = 0; i < this.editingContexts.length; i++) {
    this.editingContexts[i].destroy();
  }
  this.editingContexts.length = 0;
};


},{"./microevent":38,"ottypes":40}],40:[function(require,module,exports){

var register = function(type) {
  exports[type.name] = type;
  if (type.uri) {
    return exports[type.uri] = type;
  }
};

// Import all the built-in types. Requiring directly rather than in register()
// so browserify works.
register(require('./simple'));

register(require('./text'));
register(require('./text-tp2'));

register(require('./json0'));


},{"./text":41,"./simple":42,"./json0":43,"./text-tp2":44}],41:[function(require,module,exports){
/* Text OT!
 *
 * This is an OT implementation for text. It is the standard implementation of
 * text used by ShareJS.
 *
 * This type is composable but non-invertable. Its similar to ShareJS's old
 * text-composable type, but its not invertable and its very similar to the
 * text-tp2 implementation but it doesn't support tombstones or purging.
 *
 * Ops are lists of components which iterate over the document.
 * Components are either:
 *   A number N: Skip N characters in the original document
 *   "str"     : Insert "str" at the current position in the document
 *   {d:'str'} : Delete 'str', which appears at the current position in the document
 *
 * Eg: [3, 'hi', 5, {d:8}]
 *
 * The operation does not have to skip the last characters in the document.
 *
 * Snapshots are strings.
 *
 * Cursors are either a single number (which is the cursor position) or a pair of
 * [anchor, focus] (aka [start, end]). Be aware that end can be before start.
 */

/** @module text */

exports.name = 'text';
exports.uri = 'http://sharejs.org/types/textv1';

/** Create a new text snapshot.
 *
 * @param {string} initial - initial snapshot data. Optional. Defaults to ''.
 */
exports.create = function(initial) {
  if ((initial != null) && typeof initial !== 'string') {
    throw new Error('Initial data must be a string');
  }
  return initial || '';
};

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) === "[object Array]";
};

/** Check the operation is valid. Throws if not valid. */
var checkOp = function(op) {
  if (!isArray(op)) throw new Error('Op must be an array of components');

  var last = null;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    switch (typeof c) {
      case 'object':
        // The only valid objects are {d:X} for +ive values of X.
        if (!(typeof c.d === 'number' && c.d > 0)) throw new Error('Object components must be deletes of size > 0');
        break;
      case 'string':
        // Strings are inserts.
        if (!(c.length > 0)) throw new Error('Inserts cannot be empty');
        break;
      case 'number':
        // Numbers must be skips. They have to be +ive numbers.
        if (!(c > 0)) throw new Error('Skip components must be >0');
        if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');
        break;
    }
    last = c;
  }

  if (typeof last === 'number') throw new Error('Op has a trailing skip');
};

/** Make a function that appends to the given operation. */
var makeAppend = function(op) {
  return function(component) {
    if (!component || component.d === 0) {
      // The component is a no-op. Ignore!
 
    } else if (op.length === 0) {
      return op.push(component);

    } else if (typeof component === typeof op[op.length - 1]) {
      if (typeof component === 'object') {
        return op[op.length - 1].d += component.d;
      } else {
        return op[op.length - 1] += component;
      }
    } else {
      return op.push(component);
    }
  };
};

/** Makes and returns utility functions take and peek. */
var makeTake = function(op) {
  // The index of the next component to take
  var idx = 0;
  // The offset into the component
  var offset = 0;

  // Take up to length n from the front of op. If n is -1, take the entire next
  // op component. If indivisableField == 'd', delete components won't be separated.
  // If indivisableField == 'i', insert components won't be separated.
  var take = function(n, indivisableField) {
    // We're at the end of the operation. The op has skips, forever. Infinity
    // might make more sense than null here.
    if (idx === op.length)
      return n === -1 ? null : n;

    var part;
    var c = op[idx];
    if (typeof c === 'number') {
      // Skip
      if (n === -1 || c - offset <= n) {
        part = c - offset;
        ++idx;
        offset = 0;
        return part;
      } else {
        offset += n;
        return n;
      }
    } else if (typeof c === 'string') {
      // Insert
      if (n === -1 || indivisableField === 'i' || c.length - offset <= n) {
        part = c.slice(offset);
        ++idx;
        offset = 0;
        return part;
      } else {
        part = c.slice(offset, offset + n);
        offset += n;
        return part;
      }
    } else {
      // Delete
      if (n === -1 || indivisableField === 'd' || c.d - offset <= n) {
        part = {d: c.d - offset};
        ++idx;
        offset = 0;
        return part;
      } else {
        offset += n;
        return {d: n};
      }
    }
  };

  // Peek at the next op that will be returned.
  var peekType = function() { return op[idx]; };

  return [take, peekType];
};

/** Get the length of a component */
var componentLength = function(c) {
  // Uglify will compress this down into a ternary
  if (typeof c === 'number') {
    return c;
  } else {
    return c.length || c.d;
  }
};

/** Trim any excess skips from the end of an operation.
 *
 * There should only be at most one, because the operation was made with append.
 */
var trim = function(op) {
  if (op.length > 0 && typeof op[op.length - 1] === 'number') {
    op.pop();
  }
  return op;
};

exports.normalize = function(op) {
  var newOp = [];
  var append = makeAppend(newOp);
  for (var i = 0; i < op.length; i++) {
    append(op[i]);
  }
  return trim(newOp);
};

/** Apply an operation to a document snapshot */
exports.apply = function(str, op) {
  if (typeof str !== 'string') {
    throw new Error('Snapshot should be a string');
  }
  checkOp(op);

  // We'll gather the new document here and join at the end.
  var newDoc = [];

  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    switch (typeof component) {
      case 'number':
        if (component > str.length) throw new Error('The op is too long for this document');

        newDoc.push(str.slice(0, component));
        // This might be slow for big strings. Consider storing the offset in
        // str instead of rewriting it each time.
        str = str.slice(component);
        break;
      case 'string':
        newDoc.push(component);
        break;
      case 'object':
        str = str.slice(component.d);
        break;
    }
  }

  return newDoc.join('') + str;
};

/** Transform op by otherOp.
 *
 * @param op - The operation to transform
 * @param otherOp - Operation to transform it by
 * @param side - Either 'left' or 'right'
 */
exports.transform = function(op, otherOp, side) {
  if (side != 'left' && side != 'right') throw new Error("side (" + side + ") must be 'left' or 'right'");

  checkOp(op);
  checkOp(otherOp);

  var newOp = [];
  var append = makeAppend(newOp);

  var _fns = makeTake(op);
  var take = _fns[0],
      peek = _fns[1];

  for (var i = 0; i < otherOp.length; i++) {
    var component = otherOp[i];

    var length, chunk;
    switch (typeof component) {
      case 'number': // Skip
        length = component;
        while (length > 0) {
          chunk = take(length, 'i');
          append(chunk);
          if (typeof chunk !== 'string') {
            length -= componentLength(chunk);
          }
        }
        break;

      case 'string': // Insert
        if (side === 'left') {
          // The left insert should go first.
          if (typeof peek() === 'string') {
            append(take(-1));
          }
        }

        // Otherwise skip the inserted text.
        append(component.length);
        break;

      case 'object': // Delete
        length = component.d;
        while (length > 0) {
          chunk = take(length, 'i');
          switch (typeof chunk) {
            case 'number':
              length -= chunk;
              break;
            case 'string':
              append(chunk);
              break;
            case 'object':
              // The delete is unnecessary now - the text has already been deleted.
              length -= chunk.d;
          }
        }
        break;
    }
  }
  
  // Append any extra data in op1.
  while ((component = take(-1)))
    append(component);
  
  return trim(newOp);
};

/** Compose op1 and op2 together and return the result */
exports.compose = function(op1, op2) {
  checkOp(op1);
  checkOp(op2);

  var result = [];
  var append = makeAppend(result);
  var take = makeTake(op1)[0];

  for (var i = 0; i < op2.length; i++) {
    var component = op2[i];
    var length, chunk;
    switch (typeof component) {
      case 'number': // Skip
        length = component;
        while (length > 0) {
          chunk = take(length, 'd');
          append(chunk);
          if (typeof chunk !== 'object') {
            length -= componentLength(chunk);
          }
        }
        break;

      case 'string': // Insert
        append(component);
        break;

      case 'object': // Delete
        length = component.d;

        while (length > 0) {
          chunk = take(length, 'd');

          switch (typeof chunk) {
            case 'number':
              append({d: chunk});
              length -= chunk;
              break;
            case 'string':
              length -= chunk.length;
              break;
            case 'object':
              append(chunk);
          }
        }
        break;
    }
  }

  while ((component = take(-1)))
    append(component);

  return trim(result);
};

var transformPosition = function(cursor, op) {
  var pos = 0;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (cursor <= pos) break;

    // I could actually use the op_iter stuff above - but I think its simpler
    // like this.
    switch (typeof c) {
      case 'number':
        if (cursor <= pos + c)
          return cursor;
        pos += c;
        break;

      case 'string':
        pos += c.length;
        cursor += c.length;
        break;

      case 'object':
        cursor -= Math.min(c.d, cursor - pos);
        break;
    }
  }
  return cursor;
};

exports.transformCursor = function(cursor, op, isOwnOp) {
  var pos = 0;
  if (isOwnOp) {
    // Just track the position. We'll teleport the cursor to the end anyway.
    // This works because text ops don't have any trailing skips at the end - so the last
    // component is the last thing.
    for (var i = 0; i < op.length; i++) {
      var c = op[i];
      switch (typeof c) {
        case 'number':
          pos += c;
          break;
        case 'string':
          pos += c.length;
          break;
        // Just eat deletes.
      }
    }
    return [pos, pos];
  } else {
    return [transformPosition(cursor[0], op), transformPosition(cursor[1], op)];
  }
};

},{}],42:[function(require,module,exports){
// This is a really simple OT type. Its not compiled with the web client, but it could be.
//
// Its mostly included for demonstration purposes and its used in the meta unit tests.
//
// This defines a really simple text OT type which only allows inserts. (No deletes).
//
// Ops look like:
//   {position:#, text:"asdf"}
//
// Document snapshots look like:
//   {str:string}

module.exports = {
  // The name of the OT type. The type itself is exposed to ottypes[type.name] and ottypes[type.uri].
  // The name can be used instead of the actual type in all API methods in ShareJS.
  name: 'simple',

  // Canonical name.
  uri: 'http://sharejs.org/types/simple',

  // Create a new document snapshot. Initial data can be passed in.
  create: function(initial) {
    if (initial == null)
      initial = '';

    return {str: initial};
  },

  // Apply the given op to the document snapshot. Returns the new snapshot.
  apply: function(snapshot, op) {
    if (op.position < 0 || op.position > snapshot.str.length)
      throw new Error('Invalid position');

    var str = snapshot.str;
    str = str.slice(0, op.position) + op.text + str.slice(op.position);
    return {str: str};
  },

  // Transform op1 by op2. Returns transformed version of op1.
  // Sym describes the symmetry of the operation. Its either 'left' or 'right'
  // depending on whether the op being transformed comes from the client or the
  // server.
  transform: function(op1, op2, sym) {
    var pos = op1.position;

    if (op2.position < pos || (op2.position === pos && sym === 'left')) {
      pos += op2.text.length;
    }

    return {position: pos, text: op1.text};
  }
};


},{}],44:[function(require,module,exports){
(function(){// A TP2 implementation of text, following this spec:
// http://code.google.com/p/lightwave/source/browse/trunk/experimental/ot/README
//
// A document is made up of a string and a set of tombstones inserted throughout
// the string. For example, 'some ', (2 tombstones), 'string'.
//
// This is encoded in a document as: {s:'some string', t:[5, -2, 6]}
//
// Ops are lists of components which iterate over the whole document. (I might
// change this at some point, but a version thats less strict is backwards
// compatible.)
//
// Components are either:
//   N:         Skip N characters in the original document
//   {i:'str'}: Insert 'str' at the current position in the document
//   {i:N}:     Insert N tombstones at the current position in the document
//   {d:N}:     Delete (tombstone) N characters at the current position in the document
//
// Eg: [3, {i:'hi'}, 5, {d:8}]
//
// Snapshots are lists with characters and tombstones. Characters are stored in strings
// and adjacent tombstones are flattened into numbers.
//
// Eg, the document: 'Hello .....world' ('.' denotes tombstoned (deleted) characters)
// would be represented by a document snapshot of ['Hello ', 5, 'world']

//var append, appendDoc, componentLength, makeTake, takeDoc, transformer;

var type = module.exports = {
  name: 'text-tp2',
  tp2: true,
  uri: 'http://sharejs.org/types/text-tp2v1',
  create: function(initial) {
    if (initial == null) {
      initial = '';
    } else {
      if (typeof initial != 'string') throw new Error('Initial data must be a string');
    }

    return {
      charLength: initial.length,
      totalLength: initial.length,
      data: initial.length ? [initial] : []
    };
  },

  serialize: function(doc) {
    if (!doc.data) {
      throw new Error('invalid doc snapshot');
    }
    return doc.data;
  },

  deserialize: function(data) {
    var doc = type.create();
    doc.data = data;

    for (var i = 0; i < data.length; i++) {
      var component = data[i];

      if (typeof component === 'string') {
        doc.charLength += component.length;
        doc.totalLength += component.length;
      } else {
        doc.totalLength += component;
      }
    }

    return doc;
  }
};

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

var checkOp = function(op) {
  if (!isArray(op)) throw new Error('Op must be an array of components');

  var last = null;
  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (typeof c == 'object') {
      // The component is an insert or a delete.
      if (c.i !== undefined) { // Insert.
        if (!((typeof c.i === 'string' && c.i.length > 0) // String inserts
              || (typeof c.i === 'number' && c.i > 0))) // Tombstone inserts
          throw new Error('Inserts must insert a string or a +ive number');

      } else if (c.d !== undefined) { // Delete
        if (!(typeof c.d === 'number' && c.d > 0))
          throw new Error('Deletes must be a +ive number');

      } else throw new Error('Operation component must define .i or .d');

    } else {
      // The component must be a skip.
      if (typeof c != 'number') throw new Error('Op components must be objects or numbers');

      if (c <= 0) throw new Error('Skip components must be a positive number');
      if (typeof last === 'number') throw new Error('Adjacent skip components should be combined');
    }

    last = c;
  }
};

// Take the next part from the specified position in a document snapshot.
// position = {index, offset}. It will be updated.
var takeDoc = type._takeDoc = function(doc, position, maxlength, tombsIndivisible) {
  if (position.index >= doc.data.length)
    throw new Error('Operation goes past the end of the document');

  var part = doc.data[position.index];

  // This can be written as an ugly-arsed giant ternary statement, but its much
  // more readable like this. Uglify will convert it into said ternary anyway.
  var result;
  if (typeof part == 'string') {
    if (maxlength != null) {
      result = part.slice(position.offset, position.offset + maxlength);
    } else {
      result = part.slice(position.offset);
    }
  } else {
    if (maxlength == null || tombsIndivisible) {
      result = part - position.offset;
    } else {
      result = Math.min(maxlength, part - position.offset);
    }
  }

  var resultLen = result.length || result;

  if ((part.length || part) - position.offset > resultLen) {
    position.offset += resultLen;
  } else {
    position.index++;
    position.offset = 0;
  }

  return result;
};

// Append a part to the end of a document
var appendDoc = type._appendDoc = function(doc, p) {
  if (p === 0 || p === '') return;

  if (typeof p === 'string') {
    doc.charLength += p.length;
    doc.totalLength += p.length;
  } else {
    doc.totalLength += p;
  }

  var data = doc.data;
  if (data.length === 0) {
    data.push(p);
  } else if (typeof data[data.length - 1] === typeof p) {
    data[data.length - 1] += p;
  } else {
    data.push(p);
  }
};

// Apply the op to the document. The document is not modified in the process.
type.apply = function(doc, op) {
  if (doc.totalLength == null || doc.charLength == null || !isArray(doc.data)) {
    throw new Error('Snapshot is invalid');
  }
  checkOp(op);

  var newDoc = type.create();
  var position = {index: 0, offset: 0};

  for (var i = 0; i < op.length; i++) {
    var component = op[i];
    var remainder, part;

    if (typeof component == 'number') { // Skip
      remainder = component;
      while (remainder > 0) {
        part = takeDoc(doc, position, remainder);
        appendDoc(newDoc, part);
        remainder -= part.length || part;
      }

    } else if (component.i !== undefined) { // Insert
      appendDoc(newDoc, component.i);

    } else if (component.d !== undefined) { // Delete
      remainder = component.d;
      while (remainder > 0) {
        part = takeDoc(doc, position, remainder);
        remainder -= part.length || part;
      }
      appendDoc(newDoc, component.d);
    }
  }
  return newDoc;
};

// Append an op component to the end of the specified op.  Exported for the
// randomOpGenerator.
var append = type._append = function(op, component) {
  var last;

  if (component === 0 || component.i === '' || component.i === 0 || component.d === 0) {
    // Drop the new component.
  } else if (op.length === 0) {
    op.push(component);
  } else {
    last = op[op.length - 1];
    if (typeof component == 'number' && typeof last == 'number') {
      op[op.length - 1] += component;
    } else if (component.i != null && (last.i != null) && typeof last.i === typeof component.i) {
      last.i += component.i;
    } else if (component.d != null && (last.d != null)) {
      last.d += component.d;
    } else {
      op.push(component);
    }
  }
};

// Makes 2 functions for taking components from the start of an op, and for
// peeking at the next op that could be taken.
var makeTake = function(op) {
  // The index of the next component to take
  var index = 0;
  // The offset into the component
  var offset = 0;

  var take = function(maxlength, insertsIndivisible) {
    if (index === op.length) return null;
    var e = op[index];
    var current;
    var result;

    // if the current element is a skip, an insert of a number or a delete
    if (typeof (current = e) == 'number' || typeof (current = e.i) == 'number' || (current = e.d) != null) {
      var c;
      if ((maxlength == null) || current - offset <= maxlength || (insertsIndivisible && e.i != null)) {
        // Return the rest of the current element.
        c = current - offset;
        ++index;
        offset = 0;
      } else {
        offset += maxlength;
        c = maxlength;
      }

      // Package the component back up.
      if (e.i != null) {
        return {i: c};
      } else if (e.d != null) {
        return {d: c};
      } else {
        return c;
      }
    } else { // Insert of a string.
      if ((maxlength == null) || e.i.length - offset <= maxlength || insertsIndivisible) {
        result = {i: e.i.slice(offset)};
        ++index;
        offset = 0;
      } else {
        result = {i: e.i.slice(offset, offset + maxlength)};
        offset += maxlength;
      }
      return result;
    }
  };

  var peekType = function() {return op[index];};
  return [take, peekType];
};

// Find and return the length of an op component
var componentLength = function(component) {
  if (typeof component === 'number') {
    return component;
  } else if (typeof component.i === 'string') {
    return component.i.length;
  } else {
    return component.d || component.i;
  }
};

// Normalize an op, removing all empty skips and empty inserts / deletes.
// Concatenate adjacent inserts and deletes.
type.normalize = function(op) {
  var newOp = [];
  for (var i = 0; i < op.length; i++) {
    append(newOp, op[i]);
  }
  return newOp;
};

// This is a helper method to transform and prune. goForwards is true for transform, false for prune.
var transformer = function(op, otherOp, goForwards, side) {
  checkOp(op);
  checkOp(otherOp);

  var newOp = [];

  var fns = makeTake(op),
      take = fns[0],
      peek = fns[1];

  for (var i = 0; i < otherOp.length; i++) {
    var component = otherOp[i];
    var len = componentLength(component);
    var chunk;

    if (component.i != null) { // Insert text or tombs
      if (goForwards) { // Transform - insert skips over deleted parts.
        if (side === 'left') {
          // The left side insert should go first.
          var next;
          while ((next = peek()) && next.i != null) {
            append(newOp, take());
          }
        }
        // In any case, skip the inserted text.
        append(newOp, len);

      } else { // Prune. Remove skips for inserts.
        while (len > 0) {
          chunk = take(len, true);

          // The chunk will be null if we run out of components in the other op.
          if (chunk === null) throw new Error('The transformed op is invalid');
          if (chunk.d != null)
            throw new Error('The transformed op deletes locally inserted characters - it cannot be purged of the insert.');

          if (typeof chunk == 'number')
            len -= chunk;
          else
            append(newOp, chunk);
        }
      }
    } else { // Skips or deletes.
      while (len > 0) {
        chunk = take(len, true);
        if (chunk === null) throw new Error('The op traverses more elements than the document has');

        append(newOp, chunk);
        if (!chunk.i) len -= componentLength(chunk);
      }
    }
  }

  // Append extras from op1.
  var component;
  while ((component = take())) {
    if (component.i === undefined) {
      throw new Error("Remaining fragments in the op: " + component);
    }
    append(newOp, component);
  }
  return newOp;
};

// transform op1 by op2. Return transformed version of op1. op1 and op2 are
// unchanged by transform. Side should be 'left' or 'right', depending on if
// op1.id <> op2.id.
//
// 'left' == client op for ShareJS.
type.transform = function(op, otherOp, side) {
  if (side != 'left' && side != 'right')
    throw new Error("side (" + side + ") should be 'left' or 'right'");

  return transformer(op, otherOp, true, side);
};

type.prune = function(op, otherOp) {
  return transformer(op, otherOp, false);
};

type.compose = function(op1, op2) {
  //var chunk, chunkLength, component, length, result, take, _, _i, _len, _ref;
  if (op1 == null) return op2;

  checkOp(op1);
  checkOp(op2);

  var result = [];
  var take = makeTake(op1)[0];
  var component;

  for (var i = 0; i < op2.length; i++) {
    component = op2[i];
    var len, chunk;

    if (typeof component === 'number') { // Skip
      // Just copy from op1.
      len = component;
      while (len > 0) {
        chunk = take(len);
        if (chunk === null)
          throw new Error('The op traverses more elements than the document has');

        append(result, chunk);
        len -= componentLength(chunk);
      }

    } else if (component.i !== undefined) { // Insert
      append(result, {i: component.i});

    } else { // Delete
      len = component.d;
      while (len > 0) {
        chunk = take(len);
        if (chunk === null)
          throw new Error('The op traverses more elements than the document has');

        var chunkLength = componentLength(chunk);

        if (chunk.i !== undefined)
          append(result, {i: chunkLength});
        else
          append(result, {d: chunkLength});

        len -= chunkLength;
      }
    }
  }

  // Append extras from op1.
  while ((component = take())) {
    if (component.i === undefined) {
      throw new Error("Remaining fragments in op1: " + component);
    }
    append(result, component);
  }
  return result;
};


})()
},{}],43:[function(require,module,exports){
/*
 This is the implementation of the JSON OT type.

 Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations

 Note: This is being made obsolete. It will soon be replaced by the JSON2 type.
*/

/**
 * UTILITY FUNCTIONS
 */

/**
 * Checks if the passed object is an Array instance. Can't use Array.isArray
 * yet because its not supported on IE8.
 *
 * @param obj
 * @returns {boolean}
 */
var isArray = function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

/**
 * Clones the passed object using JSON serialization (which is slow).
 *
 * hax, copied from test/types/json. Apparently this is still the fastest way
 * to deep clone an object, assuming we have browser support for JSON.  @see
 * http://jsperf.com/cloning-an-object/12
 */
var clone = function(o) {
  return JSON.parse(JSON.stringify(o));
};



/**
 * Reference to the Text OT type. This is used for the JSON String operations.
 * @type {*}
 */
var text = typeof require !== "undefined" ? require('./text-old') : window.ottypes.text;



/**
 * JSON OT Type
 * @type {*}
 */
var json = { 
  name: 'json0',
  uri: 'http://sharejs.org/types/JSONv0'
};

json.create = function(data) {
  // Null instead of undefined if you don't pass an argument.
  return data === undefined ? null : data;
};

json.invertComponent = function(c) {
  var c_ = {p: c.p};

  if (c.si !== void 0) c_.sd = c.si;
  if (c.sd !== void 0) c_.si = c.sd;
  if (c.oi !== void 0) c_.od = c.oi;
  if (c.od !== void 0) c_.oi = c.od;
  if (c.li !== void 0) c_.ld = c.li;
  if (c.ld !== void 0) c_.li = c.ld;
  if (c.na !== void 0) c_.na = -c.na;

  if (c.lm !== void 0) {
    c_.lm = c.p[c.p.length-1];
    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);
  }

  return c_;
};

json.invert = function(op) {
  var op_ = op.slice().reverse();
  var iop = [];
  for (var i = 0; i < op_.length; i++) {
    iop.push(json.invertComponent(op_[i]));
  }
  return iop;
};

json.checkValidOp = function(op) {
  for (var i = 0; i < op.length; i++) {
  if (!isArray(op[i].p))
    throw new Error('Missing path');
  }
};

json.checkList = function(elem) {
  if (!isArray(elem))
    throw new Error('Referenced element not a list');
};

json.checkObj = function(elem) {
  if (elem.constructor !== Object) {
    throw new Error("Referenced element not an object (it was " + JSON.stringify(elem) + ")");
  }
};

json.apply = function(snapshot, op) {
  json.checkValidOp(op);

  op = clone(op);

  var container = {
    data: snapshot
  };

  for (var i = 0; i < op.length; i++) {
    var c = op[i];

    var parent = null;
    var parentKey = null;
    var elem = container;
    var key = 'data';

    for (var j = 0; j < c.p.length; j++) {
      var p = c.p[j];

      parent = elem;
      parentKey = key;
      elem = elem[key];
      key = p;

      if (parent == null)
        throw new Error('Path invalid');
    }

    // Number add
    if (c.na !== void 0) {
      if (typeof elem[key] != 'number')
        throw new Error('Referenced element not a number');

      elem[key] += c.na;
    }

    // String insert
    else if (c.si !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string (it was '+JSON.stringify(elem)+')');

      parent[parentKey] = elem.slice(0,key) + c.si + elem.slice(key);
    }

    // String delete
    else if (c.sd !== void 0) {
      if (typeof elem != 'string')
        throw new Error('Referenced element not a string');

      if (elem.slice(key,key + c.sd.length) !== c.sd)
        throw new Error('Deleted string does not match');

      parent[parentKey] = elem.slice(0,key) + elem.slice(key + c.sd.length);
    }

    // List replace
    else if (c.li !== void 0 && c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld
      elem[key] = c.li;
    }

    // List insert
    else if (c.li !== void 0) {
      json.checkList(elem);
      elem.splice(key,0, c.li);
    }

    // List delete
    else if (c.ld !== void 0) {
      json.checkList(elem);
      // Should check the list element matches c.ld here too.
      elem.splice(key,1);
    }

    // List move
    else if (c.lm !== void 0) {
      json.checkList(elem);
      if (c.lm != key) {
        var e = elem[key];
        // Remove it...
        elem.splice(key,1);
        // And insert it back.
        elem.splice(c.lm,0,e);
      }
    }

    // Object insert / replace
    else if (c.oi !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      elem[key] = c.oi;
    }

    // Object delete
    else if (c.od !== void 0) {
      json.checkObj(elem);

      // Should check that elem[key] == c.od
      delete elem[key];
    }

    else {
      throw new Error('invalid / missing instruction in op');
    }
  }

  return container.data;
};

// Helper for incrementally applying an operation to a snapshot. Calls yield
// after each op component has been applied.
json.incrementalApply = function(snapshot, op, _yield) {
  for (var i = 0; i < op.length; i++) {
    var smallOp = [op[i]];
    snapshot = json.apply(snapshot, smallOp);
    // I'd just call this yield, but thats a reserved keyword. Bah!
    _yield(smallOp, snapshot);
  }
  
  return snapshot;
};

// Checks if two paths, p1 and p2 match.
var pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {
  if (p1.length != p2.length)
    return false;

  for (var i = 0; i < p1.length; i++) {
    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))
      return false;
  }

  return true;
};

var _convertToTextComponent = function(component) {
  var newC = {p: component.p[component.p.length - 1]};
  if (component.si != null) {
    newC.i = component.si;
  } else {
    newC.d = component.sd;
  }
  return newC;
};

json.append = function(dest,c) {
  c = clone(c);

  var last;

  if (dest.length != 0 && pathMatches(c.p, (last = dest[dest.length - 1]).p)) {
    if (last.na != null && c.na != null) {
      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};
    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {
      // insert immediately followed by delete becomes a noop.
      if (last.ld !== undefined) {
        // leave the delete part of the replace
        delete last.li;
      } else {
        dest.pop();
      }
    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {
      last.oi = c.oi;
    } else if (last.oi !== undefined && c.od !== undefined) {
      // The last path component inserted something that the new component deletes (or replaces).
      // Just merge them.
      if (c.oi !== undefined) {
        last.oi = c.oi;
      } else if (last.od !== undefined) {
        delete last.oi;
      } else {
        // An insert directly followed by a delete turns into a no-op and can be removed.
        dest.pop();
      }
    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {
      // don't do anything
    } else {
      dest.push(c);
    }
  } else if (dest.length != 0 && pathMatches(c.p, last.p, true)) {
    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {
      // Try to compose the string ops together using text's equivalent methods
      var textOp = [_convertToTextComponent(last)];
      text._append(textOp, _convertToTextComponent(c));
      
      // Then convert back.
      if (textOp.length !== 1) {
        dest.push(c);
      } else {
        var textC = textOp[0];
        last.p[last.p.length - 1] = textC.p;
        if (textC.i != null)
          last.si = textC.i;
        else
          last.sd = textC.d;
      }
    } else {
      dest.push(c);
    }
  } else {
    dest.push(c);
  }
};

json.compose = function(op1,op2) {
  json.checkValidOp(op1);
  json.checkValidOp(op2);

  var newOp = clone(op1);

  for (var i = 0; i < op2.length; i++) {
    json.append(newOp,op2[i]);
  }

  return newOp;
};

json.normalize = function(op) {
  var newOp = [];

  op = isArray(op) ? op : [op];

  for (var i = 0; i < op.length; i++) {
    var c = op[i];
    if (c.p == null) c.p = [];

    json.append(newOp,c);
  }

  return newOp;
};

// Returns true if an op at otherPath may affect an op at path
json.canOpAffectOp = function(otherPath,path) {
  if (otherPath.length === 0) return true;
  if (path.length === 0) return false;

  path = path.slice(0,path.length - 1);
  otherPath = otherPath.slice(0,otherPath.length - 1);

  for (var i = 0; i < otherPath.length; i++) {
    var p = otherPath[i];
    if (i >= path.length || p != path[i]) return false;
  }

  // Same
  return true;
};

// transform c so it applies to a document with otherC applied.
json.transformComponent = function(dest, c, otherC, type) {
  c = clone(c);

  if (c.na !== void 0)
    c.p.push(0);

  if (otherC.na !== void 0)
    otherC.p.push(0);

  var common;
  if (json.canOpAffectOp(otherC.p, c.p))
    common = otherC.p.length - 1;

  var common2;
  if (json.canOpAffectOp(c.p,otherC.p))
    common2 = c.p.length - 1;

  var cplength = c.p.length;
  var otherCplength = otherC.p.length;

  if (c.na !== void 0) // hax
    c.p.pop();

  if (otherC.na !== void 0)
    otherC.p.pop();

  if (otherC.na) {
    if (common2 != null && otherCplength >= cplength && otherC.p[common2] == c.p[common2]) {
      if (c.ld !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.ld = json.apply(clone(c.ld),[oc]);
      } else if (c.od !== void 0) {
        var oc = clone(otherC);
        oc.p = oc.p.slice(cplength);
        c.od = json.apply(clone(c.od),[oc]);
      }
    }
    json.append(dest,c);
    return dest;
  }

  // if c is deleting something, and that thing is changed by otherC, we need to
  // update c to reflect that change for invertibility.
  // TODO this is probably not needed since we don't have invertibility
  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {
    if (c.ld !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.ld = json.apply(clone(c.ld),[oc]);
    } else if (c.od !== void 0) {
      var oc = clone(otherC);
      oc.p = oc.p.slice(cplength);
      c.od = json.apply(clone(c.od),[oc]);
    }
  }

  if (common != null) {
    var commonOperand = cplength == otherCplength;

    // transform based on otherC
    if (otherC.na !== void 0) {
      // this case is handled above due to icky path hax
    } else if (otherC.si !== void 0 || otherC.sd !== void 0) {
      // String op vs string op - pass through to text type
      if (c.si !== void 0 || c.sd !== void 0) {
        if (!commonOperand) throw new Error('must be a string?');

        // Convert an op component to a text op component so we can use the
        // text type's transform function
        var tc1 = _convertToTextComponent(c);
        var tc2 = _convertToTextComponent(otherC);

        var res = [];

        // actually transform
        text._tc(res, tc1, tc2, type);
        
        // .... then convert the result back into a JSON op again.
        for (var i = 0; i < res.length; i++) {
          // Text component
          var tc = res[i];
          // JSON component
          var jc = {p: c.p.slice(0, common)};
          jc.p.push(tc.p);

          if (tc.i != null) jc.si = tc.i;
          if (tc.d != null) jc.sd = tc.d;
          json.append(dest, jc);
        }
        return dest;
      }
    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {
      if (otherC.p[common] === c.p[common]) {
        // noop

        if (!commonOperand) {
          return dest;
        } else if (c.ld !== void 0) {
          // we're trying to delete the same element, -> noop
          if (c.li !== void 0 && type === 'left') {
            // we're both replacing one element with another. only one can survive
            c.ld = clone(otherC.li);
          } else {
            return dest;
          }
        }
      }
    } else if (otherC.li !== void 0) {
      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {
        // in li vs. li, left wins.
        if (type === 'right')
          c.p[common]++;
      } else if (otherC.p[common] <= c.p[common]) {
        c.p[common]++;
      }

      if (c.lm !== void 0) {
        if (commonOperand) {
          // otherC edits the same list we edit
          if (otherC.p[common] <= c.lm)
            c.lm++;
          // changing c.from is handled above.
        }
      }
    } else if (otherC.ld !== void 0) {
      if (c.lm !== void 0) {
        if (commonOperand) {
          if (otherC.p[common] === c.p[common]) {
            // they deleted the thing we're trying to move
            return dest;
          }
          // otherC edits the same list we edit
          var p = otherC.p[common];
          var from = c.p[common];
          var to = c.lm;
          if (p < to || (p === to && from < to))
            c.lm--;

        }
      }

      if (otherC.p[common] < c.p[common]) {
        c.p[common]--;
      } else if (otherC.p[common] === c.p[common]) {
        if (otherCplength < cplength) {
          // we're below the deleted element, so -> noop
          return dest;
        } else if (c.ld !== void 0) {
          if (c.li !== void 0) {
            // we're replacing, they're deleting. we become an insert.
            delete c.ld;
          } else {
            // we're trying to delete the same element, -> noop
            return dest;
          }
        }
      }

    } else if (otherC.lm !== void 0) {
      if (c.lm !== void 0 && cplength === otherCplength) {
        // lm vs lm, here we go!
        var from = c.p[common];
        var to = c.lm;
        var otherFrom = otherC.p[common];
        var otherTo = otherC.lm;
        if (otherFrom !== otherTo) {
          // if otherFrom == otherTo, we don't need to change our op.

          // where did my thing go?
          if (from === otherFrom) {
            // they moved it! tie break.
            if (type === 'left') {
              c.p[common] = otherTo;
              if (from === to) // ugh
                c.lm = otherTo;
            } else {
              return dest;
            }
          } else {
            // they moved around it
            if (from > otherFrom) c.p[common]--;
            if (from > otherTo) c.p[common]++;
            else if (from === otherTo) {
              if (otherFrom > otherTo) {
                c.p[common]++;
                if (from === to) // ugh, again
                  c.lm++;
              }
            }

            // step 2: where am i going to put it?
            if (to > otherFrom) {
              c.lm--;
            } else if (to === otherFrom) {
              if (to > from)
                c.lm--;
            }
            if (to > otherTo) {
              c.lm++;
            } else if (to === otherTo) {
              // if we're both moving in the same direction, tie break
              if ((otherTo > otherFrom && to > from) ||
                  (otherTo < otherFrom && to < from)) {
                if (type === 'right') c.lm++;
              } else {
                if (to > from) c.lm++;
                else if (to === otherFrom) c.lm--;
              }
            }
          }
        }
      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {
        // li
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p > from) c.p[common]--;
        if (p > to) c.p[common]++;
      } else {
        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath
        // the lm
        //
        // i.e. things care about where their item is after the move.
        var from = otherC.p[common];
        var to = otherC.lm;
        p = c.p[common];
        if (p === from) {
          c.p[common] = to;
        } else {
          if (p > from) c.p[common]--;
          if (p > to) c.p[common]++;
          else if (p === to && from > to) c.p[common]++;
        }
      }
    }
    else if (otherC.oi !== void 0 && otherC.od !== void 0) {
      if (c.p[common] === otherC.p[common]) {
        if (c.oi !== void 0 && commonOperand) {
          // we inserted where someone else replaced
          if (type === 'right') {
            // left wins
            return dest;
          } else {
            // we win, make our op replace what they inserted
            c.od = otherC.oi;
          }
        } else {
          // -> noop if the other component is deleting the same object (or any parent)
          return dest;
        }
      }
    } else if (otherC.oi !== void 0) {
      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {
        // left wins if we try to insert at the same place
        if (type === 'left') {
          json.append(dest,{p: c.p, od:otherC.oi});
        } else {
          return dest;
        }
      }
    } else if (otherC.od !== void 0) {
      if (c.p[common] == otherC.p[common]) {
        if (!commonOperand)
          return dest;
        if (c.oi !== void 0) {
          delete c.od;
        } else {
          return dest;
        }
      }
    }
  }

  json.append(dest,c);
  return dest;
};

if (typeof require !== "undefined") {
  require('./helpers')._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);
} else {
  // This is kind of awful - come up with a better way to hook this helper code up.
  exports._bootstrapTransform(json, json.transformComponent, json.checkValidOp, json.append);
}

module.exports = json;

},{"./helpers":45,"./text-old":46}],45:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
exports._bootstrapTransform = function(type, transformComponent, checkValidOp, append) {
  var transformComponentX, transformX;

  transformComponentX = function(left, right, destLeft, destRight) {
    transformComponent(destLeft, left, right, 'left');
    return transformComponent(destRight, right, left, 'right');
  };
  type.transformX = type.transformX = transformX = function(leftOp, rightOp) {
    var k, l, l_, newLeftOp, newRightOp, nextC, r, r_, rightComponent, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;

    checkValidOp(leftOp);
    checkValidOp(rightOp);
    newRightOp = [];
    for (_i = 0, _len = rightOp.length; _i < _len; _i++) {
      rightComponent = rightOp[_i];
      newLeftOp = [];
      k = 0;
      while (k < leftOp.length) {
        nextC = [];
        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);
        k++;
        if (nextC.length === 1) {
          rightComponent = nextC[0];
        } else if (nextC.length === 0) {
          _ref = leftOp.slice(k);
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            l = _ref[_j];
            append(newLeftOp, l);
          }
          rightComponent = null;
          break;
        } else {
          _ref1 = transformX(leftOp.slice(k), nextC), l_ = _ref1[0], r_ = _ref1[1];
          for (_k = 0, _len2 = l_.length; _k < _len2; _k++) {
            l = l_[_k];
            append(newLeftOp, l);
          }
          for (_l = 0, _len3 = r_.length; _l < _len3; _l++) {
            r = r_[_l];
            append(newRightOp, r);
          }
          rightComponent = null;
          break;
        }
      }
      if (rightComponent != null) {
        append(newRightOp, rightComponent);
      }
      leftOp = newLeftOp;
    }
    return [leftOp, newRightOp];
  };
  return type.transform = type['transform'] = function(op, otherOp, type) {
    if (!(type === 'left' || type === 'right')) {
      throw new Error("type must be 'left' or 'right'");
    }
    if (otherOp.length === 0) {
      return op;
    }
    if (op.length === 1 && otherOp.length === 1) {
      return transformComponent([], op[0], otherOp[0], type);
    }
    if (type === 'left') {
      return transformX(op, otherOp)[0];
    } else {
      return transformX(otherOp, op)[1];
    }
  };
};

},{}],46:[function(require,module,exports){
// Generated by CoffeeScript 1.6.2
var append, checkValidComponent, checkValidOp, invertComponent, strInject, text, transformComponent, transformPosition;

text = {
  name: 'text-old',
  uri: 'http://sharejs.org/types/textv0',
  create: function() {
    return '';
  }
};

strInject = function(s1, pos, s2) {
  return s1.slice(0, pos) + s2 + s1.slice(pos);
};

checkValidComponent = function(c) {
  var d_type, i_type;

  if (typeof c.p !== 'number') {
    throw new Error('component missing position field');
  }
  i_type = typeof c.i;
  d_type = typeof c.d;
  if (!((i_type === 'string') ^ (d_type === 'string'))) {
    throw new Error('component needs an i or d field');
  }
  if (!(c.p >= 0)) {
    throw new Error('position cannot be negative');
  }
};

checkValidOp = function(op) {
  var c, _i, _len;

  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    checkValidComponent(c);
  }
  return true;
};

text.apply = function(snapshot, op) {
  var component, deleted, _i, _len;

  checkValidOp(op);
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    component = op[_i];
    if (component.i != null) {
      snapshot = strInject(snapshot, component.p, component.i);
    } else {
      deleted = snapshot.slice(component.p, component.p + component.d.length);
      if (component.d !== deleted) {
        throw new Error("Delete component '" + component.d + "' does not match deleted text '" + deleted + "'");
      }
      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);
    }
  }
  return snapshot;
};

text._append = append = function(newOp, c) {
  var last, _ref, _ref1;

  if (c.i === '' || c.d === '') {
    return;
  }
  if (newOp.length === 0) {
    return newOp.push(c);
  } else {
    last = newOp[newOp.length - 1];
    if ((last.i != null) && (c.i != null) && (last.p <= (_ref = c.p) && _ref <= (last.p + last.i.length))) {
      return newOp[newOp.length - 1] = {
        i: strInject(last.i, c.p - last.p, c.i),
        p: last.p
      };
    } else if ((last.d != null) && (c.d != null) && (c.p <= (_ref1 = last.p) && _ref1 <= (c.p + c.d.length))) {
      return newOp[newOp.length - 1] = {
        d: strInject(c.d, last.p - c.p, last.d),
        p: c.p
      };
    } else {
      return newOp.push(c);
    }
  }
};

text.compose = function(op1, op2) {
  var c, newOp, _i, _len;

  checkValidOp(op1);
  checkValidOp(op2);
  newOp = op1.slice();
  for (_i = 0, _len = op2.length; _i < _len; _i++) {
    c = op2[_i];
    append(newOp, c);
  }
  return newOp;
};

text.compress = function(op) {
  return text.compose([], op);
};

text.normalize = function(op) {
  var c, newOp, _i, _len, _ref;

  newOp = [];
  if ((op.i != null) || (op.p != null)) {
    op = [op];
  }
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    if ((_ref = c.p) == null) {
      c.p = 0;
    }
    append(newOp, c);
  }
  return newOp;
};

transformPosition = function(pos, c, insertAfter) {
  if (c.i != null) {
    if (c.p < pos || (c.p === pos && insertAfter)) {
      return pos + c.i.length;
    } else {
      return pos;
    }
  } else {
    if (pos <= c.p) {
      return pos;
    } else if (pos <= c.p + c.d.length) {
      return c.p;
    } else {
      return pos - c.d.length;
    }
  }
};

text.transformCursor = function(position, op, side) {
  var c, insertAfter, _i, _len;

  insertAfter = side === 'right';
  for (_i = 0, _len = op.length; _i < _len; _i++) {
    c = op[_i];
    position = transformPosition(position, c, insertAfter);
  }
  return position;
};

text._tc = transformComponent = function(dest, c, otherC, side) {
  var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;

  checkValidOp([c]);
  checkValidOp([otherC]);
  if (c.i != null) {
    append(dest, {
      i: c.i,
      p: transformPosition(c.p, otherC, side === 'right')
    });
  } else {
    if (otherC.i != null) {
      s = c.d;
      if (c.p < otherC.p) {
        append(dest, {
          d: s.slice(0, otherC.p - c.p),
          p: c.p
        });
        s = s.slice(otherC.p - c.p);
      }
      if (s !== '') {
        append(dest, {
          d: s,
          p: c.p + otherC.i.length
        });
      }
    } else {
      if (c.p >= otherC.p + otherC.d.length) {
        append(dest, {
          d: c.d,
          p: c.p - otherC.d.length
        });
      } else if (c.p + c.d.length <= otherC.p) {
        append(dest, c);
      } else {
        newC = {
          d: '',
          p: c.p
        };
        if (c.p < otherC.p) {
          newC.d = c.d.slice(0, otherC.p - c.p);
        }
        if (c.p + c.d.length > otherC.p + otherC.d.length) {
          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);
        }
        intersectStart = Math.max(c.p, otherC.p);
        intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);
        cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);
        otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);
        if (cIntersect !== otherIntersect) {
          throw new Error('Delete ops delete different text in the same region of the document');
        }
        if (newC.d !== '') {
          newC.p = transformPosition(newC.p, otherC);
          append(dest, newC);
        }
      }
    }
  }
  return dest;
};

invertComponent = function(c) {
  if (c.i != null) {
    return {
      d: c.i,
      p: c.p
    };
  } else {
    return {
      i: c.d,
      p: c.p
    };
  }
};

text.invert = function(op) {
  var c, _i, _len, _ref, _results;

  _ref = op.slice().reverse();
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    c = _ref[_i];
    _results.push(invertComponent(c));
  }
  return _results;
};

if (typeof require === 'undefined') {
  exports._bootstrapTransform(text, text.transformComponent, text.checkValidOp, text.append);
} else {
  require('./helpers')._bootstrapTransform(text, text.transformComponent, text.checkValidOp, text.append);
}

module.exports = text;

},{"./helpers":45}]},{},[1,3])
//@ sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vY2xpZW50LmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9saWIvaW5kZXguanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyLWJyb3dzZXJjaGFubmVsL2xpYi9icm93c2VyLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvYnVpbHRpbi9ldmVudHMuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyLWJyb3dzZXJjaGFubmVsL25vZGVfbW9kdWxlcy9icm93c2VyY2hhbm5lbC9kaXN0L2Jjc29ja2V0LXVuY29tcHJlc3NlZC5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbGliL1JhY2VyLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9saWIvdXRpbC5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL3BhdGhzLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvZXZlbnRzLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvY29sbGVjdGlvbnMuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9tdXRhdG9ycy5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL3N1YnNjcmlwdGlvbnMuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9jb250ZXh0cy5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL2ZuLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvZmlsdGVyLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvcmVmTGlzdC5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL3JlZi5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2RlZXAtaXMvaW5kZXguanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9pbmRleC5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL2RlZmF1bHRGbnMuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvYnVmZmVyLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvbm9kZS11dWlkL3V1aWQuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9DaGFubmVsLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvTG9jYWxEb2MuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9SZW1vdGVEb2MuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL2xpYi9Nb2RlbC9jb25uZWN0aW9uLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvRG9jLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9saWIvTW9kZWwvc2V0RGlmZi5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsL1F1ZXJ5LmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9pbmRleC5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2FycmF5ZGlmZi9pbmRleC5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9ub2RlX21vZHVsZXMvY3J5cHRvLWJyb3dzZXJpZnkvc2hhLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL25vZGVfbW9kdWxlcy9jcnlwdG8tYnJvd3NlcmlmeS9ybmcuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXJlc29sdmUvbm9kZV9tb2R1bGVzL2NyeXB0by1icm93c2VyaWZ5L21kNS5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL2xpYi9jbGllbnQvaW5kZXguanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9saWIvY2xpZW50L21pY3JvZXZlbnQuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9saWIvY2xpZW50L3F1ZXJ5LmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbGliL2NsaWVudC9jb25uZWN0aW9uLmpzIiwiL1VzZXJzL3B3aW50ZXJzL0RldmVsb3BtZW50L2RpdHRvL25vZGVfbW9kdWxlcy9yYWNlci9ub2RlX21vZHVsZXMvc2hhcmUvbGliL2NsaWVudC9kb2MuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9ub2RlX21vZHVsZXMvb3R0eXBlcy9saWIvaW5kZXguanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9ub2RlX21vZHVsZXMvb3R0eXBlcy9saWIvdGV4dC5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL25vZGVfbW9kdWxlcy9vdHR5cGVzL2xpYi9zaW1wbGUuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9ub2RlX21vZHVsZXMvb3R0eXBlcy9saWIvdGV4dC10cDIuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9ub2RlX21vZHVsZXMvb3R0eXBlcy9saWIvanNvbjAuanMiLCIvVXNlcnMvcHdpbnRlcnMvRGV2ZWxvcG1lbnQvZGl0dG8vbm9kZV9tb2R1bGVzL3JhY2VyL25vZGVfbW9kdWxlcy9zaGFyZS9ub2RlX21vZHVsZXMvb3R0eXBlcy9saWIvaGVscGVycy5qcyIsIi9Vc2Vycy9wd2ludGVycy9EZXZlbG9wbWVudC9kaXR0by9ub2RlX21vZHVsZXMvcmFjZXIvbm9kZV9tb2R1bGVzL3NoYXJlL25vZGVfbW9kdWxlcy9vdHR5cGVzL2xpYi90ZXh0LW9sZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7Ozs7QUNBQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaG9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2eEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWUE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwNEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNub0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6W251bGwsInZhciBSYWNlciA9IHJlcXVpcmUoJy4vUmFjZXInKTtcbm1vZHVsZS5leHBvcnRzID0gbmV3IFJhY2VyO1xuIiwidmFyIHJhY2VyID0gcmVxdWlyZSgncmFjZXInKTtcbnZhciBCQ1NvY2tldCA9IHJlcXVpcmUoJ2Jyb3dzZXJjaGFubmVsL2Rpc3QvYmNzb2NrZXQtdW5jb21wcmVzc2VkJykuQkNTb2NrZXQ7XG5cbnJhY2VyLk1vZGVsLnByb3RvdHlwZS5fY3JlYXRlU29ja2V0ID0gZnVuY3Rpb24oYnVuZGxlKSB7XG4gIHZhciBvcHRpb25zID0gYnVuZGxlLnJhY2VyQnJvd3NlckNoYW5uZWw7XG4gIHZhciBiYXNlID0gb3B0aW9ucy5iYXNlIHx8ICcvY2hhbm5lbCc7XG4gIGlmIChidW5kbGUubW91bnQpIGJhc2UgPSBidW5kbGUubW91bnQgKyBiYXNlO1xuICByZXR1cm4gbmV3IEJDU29ja2V0KGJhc2UsIG9wdGlvbnMpO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYuc291cmNlID09PSB3aW5kb3cgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe2lmICghcHJvY2Vzcy5FdmVudEVtaXR0ZXIpIHByb2Nlc3MuRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBFdmVudEVtaXR0ZXIgPSBleHBvcnRzLkV2ZW50RW1pdHRlciA9IHByb2Nlc3MuRXZlbnRFbWl0dGVyO1xudmFyIGlzQXJyYXkgPSB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gQXJyYXkuaXNBcnJheVxuICAgIDogZnVuY3Rpb24gKHhzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgfVxuO1xuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeCA9PT0geHNbaV0pIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW5cbi8vIDEwIGxpc3RlbmVycyBhcmUgYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaFxuLy8gaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG4vL1xuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzID0gbjtcbn07XG5cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNBcnJheSh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSlcbiAgICB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gZmFsc2U7XG4gIHZhciBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBpZiAoIWhhbmRsZXIpIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAoaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBFdmVudEVtaXR0ZXIgaXMgZGVmaW5lZCBpbiBzcmMvbm9kZV9ldmVudHMuY2Ncbi8vIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCgpIGlzIGFsc28gZGVmaW5lZCB0aGVyZS5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdhZGRMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT0gXCJuZXdMaXN0ZW5lcnNcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJzXCIuXG4gIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgfSBlbHNlIGlmIChpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgICB2YXIgbTtcbiAgICAgIGlmICh0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbSA9IHRoaXMuX2V2ZW50cy5tYXhMaXN0ZW5lcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtID0gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYub24odHlwZSwgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgbGlzdGVuZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUxpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzQXJyYXkobGlzdCkpIHtcbiAgICB2YXIgaSA9IGluZGV4T2YobGlzdCwgbGlzdGVuZXIpO1xuICAgIGlmIChpIDwgMCkgcmV0dXJuIHRoaXM7XG4gICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgaWYgKGxpc3QubGVuZ3RoID09IDApXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICB9IGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gbGlzdGVuZXIpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGRvZXMgbm90IHVzZSBsaXN0ZW5lcnMoKSwgc28gbm8gc2lkZSBlZmZlY3Qgb2YgY3JlYXRpbmcgX2V2ZW50c1t0eXBlXVxuICBpZiAodHlwZSAmJiB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB0aGlzLl9ldmVudHNbdHlwZV0gPSBbXTtcbiAgaWYgKCFpc0FycmF5KHRoaXMuX2V2ZW50c1t0eXBlXSkpIHtcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZXZlbnRzW3R5cGVdO1xufTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9wcm9jZXNzXCIpKSIsIihmdW5jdGlvbigpe1xuZnVuY3Rpb24gZShhKSB7XG4gIHRocm93IGE7XG59XG52YXIgaCA9IHZvaWQgMCwgbCA9ICEwLCBtID0gbnVsbCwgciA9ICExO1xuZnVuY3Rpb24gcygpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICB9XG59XG5mdW5jdGlvbiB0KGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGIpIHtcbiAgICB0aGlzW2FdID0gYlxuICB9XG59XG5mdW5jdGlvbiBhYShhKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpc1thXVxuICB9XG59XG5mdW5jdGlvbiBiYShhKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYVxuICB9XG59XG52YXIgdSwgY2EgPSBjYSB8fCB7fSwgdyA9IHRoaXM7XG5mdW5jdGlvbiBkYShhKSB7XG4gIGEgPSBhLnNwbGl0KFwiLlwiKTtcbiAgZm9yKHZhciBiID0gdywgYztjID0gYS5zaGlmdCgpOykge1xuICAgIGlmKGJbY10gIT0gbSkge1xuICAgICAgYiA9IGJbY11cbiAgICB9ZWxzZSB7XG4gICAgICByZXR1cm4gbVxuICAgIH1cbiAgfVxuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gZWEoKSB7XG59XG5mdW5jdGlvbiBmYShhKSB7XG4gIHZhciBiID0gdHlwZW9mIGE7XG4gIGlmKFwib2JqZWN0XCIgPT0gYikge1xuICAgIGlmKGEpIHtcbiAgICAgIGlmKGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXR1cm5cImFycmF5XCJcbiAgICAgIH1cbiAgICAgIGlmKGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJcbiAgICAgIH1cbiAgICAgIHZhciBjID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO1xuICAgICAgaWYoXCJbb2JqZWN0IFdpbmRvd11cIiA9PSBjKSB7XG4gICAgICAgIHJldHVyblwib2JqZWN0XCJcbiAgICAgIH1cbiAgICAgIGlmKFwiW29iamVjdCBBcnJheV1cIiA9PSBjIHx8IFwibnVtYmVyXCIgPT0gdHlwZW9mIGEubGVuZ3RoICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGEuc3BsaWNlICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGEucHJvcGVydHlJc0VudW1lcmFibGUgJiYgIWEucHJvcGVydHlJc0VudW1lcmFibGUoXCJzcGxpY2VcIikpIHtcbiAgICAgICAgcmV0dXJuXCJhcnJheVwiXG4gICAgICB9XG4gICAgICBpZihcIltvYmplY3QgRnVuY3Rpb25dXCIgPT0gYyB8fCBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBhLmNhbGwgJiYgXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgYS5wcm9wZXJ0eUlzRW51bWVyYWJsZSAmJiAhYS5wcm9wZXJ0eUlzRW51bWVyYWJsZShcImNhbGxcIikpIHtcbiAgICAgICAgcmV0dXJuXCJmdW5jdGlvblwiXG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgcmV0dXJuXCJudWxsXCJcbiAgICB9XG4gIH1lbHNlIHtcbiAgICBpZihcImZ1bmN0aW9uXCIgPT0gYiAmJiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBhLmNhbGwpIHtcbiAgICAgIHJldHVyblwib2JqZWN0XCJcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIHgoYSkge1xuICByZXR1cm5cImFycmF5XCIgPT0gZmEoYSlcbn1cbmZ1bmN0aW9uIGdhKGEpIHtcbiAgdmFyIGIgPSBmYShhKTtcbiAgcmV0dXJuXCJhcnJheVwiID09IGIgfHwgXCJvYmplY3RcIiA9PSBiICYmIFwibnVtYmVyXCIgPT0gdHlwZW9mIGEubGVuZ3RoXG59XG5mdW5jdGlvbiB6KGEpIHtcbiAgcmV0dXJuXCJzdHJpbmdcIiA9PSB0eXBlb2YgYVxufVxuZnVuY3Rpb24gaGEoYSkge1xuICByZXR1cm5cImZ1bmN0aW9uXCIgPT0gZmEoYSlcbn1cbmZ1bmN0aW9uIEEoYSkge1xuICByZXR1cm4gYVtpYV0gfHwgKGFbaWFdID0gKytqYSlcbn1cbnZhciBpYSA9IFwiY2xvc3VyZV91aWRfXCIgKyAoMUU5ICogTWF0aC5yYW5kb20oKSA+Pj4gMCksIGphID0gMDtcbmZ1bmN0aW9uIGthKGEsIGIsIGMpIHtcbiAgcmV0dXJuIGEuY2FsbC5hcHBseShhLmJpbmQsIGFyZ3VtZW50cylcbn1cbmZ1bmN0aW9uIGxhKGEsIGIsIGMpIHtcbiAgYSB8fCBlKEVycm9yKCkpO1xuICBpZigyIDwgYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHZhciBkID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjLCBkKTtcbiAgICAgIHJldHVybiBhLmFwcGx5KGIsIGMpXG4gICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYS5hcHBseShiLCBhcmd1bWVudHMpXG4gIH1cbn1cbmZ1bmN0aW9uIEIoYSwgYiwgYykge1xuICBCID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgJiYgLTEgIT0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQudG9TdHJpbmcoKS5pbmRleE9mKFwibmF0aXZlIGNvZGVcIikgPyBrYSA6IGxhO1xuICByZXR1cm4gQi5hcHBseShtLCBhcmd1bWVudHMpXG59XG52YXIgQyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICByZXR1cm4rbmV3IERhdGVcbn07XG5mdW5jdGlvbiBEKGEsIGIpIHtcbiAgZnVuY3Rpb24gYygpIHtcbiAgfVxuICBjLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnFhID0gYi5wcm90b3R5cGU7XG4gIGEucHJvdG90eXBlID0gbmV3IGNcbn1cbjtmdW5jdGlvbiBtYShhLCBiKSB7XG4gIGZvcih2YXIgYyA9IDE7YyA8IGFyZ3VtZW50cy5sZW5ndGg7YysrKSB7XG4gICAgdmFyIGQgPSBTdHJpbmcoYXJndW1lbnRzW2NdKS5yZXBsYWNlKC9cXCQvZywgXCIkJCQkXCIpO1xuICAgIGEgPSBhLnJlcGxhY2UoL1xcJXMvLCBkKVxuICB9XG4gIHJldHVybiBhXG59XG5mdW5jdGlvbiBuYShhKSB7XG4gIGlmKCFvYS50ZXN0KGEpKSB7XG4gICAgcmV0dXJuIGFcbiAgfVxuICAtMSAhPSBhLmluZGV4T2YoXCImXCIpICYmIChhID0gYS5yZXBsYWNlKHBhLCBcIiZhbXA7XCIpKTtcbiAgLTEgIT0gYS5pbmRleE9mKFwiPFwiKSAmJiAoYSA9IGEucmVwbGFjZShxYSwgXCImbHQ7XCIpKTtcbiAgLTEgIT0gYS5pbmRleE9mKFwiPlwiKSAmJiAoYSA9IGEucmVwbGFjZShyYSwgXCImZ3Q7XCIpKTtcbiAgLTEgIT0gYS5pbmRleE9mKCdcIicpICYmIChhID0gYS5yZXBsYWNlKHNhLCBcIiZxdW90O1wiKSk7XG4gIHJldHVybiBhXG59XG52YXIgcGEgPSAvJi9nLCBxYSA9IC88L2csIHJhID0gLz4vZywgc2EgPSAvXFxcIi9nLCBvYSA9IC9bJjw+XFxcIl0vO1xudmFyIHRhLCB1YSwgdmEsIHdhO1xuZnVuY3Rpb24geGEoKSB7XG4gIHJldHVybiB3Lm5hdmlnYXRvciA/IHcubmF2aWdhdG9yLnVzZXJBZ2VudCA6IG1cbn1cbndhID0gdmEgPSB1YSA9IHRhID0gcjtcbnZhciB5YTtcbmlmKHlhID0geGEoKSkge1xuICB2YXIgemEgPSB3Lm5hdmlnYXRvcjtcbiAgdGEgPSAwID09IHlhLmluZGV4T2YoXCJPcGVyYVwiKTtcbiAgdWEgPSAhdGEgJiYgLTEgIT0geWEuaW5kZXhPZihcIk1TSUVcIik7XG4gIHZhID0gIXRhICYmIC0xICE9IHlhLmluZGV4T2YoXCJXZWJLaXRcIik7XG4gIHdhID0gIXRhICYmICF2YSAmJiBcIkdlY2tvXCIgPT0gemEucHJvZHVjdFxufVxudmFyIEFhID0gdGEsIEUgPSB1YSwgQmEgPSB3YSwgRiA9IHZhLCBDYSA9IHcubmF2aWdhdG9yLCBEYSA9IC0xICE9IChDYSAmJiBDYS5wbGF0Zm9ybSB8fCBcIlwiKS5pbmRleE9mKFwiTWFjXCIpO1xuZnVuY3Rpb24gRWEoKSB7XG4gIHZhciBhID0gdy5kb2N1bWVudDtcbiAgcmV0dXJuIGEgPyBhLmRvY3VtZW50TW9kZSA6IGhcbn1cbnZhciBGYTtcbmE6IHtcbiAgdmFyIEdhID0gXCJcIiwgSGE7XG4gIGlmKEFhICYmIHcub3BlcmEpIHtcbiAgICB2YXIgSWEgPSB3Lm9wZXJhLnZlcnNpb24sIEdhID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBJYSA/IElhKCkgOiBJYVxuICB9ZWxzZSB7XG4gICAgaWYoQmEgPyBIYSA9IC9ydlxcOihbXlxcKTtdKykoXFwpfDspLyA6IEUgPyBIYSA9IC9NU0lFXFxzKyhbXlxcKTtdKykoXFwpfDspLyA6IEYgJiYgKEhhID0gL1dlYktpdFxcLyhcXFMrKS8pLCBIYSkge1xuICAgICAgdmFyIEphID0gSGEuZXhlYyh4YSgpKSwgR2EgPSBKYSA/IEphWzFdIDogXCJcIlxuICAgIH1cbiAgfVxuICBpZihFKSB7XG4gICAgdmFyIEthID0gRWEoKTtcbiAgICBpZihLYSA+IHBhcnNlRmxvYXQoR2EpKSB7XG4gICAgICBGYSA9IFN0cmluZyhLYSk7XG4gICAgICBicmVhayBhXG4gICAgfVxuICB9XG4gIEZhID0gR2Fcbn1cbnZhciBMYSA9IHt9O1xuZnVuY3Rpb24gRyhhKSB7XG4gIHZhciBiO1xuICBpZighKGIgPSBMYVthXSkpIHtcbiAgICBiID0gMDtcbiAgICBmb3IodmFyIGMgPSBTdHJpbmcoRmEpLnJlcGxhY2UoL15bXFxzXFx4YTBdK3xbXFxzXFx4YTBdKyQvZywgXCJcIikuc3BsaXQoXCIuXCIpLCBkID0gU3RyaW5nKGEpLnJlcGxhY2UoL15bXFxzXFx4YTBdK3xbXFxzXFx4YTBdKyQvZywgXCJcIikuc3BsaXQoXCIuXCIpLCBmID0gTWF0aC5tYXgoYy5sZW5ndGgsIGQubGVuZ3RoKSwgZyA9IDA7MCA9PSBiICYmIGcgPCBmO2crKykge1xuICAgICAgdmFyIGsgPSBjW2ddIHx8IFwiXCIsIHEgPSBkW2ddIHx8IFwiXCIsIG4gPSBSZWdFeHAoXCIoXFxcXGQqKShcXFxcRCopXCIsIFwiZ1wiKSwgeSA9IFJlZ0V4cChcIihcXFxcZCopKFxcXFxEKilcIiwgXCJnXCIpO1xuICAgICAgZG8ge1xuICAgICAgICB2YXIgcCA9IG4uZXhlYyhrKSB8fCBbXCJcIiwgXCJcIiwgXCJcIl0sIHYgPSB5LmV4ZWMocSkgfHwgW1wiXCIsIFwiXCIsIFwiXCJdO1xuICAgICAgICBpZigwID09IHBbMF0ubGVuZ3RoICYmIDAgPT0gdlswXS5sZW5ndGgpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGIgPSAoKDAgPT0gcFsxXS5sZW5ndGggPyAwIDogcGFyc2VJbnQocFsxXSwgMTApKSA8ICgwID09IHZbMV0ubGVuZ3RoID8gMCA6IHBhcnNlSW50KHZbMV0sIDEwKSkgPyAtMSA6ICgwID09IHBbMV0ubGVuZ3RoID8gMCA6IHBhcnNlSW50KHBbMV0sIDEwKSkgPiAoMCA9PSB2WzFdLmxlbmd0aCA/IDAgOiBwYXJzZUludCh2WzFdLCAxMCkpID8gMSA6IDApIHx8ICgoMCA9PSBwWzJdLmxlbmd0aCkgPCAoMCA9PSB2WzJdLmxlbmd0aCkgPyAtMSA6ICgwID09IHBbMl0ubGVuZ3RoKSA+ICgwID09IHZbMl0ubGVuZ3RoKSA/IDEgOiAwKSB8fCAocFsyXSA8IHZbMl0gPyAtMSA6IHBbMl0gPiB2WzJdID8gMSA6IDApXG4gICAgICB9d2hpbGUoMCA9PSBiKVxuICAgIH1cbiAgICBiID0gTGFbYV0gPSAwIDw9IGJcbiAgfVxuICByZXR1cm4gYlxufVxudmFyIE1hID0gdy5kb2N1bWVudCwgTmEgPSAhTWEgfHwgIUUgPyBoIDogRWEoKSB8fCAoXCJDU1MxQ29tcGF0XCIgPT0gTWEuY29tcGF0TW9kZSA/IHBhcnNlSW50KEZhLCAxMCkgOiA1KTtcbmZ1bmN0aW9uIE9hKGEpIHtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBPYSkgOiB0aGlzLnN0YWNrID0gRXJyb3IoKS5zdGFjayB8fCBcIlwiO1xuICBhICYmICh0aGlzLm1lc3NhZ2UgPSBTdHJpbmcoYSkpXG59XG5EKE9hLCBFcnJvcik7XG5PYS5wcm90b3R5cGUubmFtZSA9IFwiQ3VzdG9tRXJyb3JcIjtcbmZ1bmN0aW9uIFBhKGEsIGIpIHtcbiAgYi51bnNoaWZ0KGEpO1xuICBPYS5jYWxsKHRoaXMsIG1hLmFwcGx5KG0sIGIpKTtcbiAgYi5zaGlmdCgpO1xuICB0aGlzLkljID0gYVxufVxuRChQYSwgT2EpO1xuUGEucHJvdG90eXBlLm5hbWUgPSBcIkFzc2VydGlvbkVycm9yXCI7XG5mdW5jdGlvbiBRYShhLCBiKSB7XG4gIGUobmV3IFBhKFwiRmFpbHVyZVwiICsgKGEgPyBcIjogXCIgKyBhIDogXCJcIiksIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKVxufVxuO3ZhciBSYSA9IFJlZ0V4cChcIl4oPzooW146Lz8jLl0rKTopPyg/Oi8vKD86KFteLz8jXSopQCk/KFteLyM/XSo/KSg/OjooWzAtOV0rKSk/KD89Wy8jP118JCkpPyhbXj8jXSspPyg/OlxcXFw/KFteI10qKSk/KD86IyguKikpPyRcIik7XG5mdW5jdGlvbiBTYShhKSB7XG4gIHZhciBiID0gVGEsIGM7XG4gIGZvcihjIGluIGIpIHtcbiAgICBhLmNhbGwoaCwgYltjXSwgYywgYilcbiAgfVxufVxuZnVuY3Rpb24gVWEoYSkge1xuICB2YXIgYiA9IFtdLCBjID0gMCwgZDtcbiAgZm9yKGQgaW4gYSkge1xuICAgIGJbYysrXSA9IGFbZF1cbiAgfVxuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gVmEoYSkge1xuICB2YXIgYiA9IFtdLCBjID0gMCwgZDtcbiAgZm9yKGQgaW4gYSkge1xuICAgIGJbYysrXSA9IGRcbiAgfVxuICByZXR1cm4gYlxufVxudmFyIFdhID0gXCJjb25zdHJ1Y3RvciBoYXNPd25Qcm9wZXJ0eSBpc1Byb3RvdHlwZU9mIHByb3BlcnR5SXNFbnVtZXJhYmxlIHRvTG9jYWxlU3RyaW5nIHRvU3RyaW5nIHZhbHVlT2ZcIi5zcGxpdChcIiBcIik7XG5mdW5jdGlvbiBYYShhLCBiKSB7XG4gIGZvcih2YXIgYywgZCwgZiA9IDE7ZiA8IGFyZ3VtZW50cy5sZW5ndGg7ZisrKSB7XG4gICAgZCA9IGFyZ3VtZW50c1tmXTtcbiAgICBmb3IoYyBpbiBkKSB7XG4gICAgICBhW2NdID0gZFtjXVxuICAgIH1cbiAgICBmb3IodmFyIGcgPSAwO2cgPCBXYS5sZW5ndGg7ZysrKSB7XG4gICAgICBjID0gV2FbZ10sIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkLCBjKSAmJiAoYVtjXSA9IGRbY10pXG4gICAgfVxuICB9XG59XG47dmFyIEggPSBBcnJheS5wcm90b3R5cGUsIFlhID0gSC5pbmRleE9mID8gZnVuY3Rpb24oYSwgYiwgYykge1xuICByZXR1cm4gSC5pbmRleE9mLmNhbGwoYSwgYiwgYylcbn0gOiBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIGMgPSBjID09IG0gPyAwIDogMCA+IGMgPyBNYXRoLm1heCgwLCBhLmxlbmd0aCArIGMpIDogYztcbiAgaWYoeihhKSkge1xuICAgIHJldHVybiF6KGIpIHx8IDEgIT0gYi5sZW5ndGggPyAtMSA6IGEuaW5kZXhPZihiLCBjKVxuICB9XG4gIGZvcig7YyA8IGEubGVuZ3RoO2MrKykge1xuICAgIGlmKGMgaW4gYSAmJiBhW2NdID09PSBiKSB7XG4gICAgICByZXR1cm4gY1xuICAgIH1cbiAgfVxuICByZXR1cm4tMVxufSwgWmEgPSBILmZvckVhY2ggPyBmdW5jdGlvbihhLCBiLCBjKSB7XG4gIEguZm9yRWFjaC5jYWxsKGEsIGIsIGMpXG59IDogZnVuY3Rpb24oYSwgYiwgYykge1xuICBmb3IodmFyIGQgPSBhLmxlbmd0aCwgZiA9IHooYSkgPyBhLnNwbGl0KFwiXCIpIDogYSwgZyA9IDA7ZyA8IGQ7ZysrKSB7XG4gICAgZyBpbiBmICYmIGIuY2FsbChjLCBmW2ddLCBnLCBhKVxuICB9XG59O1xuZnVuY3Rpb24gJGEoYSkge1xuICByZXR1cm4gSC5jb25jYXQuYXBwbHkoSCwgYXJndW1lbnRzKVxufVxuZnVuY3Rpb24gYWIoYSkge1xuICB2YXIgYiA9IGEubGVuZ3RoO1xuICBpZigwIDwgYikge1xuICAgIGZvcih2YXIgYyA9IEFycmF5KGIpLCBkID0gMDtkIDwgYjtkKyspIHtcbiAgICAgIGNbZF0gPSBhW2RdXG4gICAgfVxuICAgIHJldHVybiBjXG4gIH1cbiAgcmV0dXJuW11cbn1cbjtmdW5jdGlvbiBiYihhKSB7XG4gIGlmKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYS5NKSB7XG4gICAgcmV0dXJuIGEuTSgpXG4gIH1cbiAgaWYoeihhKSkge1xuICAgIHJldHVybiBhLnNwbGl0KFwiXCIpXG4gIH1cbiAgaWYoZ2EoYSkpIHtcbiAgICBmb3IodmFyIGIgPSBbXSwgYyA9IGEubGVuZ3RoLCBkID0gMDtkIDwgYztkKyspIHtcbiAgICAgIGIucHVzaChhW2RdKVxuICAgIH1cbiAgICByZXR1cm4gYlxuICB9XG4gIHJldHVybiBVYShhKVxufVxuZnVuY3Rpb24gY2IoYSwgYiwgYykge1xuICBpZihcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEuZm9yRWFjaCkge1xuICAgIGEuZm9yRWFjaChiLCBjKVxuICB9ZWxzZSB7XG4gICAgaWYoZ2EoYSkgfHwgeihhKSkge1xuICAgICAgWmEoYSwgYiwgYylcbiAgICB9ZWxzZSB7XG4gICAgICB2YXIgZDtcbiAgICAgIGlmKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYS5qYSkge1xuICAgICAgICBkID0gYS5qYSgpXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIGlmKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgYS5NKSB7XG4gICAgICAgICAgaWYoZ2EoYSkgfHwgeihhKSkge1xuICAgICAgICAgICAgZCA9IFtdO1xuICAgICAgICAgICAgZm9yKHZhciBmID0gYS5sZW5ndGgsIGcgPSAwO2cgPCBmO2crKykge1xuICAgICAgICAgICAgICBkLnB1c2goZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICBkID0gVmEoYSlcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICBkID0gaFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IodmFyIGYgPSBiYihhKSwgZyA9IGYubGVuZ3RoLCBrID0gMDtrIDwgZztrKyspIHtcbiAgICAgICAgYi5jYWxsKGMsIGZba10sIGQgJiYgZFtrXSwgYSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjtmdW5jdGlvbiBkYihhLCBiKSB7XG4gIHRoaXMuTiA9IHt9O1xuICB0aGlzLmogPSBbXTtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoO1xuICBpZigxIDwgYykge1xuICAgIGMgJSAyICYmIGUoRXJyb3IoXCJVbmV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50c1wiKSk7XG4gICAgZm9yKHZhciBkID0gMDtkIDwgYztkICs9IDIpIHtcbiAgICAgIHRoaXMuc2V0KGFyZ3VtZW50c1tkXSwgYXJndW1lbnRzW2QgKyAxXSlcbiAgICB9XG4gIH1lbHNlIHtcbiAgICBpZihhKSB7XG4gICAgICBhIGluc3RhbmNlb2YgZGIgPyAoYyA9IGEuamEoKSwgZCA9IGEuTSgpKSA6IChjID0gVmEoYSksIGQgPSBVYShhKSk7XG4gICAgICBmb3IodmFyIGYgPSAwO2YgPCBjLmxlbmd0aDtmKyspIHtcbiAgICAgICAgdGhpcy5zZXQoY1tmXSwgZFtmXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbnUgPSBkYi5wcm90b3R5cGU7XG51LmYgPSAwO1xudS5hYyA9IDA7XG51Lk0gPSBmdW5jdGlvbigpIHtcbiAgZWIodGhpcyk7XG4gIGZvcih2YXIgYSA9IFtdLCBiID0gMDtiIDwgdGhpcy5qLmxlbmd0aDtiKyspIHtcbiAgICBhLnB1c2godGhpcy5OW3RoaXMualtiXV0pXG4gIH1cbiAgcmV0dXJuIGFcbn07XG51LmphID0gZnVuY3Rpb24oKSB7XG4gIGViKHRoaXMpO1xuICByZXR1cm4gdGhpcy5qLmNvbmNhdCgpXG59O1xudS5oYSA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIGZiKHRoaXMuTiwgYSlcbn07XG51LnJlbW92ZSA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIGZiKHRoaXMuTiwgYSkgPyAoZGVsZXRlIHRoaXMuTlthXSwgdGhpcy5mLS0sIHRoaXMuYWMrKywgdGhpcy5qLmxlbmd0aCA+IDIgKiB0aGlzLmYgJiYgZWIodGhpcyksIGwpIDogclxufTtcbmZ1bmN0aW9uIGViKGEpIHtcbiAgaWYoYS5mICE9IGEuai5sZW5ndGgpIHtcbiAgICBmb3IodmFyIGIgPSAwLCBjID0gMDtiIDwgYS5qLmxlbmd0aDspIHtcbiAgICAgIHZhciBkID0gYS5qW2JdO1xuICAgICAgZmIoYS5OLCBkKSAmJiAoYS5qW2MrK10gPSBkKTtcbiAgICAgIGIrK1xuICAgIH1cbiAgICBhLmoubGVuZ3RoID0gY1xuICB9XG4gIGlmKGEuZiAhPSBhLmoubGVuZ3RoKSB7XG4gICAgZm9yKHZhciBmID0ge30sIGMgPSBiID0gMDtiIDwgYS5qLmxlbmd0aDspIHtcbiAgICAgIGQgPSBhLmpbYl0sIGZiKGYsIGQpIHx8IChhLmpbYysrXSA9IGQsIGZbZF0gPSAxKSwgYisrXG4gICAgfVxuICAgIGEuai5sZW5ndGggPSBjXG4gIH1cbn1cbnUuZ2V0ID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gZmIodGhpcy5OLCBhKSA/IHRoaXMuTlthXSA6IGJcbn07XG51LnNldCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgZmIodGhpcy5OLCBhKSB8fCAodGhpcy5mKyssIHRoaXMuai5wdXNoKGEpLCB0aGlzLmFjKyspO1xuICB0aGlzLk5bYV0gPSBiXG59O1xudS5uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgZGIodGhpcylcbn07XG5mdW5jdGlvbiBmYihhLCBiKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYilcbn1cbjtmdW5jdGlvbiBJKGEsIGIpIHtcbiAgdmFyIGM7XG4gIGlmKGEgaW5zdGFuY2VvZiBJKSB7XG4gICAgdGhpcy5DID0gYiAhPT0gaCA/IGIgOiBhLkMsIGdiKHRoaXMsIGEucGEpLCBjID0gYS4kYSwgSih0aGlzKSwgdGhpcy4kYSA9IGggPyBjID8gZGVjb2RlVVJJQ29tcG9uZW50KGMpIDogXCJcIiA6IGMsIGhiKHRoaXMsIGEuaWEpLCBpYih0aGlzLCBhLkFhKSwgamIodGhpcywgYS5HKSwga2IodGhpcywgYS5RLm4oKSksIGMgPSBhLkxhLCBKKHRoaXMpLCB0aGlzLkxhID0gaCA/IGMgPyBkZWNvZGVVUklDb21wb25lbnQoYykgOiBcIlwiIDogY1xuICB9ZWxzZSB7XG4gICAgaWYoYSAmJiAoYyA9IFN0cmluZyhhKS5tYXRjaChSYSkpKSB7XG4gICAgICB0aGlzLkMgPSAhIWI7XG4gICAgICBnYih0aGlzLCBjWzFdIHx8IFwiXCIsIGwpO1xuICAgICAgdmFyIGQgPSBjWzJdIHx8IFwiXCI7XG4gICAgICBKKHRoaXMpO1xuICAgICAgdGhpcy4kYSA9IGwgPyBkID8gZGVjb2RlVVJJQ29tcG9uZW50KGQpIDogXCJcIiA6IGQ7XG4gICAgICBoYih0aGlzLCBjWzNdIHx8IFwiXCIsIGwpO1xuICAgICAgaWIodGhpcywgY1s0XSk7XG4gICAgICBqYih0aGlzLCBjWzVdIHx8IFwiXCIsIGwpO1xuICAgICAga2IodGhpcywgY1s2XSB8fCBcIlwiLCBsKTtcbiAgICAgIGMgPSBjWzddIHx8IFwiXCI7XG4gICAgICBKKHRoaXMpO1xuICAgICAgdGhpcy5MYSA9IGwgPyBjID8gZGVjb2RlVVJJQ29tcG9uZW50KGMpIDogXCJcIiA6IGNcbiAgICB9ZWxzZSB7XG4gICAgICB0aGlzLkMgPSAhIWIsIHRoaXMuUSA9IG5ldyBsYihtLCAwLCB0aGlzLkMpXG4gICAgfVxuICB9XG59XG51ID0gSS5wcm90b3R5cGU7XG51LnBhID0gXCJcIjtcbnUuJGEgPSBcIlwiO1xudS5pYSA9IFwiXCI7XG51LkFhID0gbTtcbnUuRyA9IFwiXCI7XG51LkxhID0gXCJcIjtcbnUubGMgPSByO1xudS5DID0gcjtcbnUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGEgPSBbXSwgYiA9IHRoaXMucGE7XG4gIGIgJiYgYS5wdXNoKG1iKGIsIG5iKSwgXCI6XCIpO1xuICBpZihiID0gdGhpcy5pYSkge1xuICAgIGEucHVzaChcIi8vXCIpO1xuICAgIHZhciBjID0gdGhpcy4kYTtcbiAgICBjICYmIGEucHVzaChtYihjLCBuYiksIFwiQFwiKTtcbiAgICBhLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhiKSkpO1xuICAgIGIgPSB0aGlzLkFhO1xuICAgIGIgIT0gbSAmJiBhLnB1c2goXCI6XCIsIFN0cmluZyhiKSlcbiAgfVxuICBpZihiID0gdGhpcy5HKSB7XG4gICAgdGhpcy5pYSAmJiBcIi9cIiAhPSBiLmNoYXJBdCgwKSAmJiBhLnB1c2goXCIvXCIpLCBhLnB1c2gobWIoYiwgXCIvXCIgPT0gYi5jaGFyQXQoMCkgPyBvYiA6IHBiKSlcbiAgfVxuICAoYiA9IHRoaXMuUS50b1N0cmluZygpKSAmJiBhLnB1c2goXCI/XCIsIGIpO1xuICAoYiA9IHRoaXMuTGEpICYmIGEucHVzaChcIiNcIiwgbWIoYiwgcWIpKTtcbiAgcmV0dXJuIGEuam9pbihcIlwiKVxufTtcbnUubiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IEkodGhpcylcbn07XG5mdW5jdGlvbiBnYihhLCBiLCBjKSB7XG4gIEooYSk7XG4gIGEucGEgPSBjID8gYiA/IGRlY29kZVVSSUNvbXBvbmVudChiKSA6IFwiXCIgOiBiO1xuICBhLnBhICYmIChhLnBhID0gYS5wYS5yZXBsYWNlKC86JC8sIFwiXCIpKVxufVxuZnVuY3Rpb24gaGIoYSwgYiwgYykge1xuICBKKGEpO1xuICBhLmlhID0gYyA/IGIgPyBkZWNvZGVVUklDb21wb25lbnQoYikgOiBcIlwiIDogYlxufVxuZnVuY3Rpb24gaWIoYSwgYikge1xuICBKKGEpO1xuICBiID8gKGIgPSBOdW1iZXIoYiksIChpc05hTihiKSB8fCAwID4gYikgJiYgZShFcnJvcihcIkJhZCBwb3J0IG51bWJlciBcIiArIGIpKSwgYS5BYSA9IGIpIDogYS5BYSA9IG1cbn1cbmZ1bmN0aW9uIGpiKGEsIGIsIGMpIHtcbiAgSihhKTtcbiAgYS5HID0gYyA/IGIgPyBkZWNvZGVVUklDb21wb25lbnQoYikgOiBcIlwiIDogYlxufVxuZnVuY3Rpb24ga2IoYSwgYiwgYykge1xuICBKKGEpO1xuICBiIGluc3RhbmNlb2YgbGIgPyAoYS5RID0gYiwgYS5RLnBiKGEuQykpIDogKGMgfHwgKGIgPSBtYihiLCByYikpLCBhLlEgPSBuZXcgbGIoYiwgMCwgYS5DKSlcbn1cbmZ1bmN0aW9uIEsoYSwgYiwgYykge1xuICBKKGEpO1xuICBhLlEuc2V0KGIsIGMpXG59XG5mdW5jdGlvbiBzYihhLCBiLCBjKSB7XG4gIEooYSk7XG4gIHgoYykgfHwgKGMgPSBbU3RyaW5nKGMpXSk7XG4gIHRiKGEuUSwgYiwgYylcbn1cbmZ1bmN0aW9uIE0oYSkge1xuICBKKGEpO1xuICBLKGEsIFwienhcIiwgTWF0aC5mbG9vcigyMTQ3NDgzNjQ4ICogTWF0aC5yYW5kb20oKSkudG9TdHJpbmcoMzYpICsgTWF0aC5hYnMoTWF0aC5mbG9vcigyMTQ3NDgzNjQ4ICogTWF0aC5yYW5kb20oKSkgXiBDKCkpLnRvU3RyaW5nKDM2KSk7XG4gIHJldHVybiBhXG59XG5mdW5jdGlvbiBKKGEpIHtcbiAgYS5sYyAmJiBlKEVycm9yKFwiVHJpZWQgdG8gbW9kaWZ5IGEgcmVhZC1vbmx5IFVyaVwiKSlcbn1cbnUucGIgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuQyA9IGE7XG4gIHRoaXMuUSAmJiB0aGlzLlEucGIoYSk7XG4gIHJldHVybiB0aGlzXG59O1xuZnVuY3Rpb24gdWIoYSwgYiwgYywgZCkge1xuICB2YXIgZiA9IG5ldyBJKG0sIGgpO1xuICBhICYmIGdiKGYsIGEpO1xuICBiICYmIGhiKGYsIGIpO1xuICBjICYmIGliKGYsIGMpO1xuICBkICYmIGpiKGYsIGQpO1xuICByZXR1cm4gZlxufVxuZnVuY3Rpb24gbWIoYSwgYikge1xuICByZXR1cm4geihhKSA/IGVuY29kZVVSSShhKS5yZXBsYWNlKGIsIHZiKSA6IG1cbn1cbmZ1bmN0aW9uIHZiKGEpIHtcbiAgYSA9IGEuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuXCIlXCIgKyAoYSA+PiA0ICYgMTUpLnRvU3RyaW5nKDE2KSArIChhICYgMTUpLnRvU3RyaW5nKDE2KVxufVxudmFyIG5iID0gL1sjXFwvXFw/QF0vZywgcGIgPSAvW1xcI1xcPzpdL2csIG9iID0gL1tcXCNcXD9dL2csIHJiID0gL1tcXCNcXD9AXS9nLCBxYiA9IC8jL2c7XG5mdW5jdGlvbiBsYihhLCBiLCBjKSB7XG4gIHRoaXMuQiA9IGEgfHwgbTtcbiAgdGhpcy5DID0gISFjXG59XG5mdW5jdGlvbiBOKGEpIHtcbiAgaWYoIWEuaSAmJiAoYS5pID0gbmV3IGRiLCBhLmYgPSAwLCBhLkIpKSB7XG4gICAgZm9yKHZhciBiID0gYS5CLnNwbGl0KFwiJlwiKSwgYyA9IDA7YyA8IGIubGVuZ3RoO2MrKykge1xuICAgICAgdmFyIGQgPSBiW2NdLmluZGV4T2YoXCI9XCIpLCBmID0gbSwgZyA9IG07XG4gICAgICAwIDw9IGQgPyAoZiA9IGJbY10uc3Vic3RyaW5nKDAsIGQpLCBnID0gYltjXS5zdWJzdHJpbmcoZCArIDEpKSA6IGYgPSBiW2NdO1xuICAgICAgZiA9IGRlY29kZVVSSUNvbXBvbmVudChmLnJlcGxhY2UoL1xcKy9nLCBcIiBcIikpO1xuICAgICAgZiA9IE8oYSwgZik7XG4gICAgICBhLmFkZChmLCBnID8gZGVjb2RlVVJJQ29tcG9uZW50KGcucmVwbGFjZSgvXFwrL2csIFwiIFwiKSkgOiBcIlwiKVxuICAgIH1cbiAgfVxufVxudSA9IGxiLnByb3RvdHlwZTtcbnUuaSA9IG07XG51LmYgPSBtO1xudS5hZGQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIE4odGhpcyk7XG4gIHRoaXMuQiA9IG07XG4gIGEgPSBPKHRoaXMsIGEpO1xuICB2YXIgYyA9IHRoaXMuaS5nZXQoYSk7XG4gIGMgfHwgdGhpcy5pLnNldChhLCBjID0gW10pO1xuICBjLnB1c2goYik7XG4gIHRoaXMuZisrO1xuICByZXR1cm4gdGhpc1xufTtcbnUucmVtb3ZlID0gZnVuY3Rpb24oYSkge1xuICBOKHRoaXMpO1xuICBhID0gTyh0aGlzLCBhKTtcbiAgcmV0dXJuIHRoaXMuaS5oYShhKSA/ICh0aGlzLkIgPSBtLCB0aGlzLmYgLT0gdGhpcy5pLmdldChhKS5sZW5ndGgsIHRoaXMuaS5yZW1vdmUoYSkpIDogclxufTtcbnUuaGEgPSBmdW5jdGlvbihhKSB7XG4gIE4odGhpcyk7XG4gIGEgPSBPKHRoaXMsIGEpO1xuICByZXR1cm4gdGhpcy5pLmhhKGEpXG59O1xudS5qYSA9IGZ1bmN0aW9uKCkge1xuICBOKHRoaXMpO1xuICBmb3IodmFyIGEgPSB0aGlzLmkuTSgpLCBiID0gdGhpcy5pLmphKCksIGMgPSBbXSwgZCA9IDA7ZCA8IGIubGVuZ3RoO2QrKykge1xuICAgIGZvcih2YXIgZiA9IGFbZF0sIGcgPSAwO2cgPCBmLmxlbmd0aDtnKyspIHtcbiAgICAgIGMucHVzaChiW2RdKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY1xufTtcbnUuTSA9IGZ1bmN0aW9uKGEpIHtcbiAgTih0aGlzKTtcbiAgdmFyIGIgPSBbXTtcbiAgaWYoYSkge1xuICAgIHRoaXMuaGEoYSkgJiYgKGIgPSAkYShiLCB0aGlzLmkuZ2V0KE8odGhpcywgYSkpKSlcbiAgfWVsc2Uge1xuICAgIGEgPSB0aGlzLmkuTSgpO1xuICAgIGZvcih2YXIgYyA9IDA7YyA8IGEubGVuZ3RoO2MrKykge1xuICAgICAgYiA9ICRhKGIsIGFbY10pXG4gICAgfVxuICB9XG4gIHJldHVybiBiXG59O1xudS5zZXQgPSBmdW5jdGlvbihhLCBiKSB7XG4gIE4odGhpcyk7XG4gIHRoaXMuQiA9IG07XG4gIGEgPSBPKHRoaXMsIGEpO1xuICB0aGlzLmhhKGEpICYmICh0aGlzLmYgLT0gdGhpcy5pLmdldChhKS5sZW5ndGgpO1xuICB0aGlzLmkuc2V0KGEsIFtiXSk7XG4gIHRoaXMuZisrO1xuICByZXR1cm4gdGhpc1xufTtcbnUuZ2V0ID0gZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYyA9IGEgPyB0aGlzLk0oYSkgOiBbXTtcbiAgcmV0dXJuIDAgPCBjLmxlbmd0aCA/IFN0cmluZyhjWzBdKSA6IGJcbn07XG5mdW5jdGlvbiB0YihhLCBiLCBjKSB7XG4gIGEucmVtb3ZlKGIpO1xuICAwIDwgYy5sZW5ndGggJiYgKGEuQiA9IG0sIGEuaS5zZXQoTyhhLCBiKSwgYWIoYykpLCBhLmYgKz0gYy5sZW5ndGgpXG59XG51LnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gIGlmKHRoaXMuQikge1xuICAgIHJldHVybiB0aGlzLkJcbiAgfVxuICBpZighdGhpcy5pKSB7XG4gICAgcmV0dXJuXCJcIlxuICB9XG4gIGZvcih2YXIgYSA9IFtdLCBiID0gdGhpcy5pLmphKCksIGMgPSAwO2MgPCBiLmxlbmd0aDtjKyspIHtcbiAgICBmb3IodmFyIGQgPSBiW2NdLCBmID0gZW5jb2RlVVJJQ29tcG9uZW50KFN0cmluZyhkKSksIGQgPSB0aGlzLk0oZCksIGcgPSAwO2cgPCBkLmxlbmd0aDtnKyspIHtcbiAgICAgIHZhciBrID0gZjtcbiAgICAgIFwiXCIgIT09IGRbZ10gJiYgKGsgKz0gXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKGRbZ10pKSk7XG4gICAgICBhLnB1c2goaylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuQiA9IGEuam9pbihcIiZcIilcbn07XG51Lm4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGEgPSBuZXcgbGI7XG4gIGEuQiA9IHRoaXMuQjtcbiAgdGhpcy5pICYmIChhLmkgPSB0aGlzLmkubigpLCBhLmYgPSB0aGlzLmYpO1xuICByZXR1cm4gYVxufTtcbmZ1bmN0aW9uIE8oYSwgYikge1xuICB2YXIgYyA9IFN0cmluZyhiKTtcbiAgYS5DICYmIChjID0gYy50b0xvd2VyQ2FzZSgpKTtcbiAgcmV0dXJuIGNcbn1cbnUucGIgPSBmdW5jdGlvbihhKSB7XG4gIGEgJiYgIXRoaXMuQyAmJiAoTih0aGlzKSwgdGhpcy5CID0gbSwgY2IodGhpcy5pLCBmdW5jdGlvbihhLCBjKSB7XG4gICAgdmFyIGQgPSBjLnRvTG93ZXJDYXNlKCk7XG4gICAgYyAhPSBkICYmICh0aGlzLnJlbW92ZShjKSwgdGIodGhpcywgZCwgYSkpXG4gIH0sIHRoaXMpKTtcbiAgdGhpcy5DID0gYVxufTtcbmZ1bmN0aW9uIHdiKCkge1xufVxud2IucHJvdG90eXBlLkZhID0gbTtcbnZhciB4YjtcbmZ1bmN0aW9uIHliKCkge1xufVxuRCh5Yiwgd2IpO1xuZnVuY3Rpb24gemIoYSkge1xuICByZXR1cm4oYSA9IEFiKGEpKSA/IG5ldyBBY3RpdmVYT2JqZWN0KGEpIDogbmV3IFhNTEh0dHBSZXF1ZXN0XG59XG5mdW5jdGlvbiBCYihhKSB7XG4gIHZhciBiID0ge307XG4gIEFiKGEpICYmIChiWzBdID0gbCwgYlsxXSA9IGwpO1xuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gQWIoYSkge1xuICBpZighYS5GYiAmJiBcInVuZGVmaW5lZFwiID09IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBBY3RpdmVYT2JqZWN0KSB7XG4gICAgZm9yKHZhciBiID0gW1wiTVNYTUwyLlhNTEhUVFAuNi4wXCIsIFwiTVNYTUwyLlhNTEhUVFAuMy4wXCIsIFwiTVNYTUwyLlhNTEhUVFBcIiwgXCJNaWNyb3NvZnQuWE1MSFRUUFwiXSwgYyA9IDA7YyA8IGIubGVuZ3RoO2MrKykge1xuICAgICAgdmFyIGQgPSBiW2NdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KGQpLCBhLkZiID0gZFxuICAgICAgfWNhdGNoKGYpIHtcbiAgICAgIH1cbiAgICB9XG4gICAgZShFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgQWN0aXZlWE9iamVjdC4gQWN0aXZlWCBtaWdodCBiZSBkaXNhYmxlZCwgb3IgTVNYTUwgbWlnaHQgbm90IGJlIGluc3RhbGxlZFwiKSlcbiAgfVxuICByZXR1cm4gYS5GYlxufVxueGIgPSBuZXcgeWI7XG5mdW5jdGlvbiBQKCkge1xuICAwICE9IENiICYmICh0aGlzLkZjID0gRXJyb3IoKS5zdGFjaywgRGJbQSh0aGlzKV0gPSB0aGlzKVxufVxudmFyIENiID0gMCwgRGIgPSB7fTtcblAucHJvdG90eXBlLnhiID0gcjtcblAucHJvdG90eXBlLkhhID0gZnVuY3Rpb24oKSB7XG4gIGlmKCF0aGlzLnhiICYmICh0aGlzLnhiID0gbCwgdGhpcy51KCksIDAgIT0gQ2IpKSB7XG4gICAgdmFyIGEgPSBBKHRoaXMpO1xuICAgIGRlbGV0ZSBEYlthXVxuICB9XG59O1xuUC5wcm90b3R5cGUudSA9IGZ1bmN0aW9uKCkge1xuICBpZih0aGlzLk1iKSB7XG4gICAgZm9yKDt0aGlzLk1iLmxlbmd0aDspIHtcbiAgICAgIHRoaXMuTWIuc2hpZnQoKSgpXG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gUShhLCBiKSB7XG4gIHRoaXMudHlwZSA9IGE7XG4gIHRoaXMuY3VycmVudFRhcmdldCA9IHRoaXMudGFyZ2V0ID0gYlxufVxudSA9IFEucHJvdG90eXBlO1xudS51ID0gcygpO1xudS5IYSA9IHMoKTtcbnUubWEgPSByO1xudS5kZWZhdWx0UHJldmVudGVkID0gcjtcbnUuVmEgPSBsO1xudS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBsO1xuICB0aGlzLlZhID0gclxufTtcbnZhciBFYiA9IDA7XG5mdW5jdGlvbiBGYigpIHtcbn1cbnUgPSBGYi5wcm90b3R5cGU7XG51LmtleSA9IDA7XG51LmRhID0gcjtcbnUuR2EgPSByO1xudS5OYSA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGYsIGcpIHtcbiAgaGEoYSkgPyB0aGlzLkhiID0gbCA6IGEgJiYgYS5oYW5kbGVFdmVudCAmJiBoYShhLmhhbmRsZUV2ZW50KSA/IHRoaXMuSGIgPSByIDogZShFcnJvcihcIkludmFsaWQgbGlzdGVuZXIgYXJndW1lbnRcIikpO1xuICB0aGlzLlYgPSBhO1xuICB0aGlzLlRiID0gYjtcbiAgdGhpcy5zcmMgPSBjO1xuICB0aGlzLnR5cGUgPSBkO1xuICB0aGlzLmNhcHR1cmUgPSAhIWY7XG4gIHRoaXMua2IgPSBnO1xuICB0aGlzLkdhID0gcjtcbiAgdGhpcy5rZXkgPSArK0ViO1xuICB0aGlzLmRhID0gclxufTtcbnUuaGFuZGxlRXZlbnQgPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiB0aGlzLkhiID8gdGhpcy5WLmNhbGwodGhpcy5rYiB8fCB0aGlzLnNyYywgYSkgOiB0aGlzLlYuaGFuZGxlRXZlbnQuY2FsbCh0aGlzLlYsIGEpXG59O1xudmFyIEdiID0gIUUgfHwgRSAmJiA5IDw9IE5hLCBIYiA9IEUgJiYgIUcoXCI5XCIpO1xuIUYgfHwgRyhcIjUyOFwiKTtcbkJhICYmIEcoXCIxLjliXCIpIHx8IEUgJiYgRyhcIjhcIikgfHwgQWEgJiYgRyhcIjkuNVwiKSB8fCBGICYmIEcoXCI1MjhcIik7XG5CYSAmJiAhRyhcIjhcIikgfHwgRSAmJiBHKFwiOVwiKTtcbmZ1bmN0aW9uIEliKGEpIHtcbiAgSWJbXCIgXCJdKGEpO1xuICByZXR1cm4gYVxufVxuSWJbXCIgXCJdID0gZWE7XG5mdW5jdGlvbiBKYihhLCBiKSB7XG4gIGEgJiYgdGhpcy5OYShhLCBiKVxufVxuRChKYiwgUSk7XG51ID0gSmIucHJvdG90eXBlO1xudS50YXJnZXQgPSBtO1xudS5yZWxhdGVkVGFyZ2V0ID0gbTtcbnUub2Zmc2V0WCA9IDA7XG51Lm9mZnNldFkgPSAwO1xudS5jbGllbnRYID0gMDtcbnUuY2xpZW50WSA9IDA7XG51LnNjcmVlblggPSAwO1xudS5zY3JlZW5ZID0gMDtcbnUuYnV0dG9uID0gMDtcbnUua2V5Q29kZSA9IDA7XG51LmNoYXJDb2RlID0gMDtcbnUuY3RybEtleSA9IHI7XG51LmFsdEtleSA9IHI7XG51LnNoaWZ0S2V5ID0gcjtcbnUubWV0YUtleSA9IHI7XG51LnhjID0gcjtcbnUueWIgPSBtO1xudS5OYSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdmFyIGMgPSB0aGlzLnR5cGUgPSBhLnR5cGU7XG4gIFEuY2FsbCh0aGlzLCBjKTtcbiAgdGhpcy50YXJnZXQgPSBhLnRhcmdldCB8fCBhLnNyY0VsZW1lbnQ7XG4gIHRoaXMuY3VycmVudFRhcmdldCA9IGI7XG4gIHZhciBkID0gYS5yZWxhdGVkVGFyZ2V0O1xuICBpZihkKSB7XG4gICAgaWYoQmEpIHtcbiAgICAgIHZhciBmO1xuICAgICAgYToge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEliKGQubm9kZU5hbWUpO1xuICAgICAgICAgIGYgPSBsO1xuICAgICAgICAgIGJyZWFrIGFcbiAgICAgICAgfWNhdGNoKGcpIHtcbiAgICAgICAgfVxuICAgICAgICBmID0gclxuICAgICAgfVxuICAgICAgZiB8fCAoZCA9IG0pXG4gICAgfVxuICB9ZWxzZSB7XG4gICAgXCJtb3VzZW92ZXJcIiA9PSBjID8gZCA9IGEuZnJvbUVsZW1lbnQgOiBcIm1vdXNlb3V0XCIgPT0gYyAmJiAoZCA9IGEudG9FbGVtZW50KVxuICB9XG4gIHRoaXMucmVsYXRlZFRhcmdldCA9IGQ7XG4gIHRoaXMub2Zmc2V0WCA9IEYgfHwgYS5vZmZzZXRYICE9PSBoID8gYS5vZmZzZXRYIDogYS5sYXllclg7XG4gIHRoaXMub2Zmc2V0WSA9IEYgfHwgYS5vZmZzZXRZICE9PSBoID8gYS5vZmZzZXRZIDogYS5sYXllclk7XG4gIHRoaXMuY2xpZW50WCA9IGEuY2xpZW50WCAhPT0gaCA/IGEuY2xpZW50WCA6IGEucGFnZVg7XG4gIHRoaXMuY2xpZW50WSA9IGEuY2xpZW50WSAhPT0gaCA/IGEuY2xpZW50WSA6IGEucGFnZVk7XG4gIHRoaXMuc2NyZWVuWCA9IGEuc2NyZWVuWCB8fCAwO1xuICB0aGlzLnNjcmVlblkgPSBhLnNjcmVlblkgfHwgMDtcbiAgdGhpcy5idXR0b24gPSBhLmJ1dHRvbjtcbiAgdGhpcy5rZXlDb2RlID0gYS5rZXlDb2RlIHx8IDA7XG4gIHRoaXMuY2hhckNvZGUgPSBhLmNoYXJDb2RlIHx8IChcImtleXByZXNzXCIgPT0gYyA/IGEua2V5Q29kZSA6IDApO1xuICB0aGlzLmN0cmxLZXkgPSBhLmN0cmxLZXk7XG4gIHRoaXMuYWx0S2V5ID0gYS5hbHRLZXk7XG4gIHRoaXMuc2hpZnRLZXkgPSBhLnNoaWZ0S2V5O1xuICB0aGlzLm1ldGFLZXkgPSBhLm1ldGFLZXk7XG4gIHRoaXMueGMgPSBEYSA/IGEubWV0YUtleSA6IGEuY3RybEtleTtcbiAgdGhpcy5zdGF0ZSA9IGEuc3RhdGU7XG4gIHRoaXMueWIgPSBhO1xuICBhLmRlZmF1bHRQcmV2ZW50ZWQgJiYgdGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuICBkZWxldGUgdGhpcy5tYVxufTtcbnUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgSmIucWEucHJldmVudERlZmF1bHQuY2FsbCh0aGlzKTtcbiAgdmFyIGEgPSB0aGlzLnliO1xuICBpZihhLnByZXZlbnREZWZhdWx0KSB7XG4gICAgYS5wcmV2ZW50RGVmYXVsdCgpXG4gIH1lbHNlIHtcbiAgICBpZihhLnJldHVyblZhbHVlID0gciwgSGIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmKGEuY3RybEtleSB8fCAxMTIgPD0gYS5rZXlDb2RlICYmIDEyMyA+PSBhLmtleUNvZGUpIHtcbiAgICAgICAgICBhLmtleUNvZGUgPSAtMVxuICAgICAgICB9XG4gICAgICB9Y2F0Y2goYikge1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbnUudSA9IHMoKTtcbnZhciBUYSA9IHt9LCBSID0ge30sIFMgPSB7fSwgS2IgPSB7fTtcbmZ1bmN0aW9uIExiKGEsIGIsIGMsIGQsIGYpIHtcbiAgaWYoeChiKSkge1xuICAgIGZvcih2YXIgZyA9IDA7ZyA8IGIubGVuZ3RoO2crKykge1xuICAgICAgTGIoYSwgYltnXSwgYywgZCwgZilcbiAgICB9XG4gICAgcmV0dXJuIG1cbiAgfVxuICBhOiB7XG4gICAgYiB8fCBlKEVycm9yKFwiSW52YWxpZCBldmVudCB0eXBlXCIpKTtcbiAgICBkID0gISFkO1xuICAgIHZhciBrID0gUjtcbiAgICBiIGluIGsgfHwgKGtbYl0gPSB7ZjowLCB0OjB9KTtcbiAgICBrID0ga1tiXTtcbiAgICBkIGluIGsgfHwgKGtbZF0gPSB7ZjowLCB0OjB9LCBrLmYrKyk7XG4gICAgdmFyIGsgPSBrW2RdLCBnID0gQShhKSwgcTtcbiAgICBrLnQrKztcbiAgICBpZihrW2ddKSB7XG4gICAgICBxID0ga1tnXTtcbiAgICAgIGZvcih2YXIgbiA9IDA7biA8IHEubGVuZ3RoO24rKykge1xuICAgICAgICBpZihrID0gcVtuXSwgay5WID09IGMgJiYgay5rYiA9PSBmKSB7XG4gICAgICAgICAgaWYoay5kYSkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgcVtuXS5HYSA9IHI7XG4gICAgICAgICAgYSA9IHFbbl07XG4gICAgICAgICAgYnJlYWsgYVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfWVsc2Uge1xuICAgICAgcSA9IGtbZ10gPSBbXSwgay5mKytcbiAgICB9XG4gICAgbiA9IE1iKCk7XG4gICAgayA9IG5ldyBGYjtcbiAgICBrLk5hKGMsIG4sIGEsIGIsIGQsIGYpO1xuICAgIGsuR2EgPSByO1xuICAgIG4uc3JjID0gYTtcbiAgICBuLlYgPSBrO1xuICAgIHEucHVzaChrKTtcbiAgICBTW2ddIHx8IChTW2ddID0gW10pO1xuICAgIFNbZ10ucHVzaChrKTtcbiAgICBhLmFkZEV2ZW50TGlzdGVuZXIgPyAoYSA9PSB3IHx8ICFhLnZiKSAmJiBhLmFkZEV2ZW50TGlzdGVuZXIoYiwgbiwgZCkgOiBhLmF0dGFjaEV2ZW50KGIgaW4gS2IgPyBLYltiXSA6IEtiW2JdID0gXCJvblwiICsgYiwgbik7XG4gICAgYSA9IGtcbiAgfVxuICBiID0gYS5rZXk7XG4gIFRhW2JdID0gYTtcbiAgcmV0dXJuIGJcbn1cbmZ1bmN0aW9uIE1iKCkge1xuICB2YXIgYSA9IE5iLCBiID0gR2IgPyBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIGEuY2FsbChiLnNyYywgYi5WLCBjKVxuICB9IDogZnVuY3Rpb24oYykge1xuICAgIGMgPSBhLmNhbGwoYi5zcmMsIGIuViwgYyk7XG4gICAgaWYoIWMpIHtcbiAgICAgIHJldHVybiBjXG4gICAgfVxuICB9O1xuICByZXR1cm4gYlxufVxuZnVuY3Rpb24gT2IoYSwgYiwgYywgZCwgZikge1xuICBpZih4KGIpKSB7XG4gICAgZm9yKHZhciBnID0gMDtnIDwgYi5sZW5ndGg7ZysrKSB7XG4gICAgICBPYihhLCBiW2ddLCBjLCBkLCBmKVxuICAgIH1cbiAgfWVsc2Uge1xuICAgIGQgPSAhIWQ7XG4gICAgYToge1xuICAgICAgZyA9IFI7XG4gICAgICBpZihiIGluIGcgJiYgKGcgPSBnW2JdLCBkIGluIGcgJiYgKGcgPSBnW2RdLCBhID0gQShhKSwgZ1thXSkpKSB7XG4gICAgICAgIGEgPSBnW2FdO1xuICAgICAgICBicmVhayBhXG4gICAgICB9XG4gICAgICBhID0gbVxuICAgIH1cbiAgICBpZihhKSB7XG4gICAgICBmb3IoZyA9IDA7ZyA8IGEubGVuZ3RoO2crKykge1xuICAgICAgICBpZihhW2ddLlYgPT0gYyAmJiBhW2ddLmNhcHR1cmUgPT0gZCAmJiBhW2ddLmtiID09IGYpIHtcbiAgICAgICAgICBQYihhW2ddLmtleSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gUGIoYSkge1xuICB2YXIgYiA9IFRhW2FdO1xuICBpZighYiB8fCBiLmRhKSB7XG4gICAgcmV0dXJuIHJcbiAgfVxuICB2YXIgYyA9IGIuc3JjLCBkID0gYi50eXBlLCBmID0gYi5UYiwgZyA9IGIuY2FwdHVyZTtcbiAgYy5yZW1vdmVFdmVudExpc3RlbmVyID8gKGMgPT0gdyB8fCAhYy52YikgJiYgYy5yZW1vdmVFdmVudExpc3RlbmVyKGQsIGYsIGcpIDogYy5kZXRhY2hFdmVudCAmJiBjLmRldGFjaEV2ZW50KGQgaW4gS2IgPyBLYltkXSA6IEtiW2RdID0gXCJvblwiICsgZCwgZik7XG4gIGMgPSBBKGMpO1xuICBpZihTW2NdKSB7XG4gICAgdmFyIGYgPSBTW2NdLCBrID0gWWEoZiwgYik7XG4gICAgMCA8PSBrICYmIEguc3BsaWNlLmNhbGwoZiwgaywgMSk7XG4gICAgMCA9PSBmLmxlbmd0aCAmJiBkZWxldGUgU1tjXVxuICB9XG4gIGIuZGEgPSBsO1xuICBpZihiID0gUltkXVtnXVtjXSkge1xuICAgIGIuTGIgPSBsLCBRYihkLCBnLCBjLCBiKVxuICB9XG4gIGRlbGV0ZSBUYVthXTtcbiAgcmV0dXJuIGxcbn1cbmZ1bmN0aW9uIFFiKGEsIGIsIGMsIGQpIHtcbiAgaWYoIWQuUGEgJiYgZC5MYikge1xuICAgIGZvcih2YXIgZiA9IDAsIGcgPSAwO2YgPCBkLmxlbmd0aDtmKyspIHtcbiAgICAgIGRbZl0uZGEgPyBkW2ZdLlRiLnNyYyA9IG0gOiAoZiAhPSBnICYmIChkW2ddID0gZFtmXSksIGcrKylcbiAgICB9XG4gICAgZC5sZW5ndGggPSBnO1xuICAgIGQuTGIgPSByO1xuICAgIDAgPT0gZyAmJiAoZGVsZXRlIFJbYV1bYl1bY10sIFJbYV1bYl0uZi0tLCAwID09IFJbYV1bYl0uZiAmJiAoZGVsZXRlIFJbYV1bYl0sIFJbYV0uZi0tKSwgMCA9PSBSW2FdLmYgJiYgZGVsZXRlIFJbYV0pXG4gIH1cbn1cbmZ1bmN0aW9uIFJiKGEpIHtcbiAgdmFyIGIgPSAwO1xuICBpZihhICE9IG0pIHtcbiAgICBpZihhID0gQShhKSwgU1thXSkge1xuICAgICAgYSA9IFNbYV07XG4gICAgICBmb3IodmFyIGMgPSBhLmxlbmd0aCAtIDE7MCA8PSBjO2MtLSkge1xuICAgICAgICBQYihhW2NdLmtleSksIGIrK1xuICAgICAgfVxuICAgIH1cbiAgfWVsc2Uge1xuICAgIFNhKGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIFBiKGMpO1xuICAgICAgYisrXG4gICAgfSlcbiAgfVxufVxuZnVuY3Rpb24gU2IoYSwgYiwgYywgZCwgZikge1xuICB2YXIgZyA9IDE7XG4gIGIgPSBBKGIpO1xuICBpZihhW2JdKSB7XG4gICAgdmFyIGsgPSAtLWEudCwgcSA9IGFbYl07XG4gICAgcS5QYSA/IHEuUGErKyA6IHEuUGEgPSAxO1xuICAgIHRyeSB7XG4gICAgICBmb3IodmFyIG4gPSBxLmxlbmd0aCwgeSA9IDA7eSA8IG47eSsrKSB7XG4gICAgICAgIHZhciBwID0gcVt5XTtcbiAgICAgICAgcCAmJiAhcC5kYSAmJiAoZyAmPSBUYihwLCBmKSAhPT0gcilcbiAgICAgIH1cbiAgICB9ZmluYWxseSB7XG4gICAgICBhLnQgPSBNYXRoLm1heChrLCBhLnQpLCBxLlBhLS0sIFFiKGMsIGQsIGIsIHEpXG4gICAgfVxuICB9XG4gIHJldHVybiBCb29sZWFuKGcpXG59XG5mdW5jdGlvbiBUYihhLCBiKSB7XG4gIGEuR2EgJiYgUGIoYS5rZXkpO1xuICByZXR1cm4gYS5oYW5kbGVFdmVudChiKVxufVxuZnVuY3Rpb24gTmIoYSwgYikge1xuICBpZihhLmRhKSB7XG4gICAgcmV0dXJuIGxcbiAgfVxuICB2YXIgYyA9IGEudHlwZSwgZCA9IFI7XG4gIGlmKCEoYyBpbiBkKSkge1xuICAgIHJldHVybiBsXG4gIH1cbiAgdmFyIGQgPSBkW2NdLCBmLCBnO1xuICBpZighR2IpIHtcbiAgICBmID0gYiB8fCBkYShcIndpbmRvdy5ldmVudFwiKTtcbiAgICB2YXIgayA9IGwgaW4gZCwgcSA9IHIgaW4gZDtcbiAgICBpZihrKSB7XG4gICAgICBpZigwID4gZi5rZXlDb2RlIHx8IGYucmV0dXJuVmFsdWUgIT0gaCkge1xuICAgICAgICByZXR1cm4gbFxuICAgICAgfVxuICAgICAgYToge1xuICAgICAgICB2YXIgbiA9IHI7XG4gICAgICAgIGlmKDAgPT0gZi5rZXlDb2RlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGYua2V5Q29kZSA9IC0xO1xuICAgICAgICAgICAgYnJlYWsgYVxuICAgICAgICAgIH1jYXRjaCh5KSB7XG4gICAgICAgICAgICBuID0gbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZihuIHx8IGYucmV0dXJuVmFsdWUgPT0gaCkge1xuICAgICAgICAgIGYucmV0dXJuVmFsdWUgPSBsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG5ldyBKYjtcbiAgICBuLk5hKGYsIHRoaXMpO1xuICAgIGYgPSBsO1xuICAgIHRyeSB7XG4gICAgICBpZihrKSB7XG4gICAgICAgIGZvcih2YXIgcCA9IFtdLCB2ID0gbi5jdXJyZW50VGFyZ2V0O3Y7diA9IHYucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHAucHVzaCh2KVxuICAgICAgICB9XG4gICAgICAgIGcgPSBkW2xdO1xuICAgICAgICBnLnQgPSBnLmY7XG4gICAgICAgIGZvcih2YXIgTCA9IHAubGVuZ3RoIC0gMTshbi5tYSAmJiAwIDw9IEwgJiYgZy50O0wtLSkge1xuICAgICAgICAgIG4uY3VycmVudFRhcmdldCA9IHBbTF0sIGYgJj0gU2IoZywgcFtMXSwgYywgbCwgbilcbiAgICAgICAgfVxuICAgICAgICBpZihxKSB7XG4gICAgICAgICAgZyA9IGRbcl07XG4gICAgICAgICAgZy50ID0gZy5mO1xuICAgICAgICAgIGZvcihMID0gMDshbi5tYSAmJiBMIDwgcC5sZW5ndGggJiYgZy50O0wrKykge1xuICAgICAgICAgICAgbi5jdXJyZW50VGFyZ2V0ID0gcFtMXSwgZiAmPSBTYihnLCBwW0xdLCBjLCByLCBuKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfWVsc2Uge1xuICAgICAgICBmID0gVGIoYSwgbilcbiAgICAgIH1cbiAgICB9ZmluYWxseSB7XG4gICAgICBwICYmIChwLmxlbmd0aCA9IDApXG4gICAgfVxuICAgIHJldHVybiBmXG4gIH1cbiAgYyA9IG5ldyBKYihiLCB0aGlzKTtcbiAgcmV0dXJuIGYgPSBUYihhLCBjKVxufVxuO2Z1bmN0aW9uIFViKCkge1xuICBQLmNhbGwodGhpcylcbn1cbkQoVWIsIFApO1xudSA9IFViLnByb3RvdHlwZTtcbnUudmIgPSBsO1xudS5vYiA9IG07XG51LmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gIExiKHRoaXMsIGEsIGIsIGMsIGQpXG59O1xudS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICBPYih0aGlzLCBhLCBiLCBjLCBkKVxufTtcbnUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGEpIHtcbiAgdmFyIGIgPSBhLnR5cGUgfHwgYSwgYyA9IFI7XG4gIGlmKGIgaW4gYykge1xuICAgIGlmKHooYSkpIHtcbiAgICAgIGEgPSBuZXcgUShhLCB0aGlzKVxuICAgIH1lbHNlIHtcbiAgICAgIGlmKGEgaW5zdGFuY2VvZiBRKSB7XG4gICAgICAgIGEudGFyZ2V0ID0gYS50YXJnZXQgfHwgdGhpc1xuICAgICAgfWVsc2Uge1xuICAgICAgICB2YXIgZCA9IGE7XG4gICAgICAgIGEgPSBuZXcgUShiLCB0aGlzKTtcbiAgICAgICAgWGEoYSwgZClcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGQgPSAxLCBmLCBjID0gY1tiXSwgYiA9IGwgaW4gYywgZztcbiAgICBpZihiKSB7XG4gICAgICBmID0gW107XG4gICAgICBmb3IoZyA9IHRoaXM7ZztnID0gZy5vYikge1xuICAgICAgICBmLnB1c2goZylcbiAgICAgIH1cbiAgICAgIGcgPSBjW2xdO1xuICAgICAgZy50ID0gZy5mO1xuICAgICAgZm9yKHZhciBrID0gZi5sZW5ndGggLSAxOyFhLm1hICYmIDAgPD0gayAmJiBnLnQ7ay0tKSB7XG4gICAgICAgIGEuY3VycmVudFRhcmdldCA9IGZba10sIGQgJj0gU2IoZywgZltrXSwgYS50eXBlLCBsLCBhKSAmJiBhLlZhICE9IHJcbiAgICAgIH1cbiAgICB9XG4gICAgaWYociBpbiBjKSB7XG4gICAgICBpZihnID0gY1tyXSwgZy50ID0gZy5mLCBiKSB7XG4gICAgICAgIGZvcihrID0gMDshYS5tYSAmJiBrIDwgZi5sZW5ndGggJiYgZy50O2srKykge1xuICAgICAgICAgIGEuY3VycmVudFRhcmdldCA9IGZba10sIGQgJj0gU2IoZywgZltrXSwgYS50eXBlLCByLCBhKSAmJiBhLlZhICE9IHJcbiAgICAgICAgfVxuICAgICAgfWVsc2Uge1xuICAgICAgICBmb3IoZiA9IHRoaXM7IWEubWEgJiYgZiAmJiBnLnQ7ZiA9IGYub2IpIHtcbiAgICAgICAgICBhLmN1cnJlbnRUYXJnZXQgPSBmLCBkICY9IFNiKGcsIGYsIGEudHlwZSwgciwgYSkgJiYgYS5WYSAhPSByXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYSA9IEJvb2xlYW4oZClcbiAgfWVsc2Uge1xuICAgIGEgPSBsXG4gIH1cbiAgcmV0dXJuIGFcbn07XG51LnUgPSBmdW5jdGlvbigpIHtcbiAgVWIucWEudS5jYWxsKHRoaXMpO1xuICBSYih0aGlzKTtcbiAgdGhpcy5vYiA9IG1cbn07XG5mdW5jdGlvbiBWYihhLCBiKSB7XG4gIFAuY2FsbCh0aGlzKTtcbiAgdGhpcy5jYSA9IGEgfHwgMTtcbiAgdGhpcy5EYSA9IGIgfHwgV2I7XG4gIHRoaXMuY2IgPSBCKHRoaXMuRGMsIHRoaXMpO1xuICB0aGlzLm5iID0gQygpXG59XG5EKFZiLCBVYik7XG5WYi5wcm90b3R5cGUuZW5hYmxlZCA9IHI7XG52YXIgV2IgPSB3O1xudSA9IFZiLnByb3RvdHlwZTtcbnUuciA9IG07XG51LnNldEludGVydmFsID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLmNhID0gYTtcbiAgdGhpcy5yICYmIHRoaXMuZW5hYmxlZCA/ICh0aGlzLnN0b3AoKSwgdGhpcy5zdGFydCgpKSA6IHRoaXMuciAmJiB0aGlzLnN0b3AoKVxufTtcbnUuRGMgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5lbmFibGVkKSB7XG4gICAgdmFyIGEgPSBDKCkgLSB0aGlzLm5iO1xuICAgIDAgPCBhICYmIGEgPCAwLjggKiB0aGlzLmNhID8gdGhpcy5yID0gdGhpcy5EYS5zZXRUaW1lb3V0KHRoaXMuY2IsIHRoaXMuY2EgLSBhKSA6ICh0aGlzLmRpc3BhdGNoRXZlbnQoWGIpLCB0aGlzLmVuYWJsZWQgJiYgKHRoaXMuciA9IHRoaXMuRGEuc2V0VGltZW91dCh0aGlzLmNiLCB0aGlzLmNhKSwgdGhpcy5uYiA9IEMoKSkpXG4gIH1cbn07XG51LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW5hYmxlZCA9IGw7XG4gIHRoaXMuciB8fCAodGhpcy5yID0gdGhpcy5EYS5zZXRUaW1lb3V0KHRoaXMuY2IsIHRoaXMuY2EpLCB0aGlzLm5iID0gQygpKVxufTtcbnUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVuYWJsZWQgPSByO1xuICB0aGlzLnIgJiYgKHRoaXMuRGEuY2xlYXJUaW1lb3V0KHRoaXMuciksIHRoaXMuciA9IG0pXG59O1xudS51ID0gZnVuY3Rpb24oKSB7XG4gIFZiLnFhLnUuY2FsbCh0aGlzKTtcbiAgdGhpcy5zdG9wKCk7XG4gIGRlbGV0ZSB0aGlzLkRhXG59O1xudmFyIFhiID0gXCJ0aWNrXCI7XG5mdW5jdGlvbiBZYihhKSB7XG4gIFAuY2FsbCh0aGlzKTtcbiAgdGhpcy5lID0gYTtcbiAgdGhpcy5qID0gW11cbn1cbkQoWWIsIFApO1xudmFyIFpiID0gW107XG5mdW5jdGlvbiAkYihhLCBiLCBjLCBkKSB7XG4gIHgoYykgfHwgKFpiWzBdID0gYywgYyA9IFpiKTtcbiAgZm9yKHZhciBmID0gMDtmIDwgYy5sZW5ndGg7ZisrKSB7XG4gICAgdmFyIGcgPSBMYihiLCBjW2ZdLCBkIHx8IGEsIHIsIGEuZSB8fCBhKTtcbiAgICBhLmoucHVzaChnKVxuICB9XG59XG5ZYi5wcm90b3R5cGUudSA9IGZ1bmN0aW9uKCkge1xuICBZYi5xYS51LmNhbGwodGhpcyk7XG4gIFphKHRoaXMuaiwgUGIpO1xuICB0aGlzLmoubGVuZ3RoID0gMFxufTtcblliLnByb3RvdHlwZS5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCkge1xuICBlKEVycm9yKFwiRXZlbnRIYW5kbGVyLmhhbmRsZUV2ZW50IG5vdCBpbXBsZW1lbnRlZFwiKSlcbn07XG5mdW5jdGlvbiBhYyhhLCBiLCBjKSB7XG4gIFAuY2FsbCh0aGlzKTtcbiAgdGhpcy5tYyA9IGE7XG4gIHRoaXMuY2EgPSBiO1xuICB0aGlzLmUgPSBjO1xuICB0aGlzLmdjID0gQih0aGlzLnNjLCB0aGlzKVxufVxuRChhYywgUCk7XG51ID0gYWMucHJvdG90eXBlO1xudS5XYSA9IHI7XG51LlNiID0gMDtcbnUuciA9IG07XG51LnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yICYmIChXYi5jbGVhclRpbWVvdXQodGhpcy5yKSwgdGhpcy5yID0gbSwgdGhpcy5XYSA9IHIpXG59O1xudS51ID0gZnVuY3Rpb24oKSB7XG4gIGFjLnFhLnUuY2FsbCh0aGlzKTtcbiAgdGhpcy5zdG9wKClcbn07XG51LnNjID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuciA9IG07XG4gIHRoaXMuV2EgJiYgIXRoaXMuU2IgJiYgKHRoaXMuV2EgPSByLCBiYyh0aGlzKSlcbn07XG5mdW5jdGlvbiBiYyhhKSB7XG4gIHZhciBiO1xuICBiID0gYS5nYztcbiAgdmFyIGMgPSBhLmNhO1xuICBoYShiKSB8fCAoYiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGIuaGFuZGxlRXZlbnQgPyBiID0gQihiLmhhbmRsZUV2ZW50LCBiKSA6IGUoRXJyb3IoXCJJbnZhbGlkIGxpc3RlbmVyIGFyZ3VtZW50XCIpKSk7XG4gIGIgPSAyMTQ3NDgzNjQ3IDwgYyA/IC0xIDogV2Iuc2V0VGltZW91dChiLCBjIHx8IDApO1xuICBhLnIgPSBiO1xuICBhLm1jLmNhbGwoYS5lKVxufVxuO2Z1bmN0aW9uIFQoYSwgYiwgYywgZCwgZikge1xuICB0aGlzLmIgPSBhO1xuICB0aGlzLmEgPSBiO1xuICB0aGlzLlkgPSBjO1xuICB0aGlzLkEgPSBkO1xuICB0aGlzLkJhID0gZiB8fCAxO1xuICB0aGlzLkNhID0gY2M7XG4gIHRoaXMuaWIgPSBuZXcgWWIodGhpcyk7XG4gIHRoaXMuUmEgPSBuZXcgVmI7XG4gIHRoaXMuUmEuc2V0SW50ZXJ2YWwoZGMpXG59XG51ID0gVC5wcm90b3R5cGU7XG51LnYgPSBtO1xudS5JID0gcjtcbnUudGEgPSBtO1xudS5yYiA9IG07XG51Lm9hID0gbTtcbnUucmEgPSBtO1xudS5TID0gbTtcbnUudyA9IG07XG51LlcgPSBtO1xudS5sID0gbTtcbnUuRWEgPSAwO1xudS5KID0gbTtcbnUuc2EgPSBtO1xudS5wID0gbTtcbnUuaCA9IC0xO1xudS5XYiA9IGw7XG51LiQgPSByO1xudS5uYSA9IDA7XG51LlNhID0gbTtcbnZhciBjYyA9IDQ1RTMsIGRjID0gMjUwO1xuZnVuY3Rpb24gZWMoYSwgYikge1xuICBzd2l0Y2goYSkge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVyblwiTm9uLTIwMCByZXR1cm4gY29kZSAoXCIgKyBiICsgXCIpXCI7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuXCJYTUxIVFRQIGZhaWx1cmUgKG5vIGRhdGEpXCI7XG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuXCJIdHRwQ29ubmVjdGlvbiB0aW1lb3V0XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVyblwiVW5rbm93biBlcnJvclwiXG4gIH1cbn1cbnZhciBmYyA9IHt9LCBnYyA9IHt9O1xuZnVuY3Rpb24gaGMoKSB7XG4gIHJldHVybiFFIHx8IEUgJiYgMTAgPD0gTmFcbn1cbnUgPSBULnByb3RvdHlwZTtcbnUuWCA9IHQoXCJ2XCIpO1xudS5zZXRUaW1lb3V0ID0gdChcIkNhXCIpO1xudS5aYiA9IHQoXCJuYVwiKTtcbmZ1bmN0aW9uIGljKGEsIGIsIGMpIHtcbiAgYS5yYSA9IDE7XG4gIGEuUyA9IE0oYi5uKCkpO1xuICBhLlcgPSBjO1xuICBhLndiID0gbDtcbiAgamMoYSwgbSlcbn1cbmZ1bmN0aW9uIGtjKGEsIGIsIGMsIGQsIGYpIHtcbiAgYS5yYSA9IDE7XG4gIGEuUyA9IE0oYi5uKCkpO1xuICBhLlcgPSBtO1xuICBhLndiID0gYztcbiAgZiAmJiAoYS5XYiA9IHIpO1xuICBqYyhhLCBkKVxufVxuZnVuY3Rpb24gamMoYSwgYikge1xuICBhLm9hID0gQygpO1xuICBsYyhhKTtcbiAgYS53ID0gYS5TLm4oKTtcbiAgc2IoYS53LCBcInRcIiwgYS5CYSk7XG4gIGEuRWEgPSAwO1xuICBhLmwgPSBhLmIuZ2IoYS5iLlhhKCkgPyBiIDogbSk7XG4gIDAgPCBhLm5hICYmIChhLlNhID0gbmV3IGFjKEIoYS5jYywgYSwgYS5sKSwgYS5uYSkpO1xuICAkYihhLmliLCBhLmwsIFwicmVhZHlzdGF0ZWNoYW5nZVwiLCBhLnpjKTtcbiAgdmFyIGM7XG4gIGlmKGEudikge1xuICAgIGMgPSBhLnY7XG4gICAgdmFyIGQgPSB7fSwgZjtcbiAgICBmb3IoZiBpbiBjKSB7XG4gICAgICBkW2ZdID0gY1tmXVxuICAgIH1cbiAgICBjID0gZFxuICB9ZWxzZSB7XG4gICAgYyA9IHt9XG4gIH1cbiAgYS5XID8gKGEuc2EgPSBcIlBPU1RcIiwgY1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIGEubC5zZW5kKGEudywgYS5zYSwgYS5XLCBjKSkgOiAoYS5zYSA9IFwiR0VUXCIsIGEuV2IgJiYgIUYgJiYgKGMuQ29ubmVjdGlvbiA9IFwiY2xvc2VcIiksIGEubC5zZW5kKGEudywgYS5zYSwgbSwgYykpO1xuICBhLmIuRihtYyk7XG4gIGlmKGQgPSBhLlcpIHtcbiAgICBjID0gXCJcIjtcbiAgICBkID0gZC5zcGxpdChcIiZcIik7XG4gICAgZm9yKGYgPSAwO2YgPCBkLmxlbmd0aDtmKyspIHtcbiAgICAgIHZhciBnID0gZFtmXS5zcGxpdChcIj1cIik7XG4gICAgICBpZigxIDwgZy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGsgPSBnWzBdLCBnID0gZ1sxXSwgcSA9IGsuc3BsaXQoXCJfXCIpO1xuICAgICAgICBjID0gMiA8PSBxLmxlbmd0aCAmJiBcInR5cGVcIiA9PSBxWzFdID8gYyArIChrICsgXCI9XCIgKyBnICsgXCImXCIpIDogYyArIChrICsgXCI9cmVkYWN0ZWQmXCIpXG4gICAgICB9XG4gICAgfVxuICB9ZWxzZSB7XG4gICAgYyA9IG1cbiAgfVxuICBhLmEuaW5mbyhcIlhNTEhUVFAgUkVRIChcIiArIGEuQSArIFwiKSBbYXR0ZW1wdCBcIiArIGEuQmEgKyBcIl06IFwiICsgYS5zYSArIFwiXFxuXCIgKyBhLncgKyBcIlxcblwiICsgYylcbn1cbnUuemMgPSBmdW5jdGlvbihhKSB7XG4gIGEgPSBhLnRhcmdldDtcbiAgdmFyIGIgPSB0aGlzLlNhO1xuICBiICYmIDMgPT0gVShhKSA/ICh0aGlzLmEuZGVidWcoXCJUaHJvdHRsaW5nIHJlYWR5c3RhdGVjaGFuZ2UuXCIpLCAhYi5yICYmICFiLlNiID8gYmMoYikgOiBiLldhID0gbCkgOiB0aGlzLmNjKGEpXG59O1xudS5jYyA9IGZ1bmN0aW9uKGEpIHtcbiAgdHJ5IHtcbiAgICBpZihhID09IHRoaXMubCkge1xuICAgICAgYToge1xuICAgICAgICB2YXIgYiA9IFUodGhpcy5sKSwgYyA9IHRoaXMubC5rYSwgZCA9IG5jKHRoaXMubCk7XG4gICAgICAgIGlmKCFoYygpIHx8IEYgJiYgIUcoXCI0MjArXCIpKSB7XG4gICAgICAgICAgaWYoNCA+IGIpIHtcbiAgICAgICAgICAgIGJyZWFrIGFcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICBpZigzID4gYiB8fCAzID09IGIgJiYgIUFhICYmICFvYyh0aGlzLmwpKSB7XG4gICAgICAgICAgICBicmVhayBhXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICF0aGlzLiQgJiYgKDQgPT0gYiAmJiBjICE9IHBjKSAmJiAoYyA9PSBxYyB8fCAwID49IGQgPyB0aGlzLmIuRihyYykgOiB0aGlzLmIuRihzYykpO1xuICAgICAgICB0Yyh0aGlzKTtcbiAgICAgICAgdmFyIGYgPSBuYyh0aGlzLmwpO1xuICAgICAgICB0aGlzLmggPSBmO1xuICAgICAgICB2YXIgZyA9IG9jKHRoaXMubCk7XG4gICAgICAgIGcgfHwgdGhpcy5hLmRlYnVnKFwiTm8gcmVzcG9uc2UgdGV4dCBmb3IgdXJpIFwiICsgdGhpcy53ICsgXCIgc3RhdHVzIFwiICsgZik7XG4gICAgICAgIHRoaXMuSSA9IDIwMCA9PSBmO1xuICAgICAgICB0aGlzLmEuaW5mbyhcIlhNTEhUVFAgUkVTUCAoXCIgKyB0aGlzLkEgKyBcIikgWyBhdHRlbXB0IFwiICsgdGhpcy5CYSArIFwiXTogXCIgKyB0aGlzLnNhICsgXCJcXG5cIiArIHRoaXMudyArIFwiXFxuXCIgKyBiICsgXCIgXCIgKyBmKTtcbiAgICAgICAgdGhpcy5JID8gKDQgPT0gYiAmJiB1Yyh0aGlzKSwgdGhpcy53YiA/ICh2Yyh0aGlzLCBiLCBnKSwgQWEgJiYgMyA9PSBiICYmICgkYih0aGlzLmliLCB0aGlzLlJhLCBYYiwgdGhpcy55YyksIHRoaXMuUmEuc3RhcnQoKSkpIDogKHdjKHRoaXMuYSwgdGhpcy5BLCBnLCBtKSwgeGModGhpcywgZykpLCB0aGlzLkkgJiYgIXRoaXMuJCAmJiAoNCA9PSBiID8gdGhpcy5iLmxhKHRoaXMpIDogKHRoaXMuSSA9IHIsIGxjKHRoaXMpKSkpIDogKDQwMCA9PSBmICYmIDAgPCBnLmluZGV4T2YoXCJVbmtub3duIFNJRFwiKSA/ICh0aGlzLnAgPSAzLCBWKHljKSwgdGhpcy5hLlooXCJYTUxIVFRQIFVua25vd24gU0lEIChcIiArIHRoaXMuQSArIFwiKVwiKSkgOiAodGhpcy5wID0gMCwgVih6YyksIHRoaXMuYS5aKFwiWE1MSFRUUCBCYWQgc3RhdHVzIFwiICsgZiArIFwiIChcIiArIHRoaXMuQSArIFwiKVwiKSksIHVjKHRoaXMpLCBBYyh0aGlzKSlcbiAgICAgIH1cbiAgICB9ZWxzZSB7XG4gICAgICB0aGlzLmEuWihcIkNhbGxlZCBiYWNrIHdpdGggYW4gdW5leHBlY3RlZCB4bWxodHRwXCIpXG4gICAgfVxuICB9Y2F0Y2goaykge1xuICAgIHRoaXMuYS5kZWJ1ZyhcIkZhaWxlZCBjYWxsIHRvIE9uWG1sSHR0cFJlYWR5U3RhdGVDaGFuZ2VkX1wiKSwgdGhpcy5sICYmIG9jKHRoaXMubCkgPyBCYyh0aGlzLmEsIGssIFwiUmVzcG9uc2VUZXh0OiBcIiArIG9jKHRoaXMubCkpIDogQmModGhpcy5hLCBrLCBcIk5vIHJlc3BvbnNlIHRleHRcIilcbiAgfWZpbmFsbHkge1xuICB9XG59O1xuZnVuY3Rpb24gdmMoYSwgYiwgYykge1xuICBmb3IodmFyIGQgPSBsOyFhLiQgJiYgYS5FYSA8IGMubGVuZ3RoOykge1xuICAgIHZhciBmID0gQ2MoYSwgYyk7XG4gICAgaWYoZiA9PSBnYykge1xuICAgICAgNCA9PSBiICYmIChhLnAgPSA0LCBWKERjKSwgZCA9IHIpO1xuICAgICAgd2MoYS5hLCBhLkEsIG0sIFwiW0luY29tcGxldGUgUmVzcG9uc2VdXCIpO1xuICAgICAgYnJlYWtcbiAgICB9ZWxzZSB7XG4gICAgICBpZihmID09IGZjKSB7XG4gICAgICAgIGEucCA9IDQ7XG4gICAgICAgIFYoRWMpO1xuICAgICAgICB3YyhhLmEsIGEuQSwgYywgXCJbSW52YWxpZCBDaHVua11cIik7XG4gICAgICAgIGQgPSByO1xuICAgICAgICBicmVha1xuICAgICAgfWVsc2Uge1xuICAgICAgICB3YyhhLmEsIGEuQSwgZiwgbSksIHhjKGEsIGYpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIDQgPT0gYiAmJiAwID09IGMubGVuZ3RoICYmIChhLnAgPSAxLCBWKEZjKSwgZCA9IHIpO1xuICBhLkkgPSBhLkkgJiYgZDtcbiAgZCB8fCAod2MoYS5hLCBhLkEsIGMsIFwiW0ludmFsaWQgQ2h1bmtlZCBSZXNwb25zZV1cIiksIHVjKGEpLCBBYyhhKSlcbn1cbnUueWMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGEgPSBVKHRoaXMubCksIGIgPSBvYyh0aGlzLmwpO1xuICB0aGlzLkVhIDwgYi5sZW5ndGggJiYgKHRjKHRoaXMpLCB2Yyh0aGlzLCBhLCBiKSwgdGhpcy5JICYmIDQgIT0gYSAmJiBsYyh0aGlzKSlcbn07XG5mdW5jdGlvbiBDYyhhLCBiKSB7XG4gIHZhciBjID0gYS5FYSwgZCA9IGIuaW5kZXhPZihcIlxcblwiLCBjKTtcbiAgaWYoLTEgPT0gZCkge1xuICAgIHJldHVybiBnY1xuICB9XG4gIGMgPSBOdW1iZXIoYi5zdWJzdHJpbmcoYywgZCkpO1xuICBpZihpc05hTihjKSkge1xuICAgIHJldHVybiBmY1xuICB9XG4gIGQgKz0gMTtcbiAgaWYoZCArIGMgPiBiLmxlbmd0aCkge1xuICAgIHJldHVybiBnY1xuICB9XG4gIHZhciBmID0gYi5zdWJzdHIoZCwgYyk7XG4gIGEuRWEgPSBkICsgYztcbiAgcmV0dXJuIGZcbn1cbmZ1bmN0aW9uIEdjKGEsIGIpIHtcbiAgYS5vYSA9IEMoKTtcbiAgbGMoYSk7XG4gIHZhciBjID0gYiA/IHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSA6IFwiXCI7XG4gIGEudyA9IGEuUy5uKCk7XG4gIEsoYS53LCBcIkRPTUFJTlwiLCBjKTtcbiAgSyhhLncsIFwidFwiLCBhLkJhKTtcbiAgdHJ5IHtcbiAgICBhLkogPSBuZXcgQWN0aXZlWE9iamVjdChcImh0bWxmaWxlXCIpXG4gIH1jYXRjaChkKSB7XG4gICAgYS5hLkgoXCJBY3RpdmVYIGJsb2NrZWRcIik7XG4gICAgdWMoYSk7XG4gICAgYS5wID0gNztcbiAgICBWKEhjKTtcbiAgICBBYyhhKTtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgZiA9IFwiPGh0bWw+PGJvZHk+XCI7XG4gIGIgJiYgKGYgKz0gJzxzY3JpcHQ+ZG9jdW1lbnQuZG9tYWluPVwiJyArIGMgKyAnXCJcXHgzYy9zY3JpcHQ+Jyk7XG4gIGYgKz0gXCI8L2JvZHk+PC9odG1sPlwiO1xuICBhLkoub3BlbigpO1xuICBhLkoud3JpdGUoZik7XG4gIGEuSi5jbG9zZSgpO1xuICBhLkoucGFyZW50V2luZG93Lm0gPSBCKGEudmMsIGEpO1xuICBhLkoucGFyZW50V2luZG93LmQgPSBCKGEuUmIsIGEsIGwpO1xuICBhLkoucGFyZW50V2luZG93LnJwY0Nsb3NlID0gQihhLlJiLCBhLCByKTtcbiAgYyA9IGEuSi5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBhLkoucGFyZW50V2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gIGMuaW5uZXJIVE1MID0gJzxpZnJhbWUgc3JjPVwiJyArIGEudyArICdcIj48L2lmcmFtZT4nO1xuICBhLmEuaW5mbyhcIlRSSURFTlQgUkVRIChcIiArIGEuQSArIFwiKSBbIGF0dGVtcHQgXCIgKyBhLkJhICsgXCJdOiBHRVRcXG5cIiArIGEudyk7XG4gIGEuYi5GKG1jKVxufVxudS52YyA9IGZ1bmN0aW9uKGEpIHtcbiAgVyhCKHRoaXMudWMsIHRoaXMsIGEpLCAwKVxufTtcbnUudWMgPSBmdW5jdGlvbihhKSB7XG4gIGlmKCF0aGlzLiQpIHtcbiAgICB2YXIgYiA9IHRoaXMuYTtcbiAgICBiLmluZm8oXCJUUklERU5UIFRFWFQgKFwiICsgdGhpcy5BICsgXCIpOiBcIiArIEljKGIsIGEpKTtcbiAgICB0Yyh0aGlzKTtcbiAgICB4Yyh0aGlzLCBhKTtcbiAgICBsYyh0aGlzKVxuICB9XG59O1xudS5SYiA9IGZ1bmN0aW9uKGEpIHtcbiAgVyhCKHRoaXMudGMsIHRoaXMsIGEpLCAwKVxufTtcbnUudGMgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuJCB8fCAodGhpcy5hLmluZm8oXCJUUklERU5UIFRFWFQgKFwiICsgdGhpcy5BICsgXCIpOiBcIiArIGEgPyBcInN1Y2Nlc3NcIiA6IFwiZmFpbHVyZVwiKSwgdWModGhpcyksIHRoaXMuSSA9IGEsIHRoaXMuYi5sYSh0aGlzKSwgdGhpcy5iLkYoSmMpKVxufTtcbnUua2MgPSBmdW5jdGlvbigpIHtcbiAgdGModGhpcyk7XG4gIHRoaXMuYi5sYSh0aGlzKVxufTtcbnUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuJCA9IGw7XG4gIHVjKHRoaXMpXG59O1xuZnVuY3Rpb24gbGMoYSkge1xuICBhLnJiID0gQygpICsgYS5DYTtcbiAgS2MoYSwgYS5DYSlcbn1cbmZ1bmN0aW9uIEtjKGEsIGIpIHtcbiAgYS50YSAhPSBtICYmIGUoRXJyb3IoXCJXYXRjaERvZyB0aW1lciBub3QgbnVsbFwiKSk7XG4gIGEudGEgPSBXKEIoYS53YywgYSksIGIpXG59XG5mdW5jdGlvbiB0YyhhKSB7XG4gIGEudGEgJiYgKHcuY2xlYXJUaW1lb3V0KGEudGEpLCBhLnRhID0gbSlcbn1cbnUud2MgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy50YSA9IG07XG4gIHZhciBhID0gQygpO1xuICAwIDw9IGEgLSB0aGlzLnJiID8gKHRoaXMuSSAmJiB0aGlzLmEuSChcIlJlY2VpdmVkIHdhdGNoZG9nIHRpbWVvdXQgZXZlbiB0aG91Z2ggcmVxdWVzdCBsb2FkZWQgc3VjY2Vzc2Z1bGx5XCIpLCB0aGlzLmEuaW5mbyhcIlRJTUVPVVQ6IFwiICsgdGhpcy53KSwgMiAhPSB0aGlzLnJhICYmIHRoaXMuYi5GKHJjKSwgdWModGhpcyksIHRoaXMucCA9IDIsIFYoTGMpLCBBYyh0aGlzKSkgOiAodGhpcy5hLlooXCJXYXRjaERvZyB0aW1lciBjYWxsZWQgdG9vIGVhcmx5XCIpLCBLYyh0aGlzLCB0aGlzLnJiIC0gYSkpXG59O1xuZnVuY3Rpb24gQWMoYSkge1xuICAhYS5iLkdiKCkgJiYgIWEuJCAmJiBhLmIubGEoYSlcbn1cbmZ1bmN0aW9uIHVjKGEpIHtcbiAgdGMoYSk7XG4gIHZhciBiID0gYS5TYTtcbiAgYiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGIuSGEgJiYgYi5IYSgpO1xuICBhLlNhID0gbTtcbiAgYS5SYS5zdG9wKCk7XG4gIGIgPSBhLmliO1xuICBaYShiLmosIFBiKTtcbiAgYi5qLmxlbmd0aCA9IDA7XG4gIGEubCAmJiAoYiA9IGEubCwgYS5sID0gbSwgYi5hYm9ydCgpLCBiLkhhKCkpO1xuICBhLkogJiYgKGEuSiA9IG0pXG59XG51LkRiID0gYWEoXCJwXCIpO1xuZnVuY3Rpb24geGMoYSwgYikge1xuICB0cnkge1xuICAgIGEuYi5PYihhLCBiKSwgYS5iLkYoSmMpXG4gIH1jYXRjaChjKSB7XG4gICAgQmMoYS5hLCBjLCBcIkVycm9yIGluIGh0dHByZXF1ZXN0IGNhbGxiYWNrXCIpXG4gIH1cbn1cbjtmdW5jdGlvbiBNYyhhKSB7XG4gIGEgPSBTdHJpbmcoYSk7XG4gIGlmKC9eXFxzKiQvLnRlc3QoYSkgPyAwIDogL15bXFxdLDp7fVxcc1xcdTIwMjhcXHUyMDI5XSokLy50ZXN0KGEucmVwbGFjZSgvXFxcXFtcIlxcXFxcXC9iZm5ydHVdL2csIFwiQFwiKS5yZXBsYWNlKC9cIlteXCJcXFxcXFxuXFxyXFx1MjAyOFxcdTIwMjlcXHgwMC1cXHgwOFxceDBhLVxceDFmXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZywgXCJdXCIpLnJlcGxhY2UoLyg/Ol58OnwsKSg/OltcXHNcXHUyMDI4XFx1MjAyOV0qXFxbKSsvZywgXCJcIikpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBldmFsKFwiKFwiICsgYSArIFwiKVwiKVxuICAgIH1jYXRjaChiKSB7XG4gICAgfVxuICB9XG4gIGUoRXJyb3IoXCJJbnZhbGlkIEpTT04gc3RyaW5nOiBcIiArIGEpKVxufVxuZnVuY3Rpb24gTmMoYSkge1xuICByZXR1cm4gZXZhbChcIihcIiArIGEgKyBcIilcIilcbn1cbmZ1bmN0aW9uIE9jKGEpIHtcbiAgdmFyIGIgPSBbXTtcbiAgUGMobmV3IFFjKGgpLCBhLCBiKTtcbiAgcmV0dXJuIGIuam9pbihcIlwiKVxufVxuZnVuY3Rpb24gUWMoYSkge1xuICB0aGlzLlVhID0gYVxufVxuZnVuY3Rpb24gUGMoYSwgYiwgYykge1xuICBzd2l0Y2godHlwZW9mIGIpIHtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICBSYyhiLCBjKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGMucHVzaChpc0Zpbml0ZShiKSAmJiAhaXNOYU4oYikgPyBiIDogXCJudWxsXCIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIGMucHVzaChiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIGMucHVzaChcIm51bGxcIik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZihiID09IG0pIHtcbiAgICAgICAgYy5wdXNoKFwibnVsbFwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmKHgoYikpIHtcbiAgICAgICAgdmFyIGQgPSBiLmxlbmd0aDtcbiAgICAgICAgYy5wdXNoKFwiW1wiKTtcbiAgICAgICAgZm9yKHZhciBmID0gXCJcIiwgZyA9IDA7ZyA8IGQ7ZysrKSB7XG4gICAgICAgICAgYy5wdXNoKGYpLCBmID0gYltnXSwgUGMoYSwgYS5VYSA/IGEuVWEuY2FsbChiLCBTdHJpbmcoZyksIGYpIDogZiwgYyksIGYgPSBcIixcIlxuICAgICAgICB9XG4gICAgICAgIGMucHVzaChcIl1cIik7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjLnB1c2goXCJ7XCIpO1xuICAgICAgZCA9IFwiXCI7XG4gICAgICBmb3IoZyBpbiBiKSB7XG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBnKSAmJiAoZiA9IGJbZ10sIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZiAmJiAoYy5wdXNoKGQpLCBSYyhnLCBjKSwgYy5wdXNoKFwiOlwiKSwgUGMoYSwgYS5VYSA/IGEuVWEuY2FsbChiLCBnLCBmKSA6IGYsIGMpLCBkID0gXCIsXCIpKVxuICAgICAgfVxuICAgICAgYy5wdXNoKFwifVwiKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGUoRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiICsgdHlwZW9mIGIpKVxuICB9XG59XG52YXIgU2MgPSB7J1wiJzonXFxcXFwiJywgXCJcXFxcXCI6XCJcXFxcXFxcXFwiLCBcIi9cIjpcIlxcXFwvXCIsIFwiXFxiXCI6XCJcXFxcYlwiLCBcIlxcZlwiOlwiXFxcXGZcIiwgXCJcXG5cIjpcIlxcXFxuXCIsIFwiXFxyXCI6XCJcXFxcclwiLCBcIlxcdFwiOlwiXFxcXHRcIiwgXCJcXHgwQlwiOlwiXFxcXHUwMDBiXCJ9LCBUYyA9IC9cXHVmZmZmLy50ZXN0KFwiXFx1ZmZmZlwiKSA/IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxcdWZmZmZdL2cgOiAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHhmZl0vZztcbmZ1bmN0aW9uIFJjKGEsIGIpIHtcbiAgYi5wdXNoKCdcIicsIGEucmVwbGFjZShUYywgZnVuY3Rpb24oYSkge1xuICAgIGlmKGEgaW4gU2MpIHtcbiAgICAgIHJldHVybiBTY1thXVxuICAgIH1cbiAgICB2YXIgYiA9IGEuY2hhckNvZGVBdCgwKSwgZiA9IFwiXFxcXHVcIjtcbiAgICAxNiA+IGIgPyBmICs9IFwiMDAwXCIgOiAyNTYgPiBiID8gZiArPSBcIjAwXCIgOiA0MDk2ID4gYiAmJiAoZiArPSBcIjBcIik7XG4gICAgcmV0dXJuIFNjW2FdID0gZiArIGIudG9TdHJpbmcoMTYpXG4gIH0pLCAnXCInKVxufVxuO2Z1bmN0aW9uIFVjKGEpIHtcbiAgcmV0dXJuIFZjKGEgfHwgYXJndW1lbnRzLmNhbGxlZS5jYWxsZXIsIFtdKVxufVxuZnVuY3Rpb24gVmMoYSwgYikge1xuICB2YXIgYyA9IFtdO1xuICBpZigwIDw9IFlhKGIsIGEpKSB7XG4gICAgYy5wdXNoKFwiWy4uLmNpcmN1bGFyIHJlZmVyZW5jZS4uLl1cIilcbiAgfWVsc2Uge1xuICAgIGlmKGEgJiYgNTAgPiBiLmxlbmd0aCkge1xuICAgICAgYy5wdXNoKFdjKGEpICsgXCIoXCIpO1xuICAgICAgZm9yKHZhciBkID0gYS5hcmd1bWVudHMsIGYgPSAwO2YgPCBkLmxlbmd0aDtmKyspIHtcbiAgICAgICAgMCA8IGYgJiYgYy5wdXNoKFwiLCBcIik7XG4gICAgICAgIHZhciBnO1xuICAgICAgICBnID0gZFtmXTtcbiAgICAgICAgc3dpdGNoKHR5cGVvZiBnKSB7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgZyA9IGcgPyBcIm9iamVjdFwiIDogXCJudWxsXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICBnID0gU3RyaW5nKGcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIGcgPSBnID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIGcgPSAoZyA9IFdjKGcpKSA/IGcgOiBcIltmbl1cIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBnID0gdHlwZW9mIGdcbiAgICAgICAgfVxuICAgICAgICA0MCA8IGcubGVuZ3RoICYmIChnID0gZy5zdWJzdHIoMCwgNDApICsgXCIuLi5cIik7XG4gICAgICAgIGMucHVzaChnKVxuICAgICAgfVxuICAgICAgYi5wdXNoKGEpO1xuICAgICAgYy5wdXNoKFwiKVxcblwiKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGMucHVzaChWYyhhLmNhbGxlciwgYikpXG4gICAgICB9Y2F0Y2goaykge1xuICAgICAgICBjLnB1c2goXCJbZXhjZXB0aW9uIHRyeWluZyB0byBnZXQgY2FsbGVyXVxcblwiKVxuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIGEgPyBjLnB1c2goXCJbLi4ubG9uZyBzdGFjay4uLl1cIikgOiBjLnB1c2goXCJbZW5kXVwiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYy5qb2luKFwiXCIpXG59XG5mdW5jdGlvbiBXYyhhKSB7XG4gIGlmKFhjW2FdKSB7XG4gICAgcmV0dXJuIFhjW2FdXG4gIH1cbiAgYSA9IFN0cmluZyhhKTtcbiAgaWYoIVhjW2FdKSB7XG4gICAgdmFyIGIgPSAvZnVuY3Rpb24gKFteXFwoXSspLy5leGVjKGEpO1xuICAgIFhjW2FdID0gYiA/IGJbMV0gOiBcIltBbm9ueW1vdXNdXCJcbiAgfVxuICByZXR1cm4gWGNbYV1cbn1cbnZhciBYYyA9IHt9O1xuZnVuY3Rpb24gWWMoYSwgYiwgYywgZCwgZikge1xuICB0aGlzLnJlc2V0KGEsIGIsIGMsIGQsIGYpXG59XG5ZYy5wcm90b3R5cGUuQmMgPSAwO1xuWWMucHJvdG90eXBlLkFiID0gbTtcblljLnByb3RvdHlwZS56YiA9IG07XG52YXIgWmMgPSAwO1xuWWMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgZikge1xuICB0aGlzLkJjID0gXCJudW1iZXJcIiA9PSB0eXBlb2YgZiA/IGYgOiBaYysrO1xuICB0aGlzLlBjID0gZCB8fCBDKCk7XG4gIHRoaXMueWEgPSBhO1xuICB0aGlzLm5jID0gYjtcbiAgdGhpcy5IYyA9IGM7XG4gIGRlbGV0ZSB0aGlzLkFiO1xuICBkZWxldGUgdGhpcy56YlxufTtcblljLnByb3RvdHlwZS5YYiA9IHQoXCJ5YVwiKTtcbmZ1bmN0aW9uICRjKGEpIHtcbiAgdGhpcy5vYyA9IGFcbn1cbiRjLnByb3RvdHlwZS5RYSA9IG07XG4kYy5wcm90b3R5cGUueWEgPSBtO1xuJGMucHJvdG90eXBlLmViID0gbTtcbiRjLnByb3RvdHlwZS5FYiA9IG07XG5mdW5jdGlvbiBhZChhLCBiKSB7XG4gIHRoaXMubmFtZSA9IGE7XG4gIHRoaXMudmFsdWUgPSBiXG59XG5hZC5wcm90b3R5cGUudG9TdHJpbmcgPSBhYShcIm5hbWVcIik7XG52YXIgYmQgPSBuZXcgYWQoXCJTRVZFUkVcIiwgMUUzKSwgY2QgPSBuZXcgYWQoXCJXQVJOSU5HXCIsIDkwMCksIGRkID0gbmV3IGFkKFwiSU5GT1wiLCA4MDApLCBlZCA9IG5ldyBhZChcIkNPTkZJR1wiLCA3MDApLCBmZCA9IG5ldyBhZChcIkZJTkVcIiwgNTAwKTtcbnUgPSAkYy5wcm90b3R5cGU7XG51LmdldFBhcmVudCA9IGFhKFwiUWFcIik7XG51LlhiID0gdChcInlhXCIpO1xuZnVuY3Rpb24gZ2QoYSkge1xuICBpZihhLnlhKSB7XG4gICAgcmV0dXJuIGEueWFcbiAgfVxuICBpZihhLlFhKSB7XG4gICAgcmV0dXJuIGdkKGEuUWEpXG4gIH1cbiAgUWEoXCJSb290IGxvZ2dlciBoYXMgbm8gbGV2ZWwgc2V0LlwiKTtcbiAgcmV0dXJuIG1cbn1cbnUubG9nID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICBpZihhLnZhbHVlID49IGdkKHRoaXMpLnZhbHVlKSB7XG4gICAgYSA9IHRoaXMuamMoYSwgYiwgYyk7XG4gICAgYiA9IFwibG9nOlwiICsgYS5uYztcbiAgICB3LmNvbnNvbGUgJiYgKHcuY29uc29sZS50aW1lU3RhbXAgPyB3LmNvbnNvbGUudGltZVN0YW1wKGIpIDogdy5jb25zb2xlLm1hcmtUaW1lbGluZSAmJiB3LmNvbnNvbGUubWFya1RpbWVsaW5lKGIpKTtcbiAgICB3Lm1zV3JpdGVQcm9maWxlck1hcmsgJiYgdy5tc1dyaXRlUHJvZmlsZXJNYXJrKGIpO1xuICAgIGZvcihiID0gdGhpcztiOykge1xuICAgICAgYyA9IGI7XG4gICAgICB2YXIgZCA9IGE7XG4gICAgICBpZihjLkViKSB7XG4gICAgICAgIGZvcih2YXIgZiA9IDAsIGcgPSBoO2cgPSBjLkViW2ZdO2YrKykge1xuICAgICAgICAgIGcoZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYiA9IGIuZ2V0UGFyZW50KClcbiAgICB9XG4gIH1cbn07XG51LmpjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICB2YXIgZCA9IG5ldyBZYyhhLCBTdHJpbmcoYiksIHRoaXMub2MpO1xuICBpZihjKSB7XG4gICAgZC5BYiA9IGM7XG4gICAgdmFyIGY7XG4gICAgdmFyIGcgPSBhcmd1bWVudHMuY2FsbGVlLmNhbGxlcjtcbiAgICB0cnkge1xuICAgICAgdmFyIGs7XG4gICAgICB2YXIgcSA9IGRhKFwid2luZG93LmxvY2F0aW9uLmhyZWZcIik7XG4gICAgICBpZih6KGMpKSB7XG4gICAgICAgIGsgPSB7bWVzc2FnZTpjLCBuYW1lOlwiVW5rbm93biBlcnJvclwiLCBsaW5lTnVtYmVyOlwiTm90IGF2YWlsYWJsZVwiLCBmaWxlTmFtZTpxLCBzdGFjazpcIk5vdCBhdmFpbGFibGVcIn1cbiAgICAgIH1lbHNlIHtcbiAgICAgICAgdmFyIG4sIHksIHAgPSByO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG4gPSBjLmxpbmVOdW1iZXIgfHwgYy5HYyB8fCBcIk5vdCBhdmFpbGFibGVcIlxuICAgICAgICB9Y2F0Y2godikge1xuICAgICAgICAgIG4gPSBcIk5vdCBhdmFpbGFibGVcIiwgcCA9IGxcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHkgPSBjLmZpbGVOYW1lIHx8IGMuZmlsZW5hbWUgfHwgYy5zb3VyY2VVUkwgfHwgdy4kZ29vZ0RlYnVnRm5hbWUgfHwgcVxuICAgICAgICB9Y2F0Y2goTCkge1xuICAgICAgICAgIHkgPSBcIk5vdCBhdmFpbGFibGVcIiwgcCA9IGxcbiAgICAgICAgfVxuICAgICAgICBrID0gcCB8fCAhYy5saW5lTnVtYmVyIHx8ICFjLmZpbGVOYW1lIHx8ICFjLnN0YWNrID8ge21lc3NhZ2U6Yy5tZXNzYWdlLCBuYW1lOmMubmFtZSwgbGluZU51bWJlcjpuLCBmaWxlTmFtZTp5LCBzdGFjazpjLnN0YWNrIHx8IFwiTm90IGF2YWlsYWJsZVwifSA6IGNcbiAgICAgIH1cbiAgICAgIGYgPSBcIk1lc3NhZ2U6IFwiICsgbmEoay5tZXNzYWdlKSArICdcXG5Vcmw6IDxhIGhyZWY9XCJ2aWV3LXNvdXJjZTonICsgay5maWxlTmFtZSArICdcIiB0YXJnZXQ9XCJfbmV3XCI+JyArIGsuZmlsZU5hbWUgKyBcIjwvYT5cXG5MaW5lOiBcIiArIGsubGluZU51bWJlciArIFwiXFxuXFxuQnJvd3NlciBzdGFjazpcXG5cIiArIG5hKGsuc3RhY2sgKyBcIi0+IFwiKSArIFwiW2VuZF1cXG5cXG5KUyBzdGFjayB0cmF2ZXJzYWw6XFxuXCIgKyBuYShVYyhnKSArIFwiLT4gXCIpXG4gICAgfWNhdGNoKFlkKSB7XG4gICAgICBmID0gXCJFeGNlcHRpb24gdHJ5aW5nIHRvIGV4cG9zZSBleGNlcHRpb24hIFlvdSB3aW4sIHdlIGxvc2UuIFwiICsgWWRcbiAgICB9XG4gICAgZC56YiA9IGZcbiAgfVxuICByZXR1cm4gZFxufTtcbnUuSCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgdGhpcy5sb2coYmQsIGEsIGIpXG59O1xudS5aID0gZnVuY3Rpb24oYSwgYikge1xuICB0aGlzLmxvZyhjZCwgYSwgYilcbn07XG51LmluZm8gPSBmdW5jdGlvbihhLCBiKSB7XG4gIHRoaXMubG9nKGRkLCBhLCBiKVxufTtcbmZ1bmN0aW9uIFgoYSwgYikge1xuICBhLmxvZyhmZCwgYiwgaClcbn1cbnZhciBoZCA9IHt9LCBpZCA9IG07XG5mdW5jdGlvbiBqZChhKSB7XG4gIGlkIHx8IChpZCA9IG5ldyAkYyhcIlwiKSwgaGRbXCJcIl0gPSBpZCwgaWQuWGIoZWQpKTtcbiAgdmFyIGI7XG4gIGlmKCEoYiA9IGhkW2FdKSkge1xuICAgIGIgPSBuZXcgJGMoYSk7XG4gICAgdmFyIGMgPSBhLmxhc3RJbmRleE9mKFwiLlwiKSwgZCA9IGEuc3Vic3RyKGMgKyAxKSwgYyA9IGpkKGEuc3Vic3RyKDAsIGMpKTtcbiAgICBjLmViIHx8IChjLmViID0ge30pO1xuICAgIGMuZWJbZF0gPSBiO1xuICAgIGIuUWEgPSBjO1xuICAgIGhkW2FdID0gYlxuICB9XG4gIHJldHVybiBiXG59XG47ZnVuY3Rpb24ga2QoKSB7XG4gIHRoaXMucSA9IGpkKFwiZ29vZy5uZXQuQnJvd3NlckNoYW5uZWxcIilcbn1cbmZ1bmN0aW9uIHdjKGEsIGIsIGMsIGQpIHtcbiAgYS5pbmZvKFwiWE1MSFRUUCBURVhUIChcIiArIGIgKyBcIik6IFwiICsgSWMoYSwgYykgKyAoZCA/IFwiIFwiICsgZCA6IFwiXCIpKVxufVxua2QucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24oYSkge1xuICB0aGlzLmluZm8oYSlcbn07XG5mdW5jdGlvbiBCYyhhLCBiLCBjKSB7XG4gIGEuSCgoYyB8fCBcIkV4Y2VwdGlvblwiKSArIGIpXG59XG5rZC5wcm90b3R5cGUuaW5mbyA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5xLmluZm8oYSlcbn07XG5rZC5wcm90b3R5cGUuWiA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5xLlooYSlcbn07XG5rZC5wcm90b3R5cGUuSCA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5xLkgoYSlcbn07XG5mdW5jdGlvbiBJYyhhLCBiKSB7XG4gIGlmKCFiIHx8IGIgPT0gbGQpIHtcbiAgICByZXR1cm4gYlxuICB9XG4gIHRyeSB7XG4gICAgdmFyIGMgPSBOYyhiKTtcbiAgICBpZihjKSB7XG4gICAgICBmb3IodmFyIGQgPSAwO2QgPCBjLmxlbmd0aDtkKyspIHtcbiAgICAgICAgaWYoeChjW2RdKSkge1xuICAgICAgICAgIHZhciBmID0gY1tkXTtcbiAgICAgICAgICBpZighKDIgPiBmLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHZhciBnID0gZlsxXTtcbiAgICAgICAgICAgIGlmKHgoZykgJiYgISgxID4gZy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgIHZhciBrID0gZ1swXTtcbiAgICAgICAgICAgICAgaWYoXCJub29wXCIgIT0gayAmJiBcInN0b3BcIiAhPSBrKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBxID0gMTtxIDwgZy5sZW5ndGg7cSsrKSB7XG4gICAgICAgICAgICAgICAgICBnW3FdID0gXCJcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2MoYylcbiAgfWNhdGNoKG4pIHtcbiAgICByZXR1cm4gYS5kZWJ1ZyhcIkV4Y2VwdGlvbiBwYXJzaW5nIGV4cGVjdGVkIEpTIGFycmF5IC0gcHJvYmFibHkgd2FzIG5vdCBKU1wiKSwgYlxuICB9XG59XG47ZnVuY3Rpb24gbWQoYSwgYikge1xuICB0aGlzLk5jID0gbmV3IFFjKGEpO1xuICB0aGlzLk8gPSBiID8gTmMgOiBNY1xufVxubWQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gdGhpcy5PKGEpXG59O1xudmFyIHBjID0gNywgcWMgPSA4O1xuZnVuY3Rpb24gbmQoYSkge1xuICBQLmNhbGwodGhpcyk7XG4gIHRoaXMuaGVhZGVycyA9IG5ldyBkYjtcbiAgdGhpcy51YSA9IGEgfHwgbVxufVxuRChuZCwgVWIpO1xubmQucHJvdG90eXBlLnEgPSBqZChcImdvb2cubmV0LlhocklvXCIpO1xudmFyIG9kID0gL15odHRwcz8kL2k7XG51ID0gbmQucHJvdG90eXBlO1xudS5SID0gcjtcbnUuZyA9IG07XG51LmFiID0gbTtcbnUuT2EgPSBcIlwiO1xudS5JYiA9IFwiXCI7XG51LmthID0gMDtcbnUucCA9IFwiXCI7XG51LmhiID0gcjtcbnUuTWEgPSByO1xudS5sYiA9IHI7XG51LmJhID0gcjtcbnUuWmEgPSAwO1xudS5lYSA9IG07XG51LlZiID0gXCJcIjtcbnUuYmMgPSByO1xudS5zZW5kID0gZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuICB0aGlzLmcgJiYgZShFcnJvcihcIltnb29nLm5ldC5YaHJJb10gT2JqZWN0IGlzIGFjdGl2ZSB3aXRoIGFub3RoZXIgcmVxdWVzdD1cIiArIHRoaXMuT2EgKyBcIjsgbmV3VXJpPVwiICsgYSkpO1xuICBiID0gYiA/IGIudG9VcHBlckNhc2UoKSA6IFwiR0VUXCI7XG4gIHRoaXMuT2EgPSBhO1xuICB0aGlzLnAgPSBcIlwiO1xuICB0aGlzLmthID0gMDtcbiAgdGhpcy5JYiA9IGI7XG4gIHRoaXMuaGIgPSByO1xuICB0aGlzLlIgPSBsO1xuICB0aGlzLmcgPSB0aGlzLnVhID8gemIodGhpcy51YSkgOiB6Yih4Yik7XG4gIHRoaXMuYWIgPSB0aGlzLnVhID8gdGhpcy51YS5GYSB8fCAodGhpcy51YS5GYSA9IEJiKHRoaXMudWEpKSA6IHhiLkZhIHx8ICh4Yi5GYSA9IEJiKHhiKSk7XG4gIHRoaXMuZy5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBCKHRoaXMuTmIsIHRoaXMpO1xuICB0cnkge1xuICAgIFgodGhpcy5xLCBZKHRoaXMsIFwiT3BlbmluZyBYaHJcIikpLCB0aGlzLmxiID0gbCwgdGhpcy5nLm9wZW4oYiwgYSwgbCksIHRoaXMubGIgPSByXG4gIH1jYXRjaChmKSB7XG4gICAgWCh0aGlzLnEsIFkodGhpcywgXCJFcnJvciBvcGVuaW5nIFhocjogXCIgKyBmLm1lc3NhZ2UpKTtcbiAgICBwZCh0aGlzLCBmKTtcbiAgICByZXR1cm5cbiAgfVxuICBhID0gYyB8fCBcIlwiO1xuICB2YXIgZyA9IHRoaXMuaGVhZGVycy5uKCk7XG4gIGQgJiYgY2IoZCwgZnVuY3Rpb24oYSwgYikge1xuICAgIGcuc2V0KGIsIGEpXG4gIH0pO1xuICBkID0gdy5Gb3JtRGF0YSAmJiBhIGluc3RhbmNlb2Ygdy5Gb3JtRGF0YTtcbiAgXCJQT1NUXCIgPT0gYiAmJiAoIWcuaGEoXCJDb250ZW50LVR5cGVcIikgJiYgIWQpICYmIGcuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLThcIik7XG4gIGNiKGcsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB0aGlzLmcuc2V0UmVxdWVzdEhlYWRlcihiLCBhKVxuICB9LCB0aGlzKTtcbiAgdGhpcy5WYiAmJiAodGhpcy5nLnJlc3BvbnNlVHlwZSA9IHRoaXMuVmIpO1xuICBcIndpdGhDcmVkZW50aWFsc1wiIGluIHRoaXMuZyAmJiAodGhpcy5nLndpdGhDcmVkZW50aWFscyA9IHRoaXMuYmMpO1xuICB0cnkge1xuICAgIHRoaXMuZWEgJiYgKFdiLmNsZWFyVGltZW91dCh0aGlzLmVhKSwgdGhpcy5lYSA9IG0pLCAwIDwgdGhpcy5aYSAmJiAoWCh0aGlzLnEsIFkodGhpcywgXCJXaWxsIGFib3J0IGFmdGVyIFwiICsgdGhpcy5aYSArIFwibXMgaWYgaW5jb21wbGV0ZVwiKSksIHRoaXMuZWEgPSBXYi5zZXRUaW1lb3V0KEIodGhpcy5DYSwgdGhpcyksIHRoaXMuWmEpKSwgWCh0aGlzLnEsIFkodGhpcywgXCJTZW5kaW5nIHJlcXVlc3RcIikpLCB0aGlzLk1hID0gbCwgdGhpcy5nLnNlbmQoYSksIHRoaXMuTWEgPSByXG4gIH1jYXRjaChrKSB7XG4gICAgWCh0aGlzLnEsIFkodGhpcywgXCJTZW5kIGVycm9yOiBcIiArIGsubWVzc2FnZSkpLCBwZCh0aGlzLCBrKVxuICB9XG59O1xudS5DYSA9IGZ1bmN0aW9uKCkge1xuICBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBjYSAmJiB0aGlzLmcgJiYgKHRoaXMucCA9IFwiVGltZWQgb3V0IGFmdGVyIFwiICsgdGhpcy5aYSArIFwibXMsIGFib3J0aW5nXCIsIHRoaXMua2EgPSBxYywgWCh0aGlzLnEsIFkodGhpcywgdGhpcy5wKSksIHRoaXMuZGlzcGF0Y2hFdmVudChcInRpbWVvdXRcIiksIHRoaXMuYWJvcnQocWMpKVxufTtcbmZ1bmN0aW9uIHBkKGEsIGIpIHtcbiAgYS5SID0gcjtcbiAgYS5nICYmIChhLmJhID0gbCwgYS5nLmFib3J0KCksIGEuYmEgPSByKTtcbiAgYS5wID0gYjtcbiAgYS5rYSA9IDU7XG4gIHFkKGEpO1xuICByZChhKVxufVxuZnVuY3Rpb24gcWQoYSkge1xuICBhLmhiIHx8IChhLmhiID0gbCwgYS5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIiksIGEuZGlzcGF0Y2hFdmVudChcImVycm9yXCIpKVxufVxudS5hYm9ydCA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5nICYmIHRoaXMuUiAmJiAoWCh0aGlzLnEsIFkodGhpcywgXCJBYm9ydGluZ1wiKSksIHRoaXMuUiA9IHIsIHRoaXMuYmEgPSBsLCB0aGlzLmcuYWJvcnQoKSwgdGhpcy5iYSA9IHIsIHRoaXMua2EgPSBhIHx8IHBjLCB0aGlzLmRpc3BhdGNoRXZlbnQoXCJjb21wbGV0ZVwiKSwgdGhpcy5kaXNwYXRjaEV2ZW50KFwiYWJvcnRcIiksIHJkKHRoaXMpKVxufTtcbnUudSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmcgJiYgKHRoaXMuUiAmJiAodGhpcy5SID0gciwgdGhpcy5iYSA9IGwsIHRoaXMuZy5hYm9ydCgpLCB0aGlzLmJhID0gciksIHJkKHRoaXMsIGwpKTtcbiAgbmQucWEudS5jYWxsKHRoaXMpXG59O1xudS5OYiA9IGZ1bmN0aW9uKCkge1xuICAhdGhpcy5sYiAmJiAhdGhpcy5NYSAmJiAhdGhpcy5iYSA/IHRoaXMucmMoKSA6IHNkKHRoaXMpXG59O1xudS5yYyA9IGZ1bmN0aW9uKCkge1xuICBzZCh0aGlzKVxufTtcbmZ1bmN0aW9uIHNkKGEpIHtcbiAgaWYoYS5SICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIGNhKSB7XG4gICAgaWYoYS5hYlsxXSAmJiA0ID09IFUoYSkgJiYgMiA9PSBuYyhhKSkge1xuICAgICAgWChhLnEsIFkoYSwgXCJMb2NhbCByZXF1ZXN0IGVycm9yIGRldGVjdGVkIGFuZCBpZ25vcmVkXCIpKVxuICAgIH1lbHNlIHtcbiAgICAgIGlmKGEuTWEgJiYgNCA9PSBVKGEpKSB7XG4gICAgICAgIFdiLnNldFRpbWVvdXQoQihhLk5iLCBhKSwgMClcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgaWYoYS5kaXNwYXRjaEV2ZW50KFwicmVhZHlzdGF0ZWNoYW5nZVwiKSwgNCA9PSBVKGEpKSB7XG4gICAgICAgICAgWChhLnEsIFkoYSwgXCJSZXF1ZXN0IGNvbXBsZXRlXCIpKTtcbiAgICAgICAgICBhLlIgPSByO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYiA9IG5jKGEpLCBjLCBkO1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBzd2l0Y2goYikge1xuICAgICAgICAgICAgICAgIGNhc2UgMjAwOlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYXNlIDIwMTpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDI6XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGNhc2UgMjA0OlxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICBjYXNlIDIwNjpcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgY2FzZSAzMDQ6XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIGNhc2UgMTIyMzpcbiAgICAgICAgICAgICAgICAgIGQgPSBsO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgYTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgZCA9IHJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIShjID0gZCkpIHtcbiAgICAgICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgICAgIGlmKGYgPSAwID09PSBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSBTdHJpbmcoYS5PYSkubWF0Y2goUmEpWzFdIHx8IG07XG4gICAgICAgICAgICAgICAgaWYoIWcgJiYgc2VsZi5sb2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgdmFyIGsgPSBzZWxmLmxvY2F0aW9uLnByb3RvY29sLCBnID0gay5zdWJzdHIoMCwgay5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmID0gIW9kLnRlc3QoZyA/IGcudG9Mb3dlckNhc2UoKSA6IFwiXCIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYyA9IGZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGMpIHtcbiAgICAgICAgICAgICAgYS5kaXNwYXRjaEV2ZW50KFwiY29tcGxldGVcIiksIGEuZGlzcGF0Y2hFdmVudChcInN1Y2Nlc3NcIilcbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgYS5rYSA9IDY7XG4gICAgICAgICAgICAgIHZhciBxO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHEgPSAyIDwgVShhKSA/IGEuZy5zdGF0dXNUZXh0IDogXCJcIlxuICAgICAgICAgICAgICB9Y2F0Y2gobikge1xuICAgICAgICAgICAgICAgIFgoYS5xLCBcIkNhbiBub3QgZ2V0IHN0YXR1czogXCIgKyBuLm1lc3NhZ2UpLCBxID0gXCJcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGEucCA9IHEgKyBcIiBbXCIgKyBuYyhhKSArIFwiXVwiO1xuICAgICAgICAgICAgICBxZChhKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1maW5hbGx5IHtcbiAgICAgICAgICAgIHJkKGEpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZChhLCBiKSB7XG4gIGlmKGEuZykge1xuICAgIHZhciBjID0gYS5nLCBkID0gYS5hYlswXSA/IGVhIDogbTtcbiAgICBhLmcgPSBtO1xuICAgIGEuYWIgPSBtO1xuICAgIGEuZWEgJiYgKFdiLmNsZWFyVGltZW91dChhLmVhKSwgYS5lYSA9IG0pO1xuICAgIGIgfHwgYS5kaXNwYXRjaEV2ZW50KFwicmVhZHlcIik7XG4gICAgdHJ5IHtcbiAgICAgIGMub25yZWFkeXN0YXRlY2hhbmdlID0gZFxuICAgIH1jYXRjaChmKSB7XG4gICAgICBhLnEuSChcIlByb2JsZW0gZW5jb3VudGVyZWQgcmVzZXR0aW5nIG9ucmVhZHlzdGF0ZWNoYW5nZTogXCIgKyBmLm1lc3NhZ2UpXG4gICAgfVxuICB9XG59XG51LmlzQWN0aXZlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiEhdGhpcy5nXG59O1xuZnVuY3Rpb24gVShhKSB7XG4gIHJldHVybiBhLmcgPyBhLmcucmVhZHlTdGF0ZSA6IDBcbn1cbmZ1bmN0aW9uIG5jKGEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gMiA8IFUoYSkgPyBhLmcuc3RhdHVzIDogLTFcbiAgfWNhdGNoKGIpIHtcbiAgICByZXR1cm4gYS5xLlooXCJDYW4gbm90IGdldCBzdGF0dXM6IFwiICsgYi5tZXNzYWdlKSwgLTFcbiAgfVxufVxuZnVuY3Rpb24gb2MoYSkge1xuICB0cnkge1xuICAgIHJldHVybiBhLmcgPyBhLmcucmVzcG9uc2VUZXh0IDogXCJcIlxuICB9Y2F0Y2goYikge1xuICAgIHJldHVybiBYKGEucSwgXCJDYW4gbm90IGdldCByZXNwb25zZVRleHQ6IFwiICsgYi5tZXNzYWdlKSwgXCJcIlxuICB9XG59XG51LkRiID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB6KHRoaXMucCkgPyB0aGlzLnAgOiBTdHJpbmcodGhpcy5wKVxufTtcbmZ1bmN0aW9uIFkoYSwgYikge1xuICByZXR1cm4gYiArIFwiIFtcIiArIGEuSWIgKyBcIiBcIiArIGEuT2EgKyBcIiBcIiArIG5jKGEpICsgXCJdXCJcbn1cbjtmdW5jdGlvbiB0ZCgpIHtcbiAgdGhpcy5VYiA9IEMoKVxufVxubmV3IHRkO1xudGQucHJvdG90eXBlLnNldCA9IHQoXCJVYlwiKTtcbnRkLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNldChDKCkpXG59O1xudGQucHJvdG90eXBlLmdldCA9IGFhKFwiVWJcIik7XG5mdW5jdGlvbiB1ZChhLCBiLCBjLCBkLCBmKSB7XG4gIChuZXcga2QpLmRlYnVnKFwiVGVzdExvYWRJbWFnZVdpdGhSZXRyaWVzOiBcIiArIGYpO1xuICBpZigwID09IGQpIHtcbiAgICBjKHIpXG4gIH1lbHNlIHtcbiAgICB2YXIgZyA9IGYgfHwgMDtcbiAgICBkLS07XG4gICAgdmQoYSwgYiwgZnVuY3Rpb24oZikge1xuICAgICAgZiA/IGMobCkgOiB3LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHVkKGEsIGIsIGMsIGQsIGcpXG4gICAgICB9LCBnKVxuICAgIH0pXG4gIH1cbn1cbmZ1bmN0aW9uIHZkKGEsIGIsIGMpIHtcbiAgZnVuY3Rpb24gZChhLCBiKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZi5kZWJ1ZyhcIlRlc3RMb2FkSW1hZ2U6IFwiICsgYiksIGcub25sb2FkID0gbSwgZy5vbmVycm9yID0gbSwgZy5vbmFib3J0ID0gbSwgZy5vbnRpbWVvdXQgPSBtLCB3LmNsZWFyVGltZW91dChrKSwgYyhhKVxuICAgICAgfWNhdGNoKGQpIHtcbiAgICAgICAgQmMoZiwgZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGYgPSBuZXcga2Q7XG4gIGYuZGVidWcoXCJUZXN0TG9hZEltYWdlOiBsb2FkaW5nIFwiICsgYSk7XG4gIHZhciBnID0gbmV3IEltYWdlLCBrID0gbTtcbiAgZy5vbmxvYWQgPSBkKGwsIFwibG9hZGVkXCIpO1xuICBnLm9uZXJyb3IgPSBkKHIsIFwiZXJyb3JcIik7XG4gIGcub25hYm9ydCA9IGQociwgXCJhYm9ydFwiKTtcbiAgZy5vbnRpbWVvdXQgPSBkKHIsIFwidGltZW91dFwiKTtcbiAgayA9IHcuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZihnLm9udGltZW91dCkge1xuICAgICAgZy5vbnRpbWVvdXQoKVxuICAgIH1cbiAgfSwgYik7XG4gIGcuc3JjID0gYVxufVxuO2Z1bmN0aW9uIHdkKGEsIGIpIHtcbiAgdGhpcy5iID0gYTtcbiAgdGhpcy5hID0gYjtcbiAgdGhpcy5PID0gbmV3IG1kKG0sIGwpXG59XG51ID0gd2QucHJvdG90eXBlO1xudS52ID0gbTtcbnUueiA9IG07XG51LlRhID0gcjtcbnUuJGIgPSBtO1xudS5KYSA9IG07XG51Lm1iID0gbTtcbnUuRyA9IG07XG51LmMgPSBtO1xudS5oID0gLTE7XG51LksgPSBtO1xudS52YSA9IG07XG51LlggPSB0KFwidlwiKTtcbnUuWWIgPSB0KFwiT1wiKTtcbnUuZmIgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuRyA9IGE7XG4gIGEgPSB4ZCh0aGlzLmIsIHRoaXMuRyk7XG4gIFYoeWQpO1xuICB0aGlzLiRiID0gQygpO1xuICB2YXIgYiA9IHRoaXMuYi5CYjtcbiAgYiAhPSBtID8gKHRoaXMuSyA9IHRoaXMuYi5jb3JyZWN0SG9zdFByZWZpeChiWzBdKSwgKHRoaXMudmEgPSBiWzFdKSA/ICh0aGlzLmMgPSAxLCB6ZCh0aGlzKSkgOiAodGhpcy5jID0gMiwgQWQodGhpcykpKSA6IChzYihhLCBcIk1PREVcIiwgXCJpbml0XCIpLCB0aGlzLnogPSBuZXcgVCh0aGlzLCB0aGlzLmEsIGgsIGgsIGgpLCB0aGlzLnouWCh0aGlzLnYpLCBrYyh0aGlzLnosIGEsIHIsIG0sIGwpLCB0aGlzLmMgPSAwKVxufTtcbmZ1bmN0aW9uIHpkKGEpIHtcbiAgdmFyIGIgPSBCZChhLmIsIGEudmEsIFwiL21haWwvaW1hZ2VzL2NsZWFyZG90LmdpZlwiKTtcbiAgTShiKTtcbiAgdWQoYi50b1N0cmluZygpLCA1RTMsIEIoYS5oYywgYSksIDMsIDJFMyk7XG4gIGEuRihtYylcbn1cbnUuaGMgPSBmdW5jdGlvbihhKSB7XG4gIGlmKGEpIHtcbiAgICB0aGlzLmMgPSAyLCBBZCh0aGlzKVxuICB9ZWxzZSB7XG4gICAgVihDZCk7XG4gICAgdmFyIGIgPSB0aGlzLmI7XG4gICAgYi5hLmRlYnVnKFwiVGVzdCBDb25uZWN0aW9uIEJsb2NrZWRcIik7XG4gICAgYi5oID0gYi5ULmg7XG4gICAgWihiLCA5KVxuICB9XG4gIGEgJiYgdGhpcy5GKHNjKVxufTtcbmZ1bmN0aW9uIEFkKGEpIHtcbiAgYS5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IHN0YXJ0aW5nIHN0YWdlIDJcIik7XG4gIGEueiA9IG5ldyBUKGEsIGEuYSwgaCwgaCwgaCk7XG4gIGEuei5YKGEudik7XG4gIHZhciBiID0gRGQoYS5iLCBhLkssIGEuRyk7XG4gIFYoRWQpO1xuICBpZihoYygpKSB7XG4gICAgc2IoYiwgXCJUWVBFXCIsIFwieG1saHR0cFwiKSwga2MoYS56LCBiLCByLCBhLkssIHIpXG4gIH1lbHNlIHtcbiAgICBzYihiLCBcIlRZUEVcIiwgXCJodG1sXCIpO1xuICAgIHZhciBjID0gYS56O1xuICAgIGEgPSBCb29sZWFuKGEuSyk7XG4gICAgYy5yYSA9IDM7XG4gICAgYy5TID0gTShiLm4oKSk7XG4gICAgR2MoYywgYSlcbiAgfVxufVxudS5nYiA9IGZ1bmN0aW9uKGEpIHtcbiAgcmV0dXJuIHRoaXMuYi5nYihhKVxufTtcbnUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy56ICYmICh0aGlzLnouY2FuY2VsKCksIHRoaXMueiA9IG0pO1xuICB0aGlzLmggPSAtMVxufTtcbnUuR2IgPSBiYShyKTtcbnUuT2IgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHRoaXMuaCA9IGEuaDtcbiAgaWYoMCA9PSB0aGlzLmMpIHtcbiAgICBpZih0aGlzLmEuZGVidWcoXCJUZXN0Q29ubmVjdGlvbjogR290IGRhdGEgZm9yIHN0YWdlIDFcIiksIGIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjID0gdGhpcy5PLnBhcnNlKGIpXG4gICAgICB9Y2F0Y2goZCkge1xuICAgICAgICBCYyh0aGlzLmEsIGQpO1xuICAgICAgICBGZCh0aGlzLmIsIHRoaXMpO1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuSyA9IHRoaXMuYi5jb3JyZWN0SG9zdFByZWZpeChjWzBdKTtcbiAgICAgIHRoaXMudmEgPSBjWzFdXG4gICAgfWVsc2Uge1xuICAgICAgdGhpcy5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IE51bGwgcmVzcG9uc2VUZXh0XCIpLCBGZCh0aGlzLmIsIHRoaXMpXG4gICAgfVxuICB9ZWxzZSB7XG4gICAgaWYoMiA9PSB0aGlzLmMpIHtcbiAgICAgIGlmKHRoaXMuVGEpIHtcbiAgICAgICAgVihHZCksIHRoaXMubWIgPSBDKClcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgaWYoXCIxMTExMVwiID09IGIpIHtcbiAgICAgICAgICBpZihWKEhkKSwgdGhpcy5UYSA9IGwsIHRoaXMuSmEgPSBDKCksIGMgPSB0aGlzLkphIC0gdGhpcy4kYiwgaGMoKSB8fCA1MDAgPiBjKSB7XG4gICAgICAgICAgICB0aGlzLmggPSAyMDAsIHRoaXMuei5jYW5jZWwoKSwgdGhpcy5hLmRlYnVnKFwiVGVzdCBjb25uZWN0aW9uIHN1Y2NlZWRlZDsgdXNpbmcgc3RyZWFtaW5nIGNvbm5lY3Rpb25cIiksIFYoSWQpLCBKZCh0aGlzLmIsIHRoaXMsIGwpXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgVihLZCksIHRoaXMuSmEgPSB0aGlzLm1iID0gQygpLCB0aGlzLlRhID0gclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudS5sYSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmggPSB0aGlzLnouaDtcbiAgaWYodGhpcy56LkkpIHtcbiAgICBpZigwID09IHRoaXMuYykge1xuICAgICAgdGhpcy5hLmRlYnVnKFwiVGVzdENvbm5lY3Rpb246IHJlcXVlc3QgY29tcGxldGUgZm9yIGluaXRpYWwgY2hlY2tcIiksIHRoaXMudmEgPyAodGhpcy5jID0gMSwgemQodGhpcykpIDogKHRoaXMuYyA9IDIsIEFkKHRoaXMpKVxuICAgIH1lbHNlIHtcbiAgICAgIGlmKDIgPT0gdGhpcy5jKSB7XG4gICAgICAgIHRoaXMuYS5kZWJ1ZyhcIlRlc3RDb25uZWN0aW9uOiByZXF1ZXN0IGNvbXBsZXRlIGZvciBzdGFnZSAyXCIpO1xuICAgICAgICB2YXIgYSA9IHI7XG4gICAgICAgIChhID0gaGMoKSA/IHRoaXMuVGEgOiAyMDAgPiB0aGlzLm1iIC0gdGhpcy5KYSA/IHIgOiBsKSA/ICh0aGlzLmEuZGVidWcoXCJUZXN0IGNvbm5lY3Rpb24gc3VjY2VlZGVkOyB1c2luZyBzdHJlYW1pbmcgY29ubmVjdGlvblwiKSwgVihJZCksIEpkKHRoaXMuYiwgdGhpcywgbCkpIDogKHRoaXMuYS5kZWJ1ZyhcIlRlc3QgY29ubmVjdGlvbiBmYWlsZWQ7IG5vdCB1c2luZyBzdHJlYW1pbmdcIiksIFYoTGQpLCBKZCh0aGlzLmIsIHRoaXMsIHIpKVxuICAgICAgfVxuICAgIH1cbiAgfWVsc2Uge1xuICAgIHRoaXMuYS5kZWJ1ZyhcIlRlc3RDb25uZWN0aW9uOiByZXF1ZXN0IGZhaWxlZCwgaW4gc3RhdGUgXCIgKyB0aGlzLmMpLCAwID09IHRoaXMuYyA/IFYoTWQpIDogMiA9PSB0aGlzLmMgJiYgVihOZCksIEZkKHRoaXMuYiwgdGhpcylcbiAgfVxufTtcbnUuWGEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYi5YYSgpXG59O1xudS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5iLmlzQWN0aXZlKClcbn07XG51LkYgPSBmdW5jdGlvbihhKSB7XG4gIHRoaXMuYi5GKGEpXG59O1xuZnVuY3Rpb24gT2QoYSwgYikge1xuICB0aGlzLnViID0gYSB8fCBtO1xuICB0aGlzLmMgPSBQZDtcbiAgdGhpcy5zID0gW107XG4gIHRoaXMuUCA9IFtdO1xuICB0aGlzLmEgPSBuZXcga2Q7XG4gIHRoaXMuTyA9IG5ldyBtZChtLCBsKTtcbiAgdGhpcy5CYiA9IGIgfHwgbVxufVxuZnVuY3Rpb24gUWQoYSwgYikge1xuICB0aGlzLktiID0gYTtcbiAgdGhpcy5tYXAgPSBiO1xuICB0aGlzLkVjID0gbVxufVxudSA9IE9kLnByb3RvdHlwZTtcbnUudiA9IG07XG51LndhID0gbTtcbnUubyA9IG07XG51LmsgPSBtO1xudS5HID0gbTtcbnUuS2EgPSBtO1xudS50YiA9IG07XG51LksgPSBtO1xudS5lYyA9IGw7XG51LnphID0gMDtcbnUucGMgPSAwO1xudS5JYSA9IHI7XG51LmUgPSBtO1xudS5EID0gbTtcbnUuTCA9IG07XG51LmFhID0gbTtcbnUuVCA9IG07XG51LnFiID0gbTtcbnUuZGMgPSBsO1xudS54YSA9IC0xO1xudS5KYiA9IC0xO1xudS5oID0gLTE7XG51LlUgPSAwO1xudS5mYSA9IDA7XG51LmZjID0gNUUzO1xudS5BYyA9IDFFNDtcbnUuamIgPSAyO1xudS5DYiA9IDJFNDtcbnUubmEgPSAwO1xudS5ZYSA9IHI7XG51LmdhID0gODtcbnZhciBQZCA9IDEsIFJkID0gbmV3IFViO1xuZnVuY3Rpb24gU2QoYSwgYikge1xuICBRLmNhbGwodGhpcywgXCJzdGF0ZXZlbnRcIiwgYSk7XG4gIHRoaXMuT2MgPSBiXG59XG5EKFNkLCBRKTtcbmZ1bmN0aW9uIFRkKGEsIGIsIGMsIGQpIHtcbiAgUS5jYWxsKHRoaXMsIFwidGltaW5nZXZlbnRcIiwgYSk7XG4gIHRoaXMuc2l6ZSA9IGI7XG4gIHRoaXMuTWMgPSBjO1xuICB0aGlzLkxjID0gZFxufVxuRChUZCwgUSk7XG52YXIgbWMgPSAxLCBzYyA9IDIsIHJjID0gMywgSmMgPSA0O1xuZnVuY3Rpb24gVWQoYSwgYikge1xuICBRLmNhbGwodGhpcywgXCJzZXJ2ZXJyZWFjaGFiaWxpdHlcIiwgYSk7XG4gIHRoaXMuS2MgPSBiXG59XG5EKFVkLCBRKTtcbnZhciB5ZCA9IDMsIENkID0gNCwgRWQgPSA1LCBIZCA9IDYsIEdkID0gNywgS2QgPSA4LCBNZCA9IDksIE5kID0gMTAsIExkID0gMTEsIElkID0gMTIsIHljID0gMTMsIHpjID0gMTQsIERjID0gMTUsIEVjID0gMTYsIEZjID0gMTcsIExjID0gMTgsIEhjID0gMjIsIGxkID0gXCJ5MmYlXCI7XG51ID0gT2QucHJvdG90eXBlO1xudS5mYiA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGYpIHtcbiAgdGhpcy5hLmRlYnVnKFwiY29ubmVjdCgpXCIpO1xuICBWKDApO1xuICB0aGlzLkcgPSBiO1xuICB0aGlzLndhID0gYyB8fCB7fTtcbiAgZCAmJiBmICE9PSBoICYmICh0aGlzLndhLk9TSUQgPSBkLCB0aGlzLndhLk9BSUQgPSBmKTtcbiAgdGhpcy5hLmRlYnVnKFwiY29ubmVjdFRlc3RfKClcIik7XG4gIFZkKHRoaXMpICYmICh0aGlzLlQgPSBuZXcgd2QodGhpcywgdGhpcy5hKSwgdGhpcy5ULlgodGhpcy52KSwgdGhpcy5ULlliKHRoaXMuTyksIHRoaXMuVC5mYihhKSlcbn07XG51LmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5hLmRlYnVnKFwiZGlzY29ubmVjdCgpXCIpO1xuICBXZCh0aGlzKTtcbiAgaWYoMyA9PSB0aGlzLmMpIHtcbiAgICB2YXIgYSA9IHRoaXMuemErKywgYiA9IHRoaXMuS2EubigpO1xuICAgIEsoYiwgXCJTSURcIiwgdGhpcy5ZKTtcbiAgICBLKGIsIFwiUklEXCIsIGEpO1xuICAgIEsoYiwgXCJUWVBFXCIsIFwidGVybWluYXRlXCIpO1xuICAgIFhkKHRoaXMsIGIpO1xuICAgIGEgPSBuZXcgVCh0aGlzLCB0aGlzLmEsIHRoaXMuWSwgYSwgaCk7XG4gICAgYS5yYSA9IDI7XG4gICAgYS5TID0gTShiLm4oKSk7XG4gICAgYiA9IG5ldyBJbWFnZTtcbiAgICBiLnNyYyA9IGEuUztcbiAgICBiLm9ubG9hZCA9IGIub25lcnJvciA9IEIoYS5rYywgYSk7XG4gICAgYS5vYSA9IEMoKTtcbiAgICBsYyhhKVxuICB9XG4gIFpkKHRoaXMpXG59O1xuZnVuY3Rpb24gV2QoYSkge1xuICBhLlQgJiYgKGEuVC5hYm9ydCgpLCBhLlQgPSBtKTtcbiAgYS5rICYmIChhLmsuY2FuY2VsKCksIGEuayA9IG0pO1xuICBhLkwgJiYgKHcuY2xlYXJUaW1lb3V0KGEuTCksIGEuTCA9IG0pO1xuICAkZChhKTtcbiAgYS5vICYmIChhLm8uY2FuY2VsKCksIGEubyA9IG0pO1xuICBhLkQgJiYgKHcuY2xlYXJUaW1lb3V0KGEuRCksIGEuRCA9IG0pXG59XG51LlggPSB0KFwidlwiKTtcbnUuWmIgPSB0KFwibmFcIik7XG51LkdiID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAwID09IHRoaXMuY1xufTtcbnUuWWIgPSB0KFwiT1wiKTtcbmZ1bmN0aW9uIGFlKGEpIHtcbiAgIWEubyAmJiAhYS5EICYmIChhLkQgPSBXKEIoYS5RYiwgYSksIDApLCBhLlUgPSAwKVxufVxudS5RYiA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5EID0gbTtcbiAgdGhpcy5hLmRlYnVnKFwic3RhcnRGb3J3YXJkQ2hhbm5lbF9cIik7XG4gIGlmKFZkKHRoaXMpKSB7XG4gICAgaWYodGhpcy5jID09IFBkKSB7XG4gICAgICBpZihhKSB7XG4gICAgICAgIHRoaXMuYS5IKFwiTm90IHN1cHBvc2VkIHRvIHJldHJ5IHRoZSBvcGVuXCIpXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHRoaXMuYS5kZWJ1ZyhcIm9wZW5fKClcIik7XG4gICAgICAgIHRoaXMuemEgPSBNYXRoLmZsb29yKDFFNSAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICBhID0gdGhpcy56YSsrO1xuICAgICAgICB2YXIgYiA9IG5ldyBUKHRoaXMsIHRoaXMuYSwgXCJcIiwgYSwgaCk7XG4gICAgICAgIGIuWCh0aGlzLnYpO1xuICAgICAgICB2YXIgYyA9IGJlKHRoaXMpLCBkID0gdGhpcy5LYS5uKCk7XG4gICAgICAgIEsoZCwgXCJSSURcIiwgYSk7XG4gICAgICAgIHRoaXMudWIgJiYgSyhkLCBcIkNWRVJcIiwgdGhpcy51Yik7XG4gICAgICAgIFhkKHRoaXMsIGQpO1xuICAgICAgICBpYyhiLCBkLCBjKTtcbiAgICAgICAgdGhpcy5vID0gYjtcbiAgICAgICAgdGhpcy5jID0gMlxuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIDMgPT0gdGhpcy5jICYmIChhID8gY2UodGhpcywgYSkgOiAwID09IHRoaXMucy5sZW5ndGggPyB0aGlzLmEuZGVidWcoXCJzdGFydEZvcndhcmRDaGFubmVsXyByZXR1cm5lZDogbm90aGluZyB0byBzZW5kXCIpIDogdGhpcy5vID8gdGhpcy5hLkgoXCJzdGFydEZvcndhcmRDaGFubmVsXyByZXR1cm5lZDogY29ubmVjdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzXCIpIDogKGNlKHRoaXMpLCB0aGlzLmEuZGVidWcoXCJzdGFydEZvcndhcmRDaGFubmVsXyBmaW5pc2hlZCwgc2VudCByZXF1ZXN0XCIpKSlcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjZShhLCBiKSB7XG4gIHZhciBjLCBkO1xuICBiID8gNiA8IGEuZ2EgPyAoYS5zID0gYS5QLmNvbmNhdChhLnMpLCBhLlAubGVuZ3RoID0gMCwgYyA9IGEuemEgLSAxLCBkID0gYmUoYSkpIDogKGMgPSBiLkEsIGQgPSBiLlcpIDogKGMgPSBhLnphKyssIGQgPSBiZShhKSk7XG4gIHZhciBmID0gYS5LYS5uKCk7XG4gIEsoZiwgXCJTSURcIiwgYS5ZKTtcbiAgSyhmLCBcIlJJRFwiLCBjKTtcbiAgSyhmLCBcIkFJRFwiLCBhLnhhKTtcbiAgWGQoYSwgZik7XG4gIGMgPSBuZXcgVChhLCBhLmEsIGEuWSwgYywgYS5VICsgMSk7XG4gIGMuWChhLnYpO1xuICBjLnNldFRpbWVvdXQoTWF0aC5yb3VuZCgwLjUgKiBhLkNiKSArIE1hdGgucm91bmQoMC41ICogYS5DYiAqIE1hdGgucmFuZG9tKCkpKTtcbiAgYS5vID0gYztcbiAgaWMoYywgZiwgZClcbn1cbmZ1bmN0aW9uIFhkKGEsIGIpIHtcbiAgaWYoYS5lKSB7XG4gICAgdmFyIGMgPSBhLmUuZ2V0QWRkaXRpb25hbFBhcmFtcyhhKTtcbiAgICBjICYmIGNiKGMsIGZ1bmN0aW9uKGEsIGMpIHtcbiAgICAgIEsoYiwgYywgYSlcbiAgICB9KVxuICB9XG59XG5mdW5jdGlvbiBiZShhKSB7XG4gIHZhciBiID0gTWF0aC5taW4oYS5zLmxlbmd0aCwgMUUzKSwgYyA9IFtcImNvdW50PVwiICsgYl0sIGQ7XG4gIDYgPCBhLmdhICYmIDAgPCBiID8gKGQgPSBhLnNbMF0uS2IsIGMucHVzaChcIm9mcz1cIiArIGQpKSA6IGQgPSAwO1xuICBmb3IodmFyIGYgPSAwO2YgPCBiO2YrKykge1xuICAgIHZhciBnID0gYS5zW2ZdLktiLCBrID0gYS5zW2ZdLm1hcCwgZyA9IDYgPj0gYS5nYSA/IGYgOiBnIC0gZDtcbiAgICB0cnkge1xuICAgICAgY2IoaywgZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBjLnB1c2goXCJyZXFcIiArIGcgKyBcIl9cIiArIGIgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhKSlcbiAgICAgIH0pXG4gICAgfWNhdGNoKHEpIHtcbiAgICAgIGMucHVzaChcInJlcVwiICsgZyArIFwiX3R5cGU9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoXCJfYmFkbWFwXCIpKSwgYS5lICYmIGEuZS5iYWRNYXBFcnJvcihhLCBrKVxuICAgIH1cbiAgfVxuICBhLlAgPSBhLlAuY29uY2F0KGEucy5zcGxpY2UoMCwgYikpO1xuICByZXR1cm4gYy5qb2luKFwiJlwiKVxufVxuZnVuY3Rpb24gZGUoYSkge1xuICAhYS5rICYmICFhLkwgJiYgKGEuc2IgPSAxLCBhLkwgPSBXKEIoYS5QYiwgYSksIDApLCBhLmZhID0gMClcbn1cbmZ1bmN0aW9uIGVlKGEpIHtcbiAgaWYoYS5rIHx8IGEuTCkge1xuICAgIHJldHVybiBhLmEuSChcIlJlcXVlc3QgYWxyZWFkeSBpbiBwcm9ncmVzc1wiKSwgclxuICB9XG4gIGlmKDMgPD0gYS5mYSkge1xuICAgIHJldHVybiByXG4gIH1cbiAgYS5hLmRlYnVnKFwiR29pbmcgdG8gcmV0cnkgR0VUXCIpO1xuICBhLnNiKys7XG4gIGEuTCA9IFcoQihhLlBiLCBhKSwgZmUoYSwgYS5mYSkpO1xuICBhLmZhKys7XG4gIHJldHVybiBsXG59XG51LlBiID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuTCA9IG07XG4gIGlmKFZkKHRoaXMpKSB7XG4gICAgdGhpcy5hLmRlYnVnKFwiQ3JlYXRpbmcgbmV3IEh0dHBSZXF1ZXN0XCIpO1xuICAgIHRoaXMuayA9IG5ldyBUKHRoaXMsIHRoaXMuYSwgdGhpcy5ZLCBcInJwY1wiLCB0aGlzLnNiKTtcbiAgICB0aGlzLmsuWCh0aGlzLnYpO1xuICAgIHRoaXMuay5aYih0aGlzLm5hKTtcbiAgICB2YXIgYSA9IHRoaXMudGIubigpO1xuICAgIEsoYSwgXCJSSURcIiwgXCJycGNcIik7XG4gICAgSyhhLCBcIlNJRFwiLCB0aGlzLlkpO1xuICAgIEsoYSwgXCJDSVwiLCB0aGlzLnFiID8gXCIwXCIgOiBcIjFcIik7XG4gICAgSyhhLCBcIkFJRFwiLCB0aGlzLnhhKTtcbiAgICBYZCh0aGlzLCBhKTtcbiAgICBpZihoYygpKSB7XG4gICAgICBLKGEsIFwiVFlQRVwiLCBcInhtbGh0dHBcIiksIGtjKHRoaXMuaywgYSwgbCwgdGhpcy5LLCByKVxuICAgIH1lbHNlIHtcbiAgICAgIEsoYSwgXCJUWVBFXCIsIFwiaHRtbFwiKTtcbiAgICAgIHZhciBiID0gdGhpcy5rLCBjID0gQm9vbGVhbih0aGlzLkspO1xuICAgICAgYi5yYSA9IDM7XG4gICAgICBiLlMgPSBNKGEubigpKTtcbiAgICAgIEdjKGIsIGMpXG4gICAgfVxuICAgIHRoaXMuYS5kZWJ1ZyhcIk5ldyBSZXF1ZXN0IGNyZWF0ZWRcIilcbiAgfVxufTtcbmZ1bmN0aW9uIFZkKGEpIHtcbiAgaWYoYS5lKSB7XG4gICAgdmFyIGIgPSBhLmUub2tUb01ha2VSZXF1ZXN0KGEpO1xuICAgIGlmKDAgIT0gYikge1xuICAgICAgcmV0dXJuIGEuYS5kZWJ1ZyhcIkhhbmRsZXIgcmV0dXJuZWQgZXJyb3IgY29kZSBmcm9tIG9rVG9NYWtlUmVxdWVzdFwiKSwgWihhLCBiKSwgclxuICAgIH1cbiAgfVxuICByZXR1cm4gbFxufVxuZnVuY3Rpb24gSmQoYSwgYiwgYykge1xuICBhLmEuZGVidWcoXCJUZXN0IENvbm5lY3Rpb24gRmluaXNoZWRcIik7XG4gIGEucWIgPSBhLmRjICYmIGM7XG4gIGEuaCA9IGIuaDtcbiAgYS5hLmRlYnVnKFwiY29ubmVjdENoYW5uZWxfKClcIik7XG4gIGEuaWMoUGQsIDApO1xuICBhLkthID0geGQoYSwgYS5HKTtcbiAgYWUoYSlcbn1cbmZ1bmN0aW9uIEZkKGEsIGIpIHtcbiAgYS5hLmRlYnVnKFwiVGVzdCBDb25uZWN0aW9uIEZhaWxlZFwiKTtcbiAgYS5oID0gYi5oO1xuICBaKGEsIDIpXG59XG51Lk9iID0gZnVuY3Rpb24oYSwgYikge1xuICBpZighKDAgPT0gdGhpcy5jIHx8IHRoaXMuayAhPSBhICYmIHRoaXMubyAhPSBhKSkge1xuICAgIGlmKHRoaXMuaCA9IGEuaCwgdGhpcy5vID09IGEgJiYgMyA9PSB0aGlzLmMpIHtcbiAgICAgIGlmKDcgPCB0aGlzLmdhKSB7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGMgPSB0aGlzLk8ucGFyc2UoYilcbiAgICAgICAgfWNhdGNoKGQpIHtcbiAgICAgICAgICBjID0gbVxuICAgICAgICB9XG4gICAgICAgIGlmKHgoYykgJiYgMyA9PSBjLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBmID0gYztcbiAgICAgICAgICBpZigwID09IGZbMF0pIHtcbiAgICAgICAgICAgIGE6IHtcbiAgICAgICAgICAgICAgaWYodGhpcy5hLmRlYnVnKFwiU2VydmVyIGNsYWltcyBvdXIgYmFja2NoYW5uZWwgaXMgbWlzc2luZy5cIiksIHRoaXMuTCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYS5kZWJ1ZyhcIkJ1dCB3ZSBhcmUgY3VycmVudGx5IHN0YXJ0aW5nIHRoZSByZXF1ZXN0LlwiKVxuICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYodGhpcy5rKSB7XG4gICAgICAgICAgICAgICAgICBpZih0aGlzLmsub2EgKyAzRTMgPCB0aGlzLm8ub2EpIHtcbiAgICAgICAgICAgICAgICAgICAgJGQodGhpcyksIHRoaXMuay5jYW5jZWwoKSwgdGhpcy5rID0gbVxuICAgICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBhXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5hLlooXCJXZSBkbyBub3QgaGF2ZSBhIEJhY2tDaGFubmVsIGVzdGFibGlzaGVkXCIpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVlKHRoaXMpO1xuICAgICAgICAgICAgICAgIFYoMTkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICB0aGlzLkpiID0gZlsxXSwgYyA9IHRoaXMuSmIgLSB0aGlzLnhhLCAwIDwgYyAmJiAoZiA9IGZbMl0sIHRoaXMuYS5kZWJ1ZyhmICsgXCIgYnl0ZXMgKGluIFwiICsgYyArIFwiIGFycmF5cykgYXJlIG91dHN0YW5kaW5nIG9uIHRoZSBCYWNrQ2hhbm5lbFwiKSwgMzc1MDAgPiBmICYmICh0aGlzLnFiICYmIDAgPT0gdGhpcy5mYSkgJiYgIXRoaXMuYWEgJiYgKHRoaXMuYWEgPSBXKEIodGhpcy5xYywgdGhpcyksIDZFMykpKVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgIHRoaXMuYS5kZWJ1ZyhcIkJhZCBQT1NUIHJlc3BvbnNlIGRhdGEgcmV0dXJuZWRcIiksIFoodGhpcywgMTEpXG4gICAgICAgIH1cbiAgICAgIH1lbHNlIHtcbiAgICAgICAgYiAhPSBsZCAmJiAodGhpcy5hLmRlYnVnKFwiQmFkIGRhdGEgcmV0dXJuZWQgLSBtaXNzaW5nL2ludmFsZCBtYWdpYyBjb29raWVcIiksIFoodGhpcywgMTEpKVxuICAgICAgfVxuICAgIH1lbHNlIHtcbiAgICAgIGlmKHRoaXMuayA9PSBhICYmICRkKHRoaXMpLCAhL15bXFxzXFx4YTBdKiQvLnRlc3QoYikpIHtcbiAgICAgICAgYyA9IHRoaXMuTy5wYXJzZShiKTtcbiAgICAgICAgZm9yKHZhciBmID0gdGhpcy5lICYmIHRoaXMuZS5jaGFubmVsSGFuZGxlTXVsdGlwbGVBcnJheXMgPyBbXSA6IG0sIGcgPSAwO2cgPCBjLmxlbmd0aDtnKyspIHtcbiAgICAgICAgICB2YXIgayA9IGNbZ107XG4gICAgICAgICAgdGhpcy54YSA9IGtbMF07XG4gICAgICAgICAgayA9IGtbMV07XG4gICAgICAgICAgMiA9PSB0aGlzLmMgPyBcImNcIiA9PSBrWzBdID8gKHRoaXMuWSA9IGtbMV0sIHRoaXMuSyA9IHRoaXMuY29ycmVjdEhvc3RQcmVmaXgoa1syXSksIGsgPSBrWzNdLCB0aGlzLmdhID0gayAhPSBtID8gayA6IDYsIHRoaXMuYyA9IDMsIHRoaXMuZSAmJiB0aGlzLmUuY2hhbm5lbE9wZW5lZCh0aGlzKSwgdGhpcy50YiA9IERkKHRoaXMsIHRoaXMuSywgdGhpcy5HKSwgZGUodGhpcykpIDogXCJzdG9wXCIgPT0ga1swXSAmJiBaKHRoaXMsIDcpIDogMyA9PSB0aGlzLmMgJiYgKFwic3RvcFwiID09IGtbMF0gPyAoZiAmJiBmLmxlbmd0aCAmJiAodGhpcy5lLmNoYW5uZWxIYW5kbGVNdWx0aXBsZUFycmF5cyh0aGlzLCBmKSwgZi5sZW5ndGggPSAwKSwgWih0aGlzLCA3KSkgOiBcIm5vb3BcIiAhPSBrWzBdICYmIChmID8gZi5wdXNoKGspIDogdGhpcy5lICYmIHRoaXMuZS5jaGFubmVsSGFuZGxlQXJyYXkodGhpcywgaykpLCB0aGlzLmZhID0gMClcbiAgICAgICAgfVxuICAgICAgICBmICYmIGYubGVuZ3RoICYmIHRoaXMuZS5jaGFubmVsSGFuZGxlTXVsdGlwbGVBcnJheXModGhpcywgZilcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG51LmNvcnJlY3RIb3N0UHJlZml4ID0gZnVuY3Rpb24oYSkge1xuICByZXR1cm4gdGhpcy5lYyA/IHRoaXMuZSA/IHRoaXMuZS5jb3JyZWN0SG9zdFByZWZpeChhKSA6IGEgOiBtXG59O1xudS5xYyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmFhICE9IG0gJiYgKHRoaXMuYWEgPSBtLCB0aGlzLmsuY2FuY2VsKCksIHRoaXMuayA9IG0sIGVlKHRoaXMpLCBWKDIwKSlcbn07XG5mdW5jdGlvbiAkZChhKSB7XG4gIGEuYWEgIT0gbSAmJiAody5jbGVhclRpbWVvdXQoYS5hYSksIGEuYWEgPSBtKVxufVxudS5sYSA9IGZ1bmN0aW9uKGEpIHtcbiAgdGhpcy5hLmRlYnVnKFwiUmVxdWVzdCBjb21wbGV0ZVwiKTtcbiAgdmFyIGI7XG4gIGlmKHRoaXMuayA9PSBhKSB7XG4gICAgJGQodGhpcyksIHRoaXMuayA9IG0sIGIgPSAyXG4gIH1lbHNlIHtcbiAgICBpZih0aGlzLm8gPT0gYSkge1xuICAgICAgdGhpcy5vID0gbSwgYiA9IDFcbiAgICB9ZWxzZSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgdGhpcy5oID0gYS5oO1xuICBpZigwICE9IHRoaXMuYykge1xuICAgIGlmKGEuSSkge1xuICAgICAgMSA9PSBiID8gKGIgPSBDKCkgLSBhLm9hLCBSZC5kaXNwYXRjaEV2ZW50KG5ldyBUZChSZCwgYS5XID8gYS5XLmxlbmd0aCA6IDAsIGIsIHRoaXMuVSkpLCBhZSh0aGlzKSwgdGhpcy5QLmxlbmd0aCA9IDApIDogZGUodGhpcylcbiAgICB9ZWxzZSB7XG4gICAgICB2YXIgYyA9IGEuRGIoKTtcbiAgICAgIGlmKDMgPT0gYyB8fCA3ID09IGMgfHwgMCA9PSBjICYmIDAgPCB0aGlzLmgpIHtcbiAgICAgICAgdGhpcy5hLmRlYnVnKFwiTm90IHJldHJ5aW5nIGR1ZSB0byBlcnJvciB0eXBlXCIpXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHRoaXMuYS5kZWJ1ZyhcIk1heWJlIHJldHJ5aW5nLCBsYXN0IGVycm9yOiBcIiArIGVjKGMsIHRoaXMuaCkpO1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgaWYoZCA9IDEgPT0gYikge1xuICAgICAgICAgIHRoaXMubyB8fCB0aGlzLkQgPyAodGhpcy5hLkgoXCJSZXF1ZXN0IGFscmVhZHkgaW4gcHJvZ3Jlc3NcIiksIGQgPSByKSA6IHRoaXMuYyA9PSBQZCB8fCB0aGlzLlUgPj0gKHRoaXMuSWEgPyAwIDogdGhpcy5qYikgPyBkID0gciA6ICh0aGlzLmEuZGVidWcoXCJHb2luZyB0byByZXRyeSBQT1NUXCIpLCB0aGlzLkQgPSBXKEIodGhpcy5RYiwgdGhpcywgYSksIGZlKHRoaXMsIHRoaXMuVSkpLCB0aGlzLlUrKywgZCA9IGwpXG4gICAgICAgIH1cbiAgICAgICAgaWYoZCB8fCAyID09IGIgJiYgZWUodGhpcykpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmEuZGVidWcoXCJFeGNlZWRlZCBtYXggbnVtYmVyIG9mIHJldHJpZXNcIilcbiAgICAgIH1cbiAgICAgIHRoaXMuYS5kZWJ1ZyhcIkVycm9yOiBIVFRQIHJlcXVlc3QgZmFpbGVkXCIpO1xuICAgICAgc3dpdGNoKGMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIFoodGhpcywgNSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBaKHRoaXMsIDEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIFoodGhpcywgNik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBaKHRoaXMsIDEyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBaKHRoaXMsIDIpXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gZmUoYSwgYikge1xuICB2YXIgYyA9IGEuZmMgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhLkFjKTtcbiAgYS5pc0FjdGl2ZSgpIHx8IChhLmEuZGVidWcoXCJJbmFjdGl2ZSBjaGFubmVsXCIpLCBjICo9IDIpO1xuICByZXR1cm4gYyAqIGJcbn1cbnUuaWMgPSBmdW5jdGlvbihhKSB7XG4gIDAgPD0gWWEoYXJndW1lbnRzLCB0aGlzLmMpIHx8IGUoRXJyb3IoXCJVbmV4cGVjdGVkIGNoYW5uZWwgc3RhdGU6IFwiICsgdGhpcy5jKSlcbn07XG5mdW5jdGlvbiBaKGEsIGIpIHtcbiAgYS5hLmluZm8oXCJFcnJvciBjb2RlIFwiICsgYik7XG4gIGlmKDIgPT0gYiB8fCA5ID09IGIpIHtcbiAgICB2YXIgYyA9IG07XG4gICAgYS5lICYmIChjID0gYS5lLmdldE5ldHdvcmtUZXN0SW1hZ2VVcmkoYSkpO1xuICAgIHZhciBkID0gQihhLkNjLCBhKTtcbiAgICBjIHx8IChjID0gbmV3IEkoXCIvL3d3dy5nb29nbGUuY29tL2ltYWdlcy9jbGVhcmRvdC5naWZcIiksIE0oYykpO1xuICAgIHZkKGMudG9TdHJpbmcoKSwgMUU0LCBkKVxuICB9ZWxzZSB7XG4gICAgVigyKVxuICB9XG4gIGdlKGEsIGIpXG59XG51LkNjID0gZnVuY3Rpb24oYSkge1xuICBhID8gKHRoaXMuYS5pbmZvKFwiU3VjY2Vzc2Z1bGx5IHBpbmdlZCBnb29nbGUuY29tXCIpLCBWKDIpKSA6ICh0aGlzLmEuaW5mbyhcIkZhaWxlZCB0byBwaW5nIGdvb2dsZS5jb21cIiksIFYoMSksIGdlKHRoaXMsIDgpKVxufTtcbmZ1bmN0aW9uIGdlKGEsIGIpIHtcbiAgYS5hLmRlYnVnKFwiSHR0cENoYW5uZWw6IGVycm9yIC0gXCIgKyBiKTtcbiAgYS5jID0gMDtcbiAgYS5lICYmIGEuZS5jaGFubmVsRXJyb3IoYSwgYik7XG4gIFpkKGEpO1xuICBXZChhKVxufVxuZnVuY3Rpb24gWmQoYSkge1xuICBhLmMgPSAwO1xuICBhLmggPSAtMTtcbiAgaWYoYS5lKSB7XG4gICAgaWYoMCA9PSBhLlAubGVuZ3RoICYmIDAgPT0gYS5zLmxlbmd0aCkge1xuICAgICAgYS5lLmNoYW5uZWxDbG9zZWQoYSlcbiAgICB9ZWxzZSB7XG4gICAgICBhLmEuZGVidWcoXCJOdW1iZXIgb2YgdW5kZWxpdmVyZWQgbWFwcywgcGVuZGluZzogXCIgKyBhLlAubGVuZ3RoICsgXCIsIG91dGdvaW5nOiBcIiArIGEucy5sZW5ndGgpO1xuICAgICAgdmFyIGIgPSBhYihhLlApLCBjID0gYWIoYS5zKTtcbiAgICAgIGEuUC5sZW5ndGggPSAwO1xuICAgICAgYS5zLmxlbmd0aCA9IDA7XG4gICAgICBhLmUuY2hhbm5lbENsb3NlZChhLCBiLCBjKVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24geGQoYSwgYikge1xuICB2YXIgYyA9IEJkKGEsIG0sIGIpO1xuICBhLmEuZGVidWcoXCJHZXRGb3J3YXJkQ2hhbm5lbFVyaTogXCIgKyBjKTtcbiAgcmV0dXJuIGNcbn1cbmZ1bmN0aW9uIERkKGEsIGIsIGMpIHtcbiAgYiA9IEJkKGEsIGEuWGEoKSA/IGIgOiBtLCBjKTtcbiAgYS5hLmRlYnVnKFwiR2V0QmFja0NoYW5uZWxVcmk6IFwiICsgYik7XG4gIHJldHVybiBiXG59XG5mdW5jdGlvbiBCZChhLCBiLCBjKSB7XG4gIHZhciBkID0gYyBpbnN0YW5jZW9mIEkgPyBjLm4oKSA6IG5ldyBJKGMsIGgpO1xuICBpZihcIlwiICE9IGQuaWEpIHtcbiAgICBiICYmIGhiKGQsIGIgKyBcIi5cIiArIGQuaWEpLCBpYihkLCBkLkFhKVxuICB9ZWxzZSB7XG4gICAgdmFyIGYgPSB3aW5kb3cubG9jYXRpb24sIGQgPSB1YihmLnByb3RvY29sLCBiID8gYiArIFwiLlwiICsgZi5ob3N0bmFtZSA6IGYuaG9zdG5hbWUsIGYucG9ydCwgYylcbiAgfVxuICBhLndhICYmIGNiKGEud2EsIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICBLKGQsIGIsIGEpXG4gIH0pO1xuICBLKGQsIFwiVkVSXCIsIGEuZ2EpO1xuICBYZChhLCBkKTtcbiAgcmV0dXJuIGRcbn1cbnUuZ2IgPSBmdW5jdGlvbihhKSB7XG4gIGEgJiYgIXRoaXMuWWEgJiYgZShFcnJvcihcIkNhbid0IGNyZWF0ZSBzZWNvbmRhcnkgZG9tYWluIGNhcGFibGUgWGhySW8gb2JqZWN0LlwiKSk7XG4gIGEgPSBuZXcgbmQ7XG4gIGEuYmMgPSB0aGlzLllhO1xuICByZXR1cm4gYVxufTtcbnUuaXNBY3RpdmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuISF0aGlzLmUgJiYgdGhpcy5lLmlzQWN0aXZlKHRoaXMpXG59O1xuZnVuY3Rpb24gVyhhLCBiKSB7XG4gIGhhKGEpIHx8IGUoRXJyb3IoXCJGbiBtdXN0IG5vdCBiZSBudWxsIGFuZCBtdXN0IGJlIGEgZnVuY3Rpb25cIikpO1xuICByZXR1cm4gdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGEoKVxuICB9LCBiKVxufVxudS5GID0gZnVuY3Rpb24oYSkge1xuICBSZC5kaXNwYXRjaEV2ZW50KG5ldyBVZChSZCwgYSkpXG59O1xuZnVuY3Rpb24gVihhKSB7XG4gIFJkLmRpc3BhdGNoRXZlbnQobmV3IFNkKFJkLCBhKSlcbn1cbnUuWGEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuWWEgfHwgIWhjKClcbn07XG5mdW5jdGlvbiBoZSgpIHtcbn1cbnUgPSBoZS5wcm90b3R5cGU7XG51LmNoYW5uZWxIYW5kbGVNdWx0aXBsZUFycmF5cyA9IG07XG51Lm9rVG9NYWtlUmVxdWVzdCA9IGJhKDApO1xudS5jaGFubmVsT3BlbmVkID0gcygpO1xudS5jaGFubmVsSGFuZGxlQXJyYXkgPSBzKCk7XG51LmNoYW5uZWxFcnJvciA9IHMoKTtcbnUuY2hhbm5lbENsb3NlZCA9IHMoKTtcbnUuZ2V0QWRkaXRpb25hbFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm57fVxufTtcbnUuZ2V0TmV0d29ya1Rlc3RJbWFnZVVyaSA9IGJhKG0pO1xudS5pc0FjdGl2ZSA9IGJhKGwpO1xudS5iYWRNYXBFcnJvciA9IHMoKTtcbnUuY29ycmVjdEhvc3RQcmVmaXggPSBmdW5jdGlvbihhKSB7XG4gIHJldHVybiBhXG59O1xudmFyICQsIGllLCBqZSA9IFtdLnNsaWNlO1xuaWUgPSB7MDpcIk9rXCIsIDQ6XCJVc2VyIGlzIGxvZ2dpbmcgb3V0XCIsIDY6XCJVbmtub3duIHNlc3Npb24gSURcIiwgNzpcIlN0b3BwZWQgYnkgc2VydmVyXCIsIDg6XCJHZW5lcmFsIG5ldHdvcmsgZXJyb3JcIiwgMjpcIlJlcXVlc3QgZmFpbGVkXCIsIDk6XCJCbG9ja2VkIGJ5IGEgbmV0d29yayBhZG1pbmlzdHJhdG9yXCIsIDU6XCJObyBkYXRhIGZyb20gc2VydmVyXCIsIDEwOlwiR290IGJhZCBkYXRhIGZyb20gdGhlIHNlcnZlclwiLCAxMTpcIkdvdCBhIGJhZCByZXNwb25zZSBmcm9tIHRoZSBzZXJ2ZXJcIn07XG4kID0gZnVuY3Rpb24oYSwgYikge1xuICB2YXIgYywgZCwgZiwgZywgaywgcSwgbiwgeSwgcCwgdjtcbiAgeSA9IHRoaXM7XG4gIGEgfHwgKGEgPSBcImNoYW5uZWxcIik7XG4gIGEubWF0Y2goLzpcXC9cXC8vKSAmJiBhLnJlcGxhY2UoL153cy8sIFwiaHR0cFwiKTtcbiAgYiB8fCAoYiA9IHt9KTtcbiAgaWYoeChiIHx8IFwic3RyaW5nXCIgPT09IHR5cGVvZiBiKSkge1xuICAgIGIgPSB7fVxuICB9XG4gIHEgPSBiLnJlY29ubmVjdFRpbWUgfHwgM0UzO1xuICB2ID0gZnVuY3Rpb24oYSkge1xuICAgIHkucmVhZHlTdGF0ZSA9IHkucmVhZHlTdGF0ZSA9IGFcbiAgfTtcbiAgdih0aGlzLkNMT1NFRCk7XG4gIHAgPSBtO1xuICBnID0gYi5KYztcbiAgYyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhLCBiO1xuICAgIGIgPSBhcmd1bWVudHNbMF07XG4gICAgYSA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IGplLmNhbGwoYXJndW1lbnRzLCAxKSA6IFtdO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm5cImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB5W2JdID8geVtiXS5hcHBseSh5LCBhKSA6IGhcbiAgICB9Y2F0Y2goYykge1xuICAgICAgYSA9IGMsIFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBjb25zb2xlICYmIGNvbnNvbGUgIT09IG0gJiYgY29uc29sZS5lcnJvcihhLnN0YWNrKSwgZShhKVxuICAgIH1cbiAgfTtcbiAgZCA9IG5ldyBoZTtcbiAgZC5jaGFubmVsT3BlbmVkID0gZnVuY3Rpb24oKSB7XG4gICAgZyA9IHA7XG4gICAgdigkLk9QRU4pO1xuICAgIHJldHVybiBjKFwib25vcGVuXCIpXG4gIH07XG4gIGYgPSBtO1xuICBkLmNoYW5uZWxFcnJvciA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgZDtcbiAgICBkID0gaWVbYl07XG4gICAgZiA9IGI7XG4gICAgdigkLmJiKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGMoXCJvbmVycm9yXCIsIGQsIGIpXG4gICAgfWNhdGNoKGcpIHtcbiAgICB9XG4gIH07XG4gIG4gPSBtO1xuICBkLmNoYW5uZWxDbG9zZWQgPSBmdW5jdGlvbihhLCBkLCBnKSB7XG4gICAgaWYoeS5yZWFkeVN0YXRlICE9PSAkLkNMT1NFRCkge1xuICAgICAgcCA9IG07XG4gICAgICBhID0gZiA/IGllW2ZdIDogXCJDbG9zZWRcIjtcbiAgICAgIHYoJC5DTE9TRUQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYyhcIm9uY2xvc2VcIiwgYSwgZCwgZylcbiAgICAgIH1jYXRjaChrZSkge1xuICAgICAgfVxuICAgICAgYi5yZWNvbm5lY3QgJiYgKDcgIT09IGYgJiYgMCAhPT0gZikgJiYgKGQgPSA2ID09PSBmID8gMCA6IHEsIGNsZWFyVGltZW91dChuKSwgbiA9IHNldFRpbWVvdXQoaywgZCkpO1xuICAgICAgcmV0dXJuIGYgPSBtXG4gICAgfVxuICB9O1xuICBkLmNoYW5uZWxIYW5kbGVBcnJheSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYyhcIm9ubWVzc2FnZVwiLCBiKVxuICB9O1xuICBrID0gZnVuY3Rpb24oKSB7XG4gICAgcCAmJiBlKEVycm9yKFwiUmVjb25uZWN0KCkgY2FsbGVkIGZyb20gaW52YWxpZCBzdGF0ZVwiKSk7XG4gICAgdigkLkNPTk5FQ1RJTkcpO1xuICAgIGMoXCJvbmNvbm5lY3RpbmdcIik7XG4gICAgY2xlYXJUaW1lb3V0KG4pO1xuICAgIHAgPSBuZXcgT2QoYi5hcHBWZXJzaW9uLCBnICE9IG0gPyBnLkJiIDogaCk7XG4gICAgYi5jcm9zc0RvbWFpblhociAmJiAocC5ZYSA9IGwpO1xuICAgIHAuZSA9IGQ7XG4gICAgZiA9IG07XG4gICAgaWYoYi5mYWlsRmFzdCkge1xuICAgICAgdmFyIGsgPSBwO1xuICAgICAgay5JYSA9IGw7XG4gICAgICBrLmEuaW5mbyhcInNldEZhaWxGYXN0OiB0cnVlXCIpO1xuICAgICAgaWYoKGsubyB8fCBrLkQpICYmIGsuVSA+IChrLklhID8gMCA6IGsuamIpKSB7XG4gICAgICAgIGsuYS5pbmZvKFwiUmV0cnkgY291bnQgXCIgKyBrLlUgKyBcIiA+IG5ldyBtYXhSZXRyaWVzIFwiICsgKGsuSWEgPyAwIDogay5qYikgKyBcIi4gRmFpbCBpbW1lZGlhdGVseSFcIiksIGsubyA/IChrLm8uY2FuY2VsKCksIGsubGEoay5vKSkgOiAody5jbGVhclRpbWVvdXQoay5EKSwgay5EID0gbSwgWihrLCAyKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHAuZmIoXCJcIiArIGEgKyBcIi90ZXN0XCIsIFwiXCIgKyBhICsgXCIvYmluZFwiLCBtLCBnICE9IG0gPyBnLlkgOiBoLCBnICE9IG0gPyBnLnhhIDogaClcbiAgfTtcbiAgdGhpcy5vcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgeS5yZWFkeVN0YXRlICE9PSB5LkNMT1NFRCAmJiBlKEVycm9yKFwiQWxyZWFkeSBvcGVuXCIpKTtcbiAgICByZXR1cm4gaygpXG4gIH07XG4gIHRoaXMuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICBjbGVhclRpbWVvdXQobik7XG4gICAgZiA9IDA7XG4gICAgaWYoeS5yZWFkeVN0YXRlICE9PSAkLkNMT1NFRCkge1xuICAgICAgcmV0dXJuIHYoJC5iYiksIHAuZGlzY29ubmVjdCgpXG4gICAgfVxuICB9O1xuICB0aGlzLnNlbmRNYXAgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIGI7XG4gICAgKChiID0geS5yZWFkeVN0YXRlKSA9PT0gJC5iYiB8fCBiID09PSAkLkNMT1NFRCkgJiYgZShFcnJvcihcIkNhbm5vdCBzZW5kIHRvIGEgY2xvc2VkIGNvbm5lY3Rpb25cIikpO1xuICAgIGIgPSBwO1xuICAgIDAgPT0gYi5jICYmIGUoRXJyb3IoXCJJbnZhbGlkIG9wZXJhdGlvbjogc2VuZGluZyBtYXAgd2hlbiBzdGF0ZSBpcyBjbG9zZWRcIikpO1xuICAgIDFFMyA9PSBiLnMubGVuZ3RoICYmIGIuYS5IKFwiQWxyZWFkeSBoYXZlIDEwMDAgcXVldWVkIG1hcHMgdXBvbiBxdWV1ZWluZyBcIiArIE9jKGEpKTtcbiAgICBiLnMucHVzaChuZXcgUWQoYi5wYysrLCBhKSk7XG4gICAgKDIgPT0gYi5jIHx8IDMgPT0gYi5jKSAmJiBhZShiKVxuICB9O1xuICB0aGlzLnNlbmQgPSBmdW5jdGlvbihhKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZE1hcCh7SlNPTjpPYyhhKX0pXG4gIH07XG4gIGsoKTtcbiAgcmV0dXJuIHRoaXNcbn07XG4kLnByb3RvdHlwZS5DT05ORUNUSU5HID0gJC5DT05ORUNUSU5HID0gJC5DT05ORUNUSU5HID0gMDtcbiQucHJvdG90eXBlLk9QRU4gPSAkLk9QRU4gPSAkLk9QRU4gPSAxO1xuJC5wcm90b3R5cGUuQ0xPU0lORyA9ICQuQ0xPU0lORyA9ICQuYmIgPSAyO1xuJC5wcm90b3R5cGUuQ0xPU0VEID0gJC5DTE9TRUQgPSAkLkNMT1NFRCA9IDM7XG4oXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGV4cG9ydHMgJiYgZXhwb3J0cyAhPT0gbSA/IGV4cG9ydHMgOiB3aW5kb3cpLkJDU29ja2V0ID0gJDtcblxufSkoKTtcbiIsIihmdW5jdGlvbihwcm9jZXNzLF9fZGlybmFtZSl7dmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vTW9kZWwnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmFjZXI7XG5cbmZ1bmN0aW9uIFJhY2VyKCkgeyBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTsgfVxuXG51dGlsLm1lcmdlSW50byhSYWNlci5wcm90b3R5cGUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG4vLyBNYWtlIGNsYXNzZXMgYWNjZXNzaWJsZSBmb3IgdXNlIGJ5IHBsdWdpbnMgYW5kIHRlc3RzXG5SYWNlci5wcm90b3R5cGUuTW9kZWwgPSBNb2RlbDtcblJhY2VyLnByb3RvdHlwZS51dGlsID0gdXRpbDtcblxuLy8gU3VwcG9ydCBwbHVnaW5zIG9uIHJhY2VyIGluc3RhbmNlc1xuUmFjZXIucHJvdG90eXBlLnVzZSA9IHV0aWwudXNlO1xuXG5SYWNlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHJhY2VyID0gdGhpcztcblxuICBwcm9jZXNzLmVudi5OT0RFX0VOViA9IGRhdGEubm9kZUVudjtcblxuICAvLyBJbml0IGlzIGV4ZWN1dGVkIGFzeW5jIHNvIHRoYXQgcGx1Z2lucyBjYW4gZXh0ZW5kIFJhY2VyIGV2ZW4gaWYgdGhleSBhcmVcbiAgLy8gaW5jbHVkZWQgYWZ0ZXIgdGhlIG1haW4gZW50cnkgcG9pbnQgaW4gdGhlIGJ1bmRsZVxuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtb2RlbCA9IG5ldyBNb2RlbDtcblxuICAgIHJhY2VyLmVtaXQoJ21vZGVsJywgbW9kZWwpO1xuXG4gICAgbW9kZWwuX2NyZWF0ZUNvbm5lY3Rpb24oZGF0YSk7XG5cbiAgICAvLyBSZS1jcmVhdGUgZG9jdW1lbnRzIGZvciBhbGwgbW9kZWwgZGF0YVxuICAgIGZvciAodmFyIGNvbGxlY3Rpb25OYW1lIGluIGRhdGEuY29sbGVjdGlvbnMpIHtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gZGF0YS5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uTmFtZV07XG4gICAgICBmb3IgKHZhciBpZCBpbiBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHZhciBkb2MgPSBtb2RlbC5nZXRPckNyZWF0ZURvYyhjb2xsZWN0aW9uTmFtZSwgaWQsIGNvbGxlY3Rpb25baWRdKTtcbiAgICAgICAgaWYgKGRvYy5zaGFyZURvYykge1xuICAgICAgICAgIG1vZGVsLl9sb2FkVmVyc2lvbnNbY29sbGVjdGlvbk5hbWUgKyAnLicgKyBpZF0gPSBkb2Muc2hhcmVEb2MudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFN1cHBvcnQgcmUtaW5pdCB3aGVuIHRoZXJlIGFyZSBjb250ZXh0cyBvdGhlciB0aGFuIHJvb3RcbiAgICB2YXIgY29udGV4dCA9IGRhdGEuY29udGV4dHMucm9vdDtcbiAgICAvLyBSZS1zdWJzY3JpYmUgdG8gZG9jdW1lbnQgc3Vic2NyaXB0aW9uc1xuICAgIGZvciAodmFyIHBhdGggaW4gY29udGV4dC5zdWJzY3JpYmVkRG9jcykge1xuICAgICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgICAgbW9kZWwuc3Vic2NyaWJlRG9jKHNlZ21lbnRzWzBdLCBzZWdtZW50c1sxXSk7XG4gICAgICBtb2RlbC5fc3Vic2NyaWJlZERvY3NbcGF0aF0gPSBjb250ZXh0LnN1YnNjcmliZWREb2NzW3BhdGhdO1xuICAgIH1cbiAgICAvLyBJbml0IGZldGNoZWREb2NzIGNvdW50c1xuICAgIGZvciAodmFyIHBhdGggaW4gY29udGV4dC5mZXRjaGVkRG9jcykge1xuICAgICAgbW9kZWwuX2ZldGNoZWREb2NzW3BhdGhdID0gY29udGV4dC5mZXRjaGVkRG9jc1twYXRoXTtcbiAgICB9XG5cbiAgICB2YXIgc2lsZW50TW9kZWwgPSBtb2RlbC5zaWxlbnQoKTtcbiAgICAvLyBSZS1jcmVhdGUgcmVmc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5yZWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGEucmVmc1tpXTtcbiAgICAgIHNpbGVudE1vZGVsLnJlZihpdGVtWzBdLCBpdGVtWzFdKTtcbiAgICB9XG4gICAgLy8gUmUtY3JlYXRlIHJlZkxpc3RzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnJlZkxpc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaXRlbSA9IGRhdGEucmVmTGlzdHNbaV07XG4gICAgICBzaWxlbnRNb2RlbC5yZWZMaXN0KGl0ZW1bMF0sIGl0ZW1bMV0sIGl0ZW1bMl0sIGl0ZW1bM10pO1xuICAgIH1cbiAgICAvLyBSZS1jcmVhdGUgZm5zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmZucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhLmZuc1tpXTtcbiAgICAgIHNpbGVudE1vZGVsLnN0YXJ0LmFwcGx5KHNpbGVudE1vZGVsLCBpdGVtKTtcbiAgICB9XG4gICAgLy8gUmUtY3JlYXRlIGZpbHRlcnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkYXRhLmZpbHRlcnNbaV07XG4gICAgICB2YXIgZmlsdGVyID0gc2lsZW50TW9kZWwuX2ZpbHRlcnMuYWRkKGl0ZW1bMF0sIGl0ZW1bMV0sIGl0ZW1bMl0pO1xuICAgICAgZmlsdGVyLnJlZihpdGVtWzNdKTtcbiAgICB9XG4gICAgLy8gSW5pdCBhbmQgcmUtc3Vic2NyaWJlIHF1ZXJpZXMgYXMgYXBwcm9wcmlhdGVcbiAgICBtb2RlbC5faW5pdFF1ZXJpZXMoZGF0YS5xdWVyaWVzKTtcblxuICAgIHJhY2VyLl9tb2RlbCA9IG1vZGVsO1xuICAgIHJhY2VyLmVtaXQoJ3JlYWR5JywgbW9kZWwpO1xuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SYWNlci5wcm90b3R5cGUucmVhZHkgPSBmdW5jdGlvbihjYikge1xuICBpZiAodGhpcy5fbW9kZWwpIHtcbiAgICAvLyBDYWxsYmFjayBhc3luYyBpbiBjYXNlIHRoZSBjb2RlIGRlcGVuZHMgb24gc2NyaXB0cyBpbmNsdWRlZCBhZnRlciBpblxuICAgIC8vIHRoZSBidW5kbGUgYW5kIGlzIGdhdGVkIGJ5IGEgcmVhZHlcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IodGhpcy5fbW9kZWwpO1xuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLm9uY2UoJ3JlYWR5JywgY2IpO1xufTtcblxudXRpbC5zZXJ2ZXJSZXF1aXJlKF9fZGlybmFtZSArICcvUmFjZXIuc2VydmVyLmpzJyk7XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSxcIi9ub2RlX21vZHVsZXMvcmFjZXIvbGliXCIpIiwiKGZ1bmN0aW9uKHByb2Nlc3Mpe3ZhciBkZWVwSXMgPSByZXF1aXJlKCdkZWVwLWlzJyk7XG5cbnZhciBpc1NlcnZlciA9IHByb2Nlc3MudGl0bGUgIT09ICdicm93c2VyJztcbnZhciBpc1Byb2R1Y3Rpb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTZXJ2ZXI6IGlzU2VydmVyXG4sIGlzUHJvZHVjdGlvbjogaXNQcm9kdWN0aW9uXG5cbiwgYXN5bmNHcm91cDogYXN5bmNHcm91cFxuLCBjb250YWluczogY29udGFpbnNcbiwgY29weU9iamVjdDogY29weU9iamVjdFxuLCBkZWVwQ29weTogZGVlcENvcHlcbiwgZGVlcEVxdWFsOiBkZWVwSXNcbiwgZXF1YWw6IGVxdWFsXG4sIGVxdWFsc05hTjogZXF1YWxzTmFOXG4sIG1lcmdlSW50bzogbWVyZ2VJbnRvXG4sIG1heUltcGFjdDogbWF5SW1wYWN0XG4sIG1heUltcGFjdEFueTogbWF5SW1wYWN0QW55XG4sIHNlcnZlclJlcXVpcmU6IHNlcnZlclJlcXVpcmVcbiwgdXNlOiB1c2Vcbn07XG5cbmZ1bmN0aW9uIGFzeW5jR3JvdXAoY2IpIHtcbiAgdmFyIGdyb3VwID0gbmV3IEFzeW5jR3JvdXAoY2IpO1xuICByZXR1cm4gZnVuY3Rpb24gYXN5bmNHcm91cEFkZCgpIHtcbiAgICByZXR1cm4gZ3JvdXAuYWRkKCk7XG4gIH07XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYihlcnIpXG4gKi9cbmZ1bmN0aW9uIEFzeW5jR3JvdXAoY2IpIHtcbiAgdGhpcy5jYiA9IGNiO1xuICB0aGlzLmlzRG9uZSA9IGZhbHNlO1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbkFzeW5jR3JvdXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNvdW50Kys7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIGZ1bmN0aW9uKGVycikge1xuICAgIHNlbGYuY291bnQtLTtcbiAgICBpZiAoc2VsZi5pc0RvbmUpIHJldHVybjtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzZWxmLmlzRG9uZSA9IHRydWU7XG4gICAgICBzZWxmLmNiKGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChzZWxmLmNvdW50ID4gMCkgcmV0dXJuO1xuICAgIHNlbGYuaXNEb25lID0gdHJ1ZTtcbiAgICBzZWxmLmNiKCk7XG4gIH07XG59O1xuXG5mdW5jdGlvbiBjb250YWlucyhzZWdtZW50cywgdGVzdFNlZ21lbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc2VnbWVudHNbaV0gIT09IHRlc3RTZWdtZW50c1tpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb3B5T2JqZWN0KG9iamVjdCkge1xuICB2YXIgb3V0ID0gbmV3IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgb3V0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gZGVlcENvcHkodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIG5ldyBEYXRlKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHZhciBjb3B5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgY29weSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IHZhbHVlLmxlbmd0aDsgaS0tOykge1xuICAgICAgICBjb3B5W2ldID0gZGVlcENvcHkodmFsdWVbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIGNvcHkgPSBuZXcgdmFsdWUuY29uc3RydWN0b3I7XG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjb3B5W2tleV0gPSBkZWVwQ29weSh2YWx1ZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIHJldHVybiAoYSA9PT0gYikgfHwgKGVxdWFsc05hTihhKSAmJiBlcXVhbHNOYU4oYikpO1xufVxuXG5mdW5jdGlvbiBlcXVhbHNOYU4oeCkge1xuICByZXR1cm4geCAhPT0geDtcbn1cblxuZnVuY3Rpb24gbWF5SW1wYWN0QW55KHNlZ21lbnRzTGlzdCwgdGVzdFNlZ21lbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdtZW50c0xpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAobWF5SW1wYWN0KHNlZ21lbnRzTGlzdFtpXSwgdGVzdFNlZ21lbnRzKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtYXlJbXBhY3Qoc2VnbWVudHMsIHRlc3RTZWdtZW50cykge1xuICB2YXIgbGVuID0gTWF0aC5taW4oc2VnbWVudHMubGVuZ3RoLCB0ZXN0U2VnbWVudHMubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChzZWdtZW50c1tpXSAhPT0gdGVzdFNlZ21lbnRzW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG1lcmdlSW50byh0bywgZnJvbSkge1xuICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgIHRvW2tleV0gPSBmcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvO1xufVxuXG5mdW5jdGlvbiBzZXJ2ZXJSZXF1aXJlKG5hbWUpIHtcbiAgaWYgKCFpc1NlcnZlcikgcmV0dXJuO1xuICAvLyBUcmlja3MgQnJvd3NlcmlmeSBpbnRvIG5vdCBsb2dnaW5nIGEgd2FybmluZ1xuICB2YXIgX3JlcXVpcmUgPSByZXF1aXJlO1xuICByZXR1cm4gX3JlcXVpcmUobmFtZSk7XG59XG5cbmZ1bmN0aW9uIHVzZShwbHVnaW4sIG9wdGlvbnMpIHtcbiAgLy8gU2VydmVyLXNpZGUgcGx1Z2lucyBtYXkgYmUgaW5jbHVkZWQgdmlhIGZpbGVuYW1lXG4gIGlmICh0eXBlb2YgcGx1Z2luID09PSAnc3RyaW5nJykge1xuICAgIGlmICghaXNTZXJ2ZXIpIHJldHVybiB0aGlzO1xuICAgIHBsdWdpbiA9IHNlcnZlclJlcXVpcmUocGx1Z2luKTtcbiAgfVxuXG4gIC8vIERvbid0IGluY2x1ZGUgYSBwbHVnaW4gbW9yZSB0aGFuIG9uY2VcbiAgdmFyIHBsdWdpbnMgPSB0aGlzLl9wbHVnaW5zIHx8ICh0aGlzLl9wbHVnaW5zID0gW10pO1xuICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgcGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwidmFyIE1vZGVsID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5leHBvcnRzLm1peGluID0ge307XG5cbk1vZGVsLnByb3RvdHlwZS5fc3BsaXRQYXRoID0gZnVuY3Rpb24oc3VicGF0aCkge1xuICB2YXIgcGF0aCA9IHRoaXMucGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIChwYXRoICYmIHBhdGguc3BsaXQoJy4nKSkgfHwgW107XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhdGggZXF1aXZhbGVudCB0byB0aGUgcGF0aCBvZiB0aGUgY3VycmVudCBzY29wZWQgbW9kZWwgcGx1c1xuICogKG9wdGlvbmFsbHkpIGEgc3VmZml4IHN1YnBhdGhcbiAqXG4gKiBAb3B0aW9uYWwgQHBhcmFtIHtTdHJpbmd9IHN1YnBhdGhcbiAqIEByZXR1cm4ge1N0cmluZ30gYWJzb2x1dGUgcGF0aFxuICogQGFwaSBwdWJsaWNcbiAqL1xuTW9kZWwucHJvdG90eXBlLnBhdGggPSBmdW5jdGlvbihzdWJwYXRoKSB7XG4gIGlmIChzdWJwYXRoID09IG51bGwgfHwgc3VicGF0aCA9PT0gJycpIHJldHVybiAodGhpcy5fYXQpID8gdGhpcy5fYXQgOiAnJztcbiAgaWYgKHR5cGVvZiBzdWJwYXRoID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc3VicGF0aCA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gKHRoaXMuX2F0KSA/IHRoaXMuX2F0ICsgJy4nICsgc3VicGF0aCA6ICcnICsgc3VicGF0aDtcbiAgfVxuICBpZiAodHlwZW9mIHN1YnBhdGgucGF0aCA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHN1YnBhdGgucGF0aCgpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLmlzUGF0aCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgcmV0dXJuIHRoaXMucGF0aChzdWJwYXRoKSAhPSBudWxsO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgc2NvcGVkID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgc2NvcGVkLl9hdCA9IHBhdGg7XG4gIHJldHVybiBzY29wZWQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG1vZGVsIG9iamVjdCBzY29wZWQgdG8gYSBwYXJ0aWN1bGFyIHBhdGguXG4gKiBFeGFtcGxlOlxuICogICAgIHZhciB1c2VyID0gbW9kZWwuYXQoJ3VzZXJzLjEnKTtcbiAqICAgICB1c2VyLnNldCgndXNlcm5hbWUnLCAnYnJpYW4nKTtcbiAqICAgICB1c2VyLm9uKCdwdXNoJywgJ3RvZG9zJywgZnVuY3Rpb24gKHRvZG8pIHtcbiAqICAgICAgIC8vIC4uLlxuICogICAgIH0pO1xuICpcbiAqICBAcGFyYW0ge1N0cmluZ30gc2VnbWVudFxuICogIEByZXR1cm4ge01vZGVsfSBhIHNjb3BlZCBtb2RlbFxuICogIEBhcGkgcHVibGljXG4gKi9cbk1vZGVsLnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHBhdGggPSB0aGlzLnBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLnNjb3BlKHBhdGgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbW9kZWwgc2NvcGUgdGhhdCBpcyBhIG51bWJlciBvZiBsZXZlbHMgYWJvdmUgdGhlIGN1cnJlbnQgc2NvcGVkXG4gKiBwYXRoLiBOdW1iZXIgb2YgbGV2ZWxzIGRlZmF1bHRzIHRvIDEsIHNvIHRoaXMgbWV0aG9kIGNhbGxlZCB3aXRob3V0XG4gKiBhcmd1bWVudHMgcmV0dXJucyB0aGUgbW9kZWwgc2NvcGUncyBwYXJlbnQgbW9kZWwgc2NvcGUuXG4gKlxuICogQG9wdGlvbmFsIEBwYXJhbSB7TnVtYmVyfSBsZXZlbHNcbiAqIEByZXR1cm4ge01vZGVsfSBhIHNjb3BlZCBtb2RlbFxuICovXG5Nb2RlbC5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24obGV2ZWxzKSB7XG4gIGlmIChsZXZlbHMgPT0gbnVsbCkgbGV2ZWxzID0gMTtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKCk7XG4gIHZhciBsZW4gPSBNYXRoLm1heCgwLCBzZWdtZW50cy5sZW5ndGggLSBsZXZlbHMpO1xuICB2YXIgcGF0aCA9IHNlZ21lbnRzLnNsaWNlKDAsIGxlbikuam9pbignLicpO1xuICByZXR1cm4gdGhpcy5zY29wZShwYXRoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBwcm9wZXJ0eSBzZWdtZW50IG9mIHRoZSBjdXJyZW50IG1vZGVsIHNjb3BlIHBhdGhcbiAqXG4gKiBAb3B0aW9uYWwgQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuTW9kZWwucHJvdG90eXBlLmxlYWYgPSBmdW5jdGlvbihwYXRoKSB7XG4gIGlmICghcGF0aCkgcGF0aCA9IHRoaXMucGF0aCgpO1xuICB2YXIgaSA9IHBhdGgubGFzdEluZGV4T2YoJy4nKTtcbiAgcmV0dXJuIHBhdGguc2xpY2UoaSArIDEpO1xufTtcbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuLy8gVGhpcyBtYXAgZGV0ZXJtaW5lcyB3aGljaCBldmVudHMgZ2V0IHJlLWVtaXR0ZWQgYXMgYW4gJ2FsbCcgZXZlbnRcbk1vZGVsLk1VVEFUT1JfRVZFTlRTID0ge1xuICBjaGFuZ2U6IHRydWVcbiwgaW5zZXJ0OiB0cnVlXG4sIHJlbW92ZTogdHJ1ZVxuLCBtb3ZlOiB0cnVlXG4sIHN0cmluZ0luc2VydDogdHJ1ZVxuLCBzdHJpbmdSZW1vdmU6IHRydWVcbiwgbG9hZDogdHJ1ZVxuLCB1bmxvYWQ6IHRydWVcbn07XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgLy8gU2V0IG1heCBsaXN0ZW5lcnMgdG8gdW5saW1pdGVkXG4gIG1vZGVsLnNldE1heExpc3RlbmVycygwKTtcblxuICAvLyBVc2VkIGluIGFzeW5jIG1ldGhvZHMgdG8gZW1pdCBhbiBlcnJvciBldmVudCBpZiBhIGNhbGxiYWNrIGlzIG5vdCBzdXBwbGllZC5cbiAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHRoZXJlIGlzIG5vIGhhbmRsZXIgZm9yIG1vZGVsLm9uKCdlcnJvcicpXG4gIG1vZGVsLl9kZWZhdWx0Q2FsbGJhY2sgPSBkZWZhdWx0Q2FsbGJhY2s7XG4gIGZ1bmN0aW9uIGRlZmF1bHRDYWxsYmFjayhlcnIpIHtcbiAgICBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIGVyciA9IG5ldyBFcnJvcihlcnIpO1xuICAgIGlmIChlcnIpIG1vZGVsLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfVxuXG4gIG1vZGVsLl9tdXRhdG9yRXZlbnRRdWV1ZSA9IG51bGw7XG4gIG1vZGVsLl9wYXNzID0gbmV3IFBhc3NlZCh7fSwge30pO1xufSk7XG5cbnV0aWwubWVyZ2VJbnRvKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5cbi8vIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24sIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIsIGFuZFxuLy8gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlIHJldHVybiBgdGhpc2AuIFRoZSBNb2RlbCBlcXVpdmFsZW50cyByZXR1cm5cbi8vIHRoZSBsaXN0ZW5lciBpbnN0ZWFkLCBzaW5jZSBpdCBpcyBtYWRlIGludGVybmFsbHkgZm9yIG1ldGhvZCBzdWJzY3JpcHRpb25zXG4vLyBhbmQgbWF5IG5lZWQgdG8gYmUgcGFzc2VkIHRvIHJlbW92ZUxpc3RlbmVyLlxuXG5Nb2RlbC5wcm90b3R5cGUuX2VtaXQgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5Nb2RlbC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKE1vZGVsLk1VVEFUT1JfRVZFTlRTW3R5cGVdKSB7XG4gICAgaWYgKHRoaXMuX3NpbGVudCkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIHNlZ21lbnRzID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBldmVudEFyZ3MgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKHRoaXMuX211dGF0b3JFdmVudFF1ZXVlKSB7XG4gICAgICB0aGlzLl9tdXRhdG9yRXZlbnRRdWV1ZS5wdXNoKFt0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fbXV0YXRvckV2ZW50UXVldWUgPSBbXTtcbiAgICB0aGlzLl9lbWl0KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MpO1xuICAgIHRoaXMuX2VtaXQoJ2FsbCcsIHNlZ21lbnRzLCBbdHlwZV0uY29uY2F0KGV2ZW50QXJncykpO1xuICAgIHdoaWxlICh0aGlzLl9tdXRhdG9yRXZlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIHZhciBxdWV1ZWQgPSB0aGlzLl9tdXRhdG9yRXZlbnRRdWV1ZS5zaGlmdCgpO1xuICAgICAgdHlwZSA9IHF1ZXVlZFswXTtcbiAgICAgIHNlZ21lbnRzID0gcXVldWVkWzFdO1xuICAgICAgZXZlbnRBcmdzID0gcXVldWVkWzJdO1xuICAgICAgdGhpcy5fZW1pdCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzKTtcbiAgICAgIHRoaXMuX2VtaXQoJ2FsbCcsIHNlZ21lbnRzLCBbdHlwZV0uY29uY2F0KGV2ZW50QXJncykpO1xuICAgIH1cbiAgICB0aGlzLl9tdXRhdG9yRXZlbnRRdWV1ZSA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fb24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuTW9kZWwucHJvdG90eXBlLmFkZExpc3RlbmVyID1cbk1vZGVsLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIHBhdHRlcm4sIGNiKSB7XG4gIHZhciBsaXN0ZW5lciA9IGV2ZW50TGlzdGVuZXIodGhpcywgcGF0dGVybiwgY2IpO1xuICB0aGlzLl9vbih0eXBlLCBsaXN0ZW5lcik7XG4gIHJldHVybiBsaXN0ZW5lcjtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgcGF0dGVybiwgY2IpIHtcbiAgdmFyIGxpc3RlbmVyID0gZXZlbnRMaXN0ZW5lcih0aGlzLCBwYXR0ZXJuLCBjYik7XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBsaXN0ZW5lci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChtYXRjaGVzKSB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuICB9XG4gIHRoaXMuX29uKHR5cGUsIGcpO1xuICByZXR1cm4gZztcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fcmVtb3ZlQWxsTGlzdGVuZXJzID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM7XG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSwgc3VicGF0dGVybikge1xuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gSWYgYSBwYXR0ZXJuIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGV2ZW50IHR5cGUsIHJlbW92ZSBhbGwgbW9kZWwgZXZlbnRcbiAgLy8gbGlzdGVuZXJzIHVuZGVyIHRoYXQgcGF0dGVybiBmb3IgYWxsIGV2ZW50c1xuICBpZiAoIXR5cGUpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXksIHN1YnBhdHRlcm4pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXRoKHN1YnBhdHRlcm4pO1xuICAvLyBJZiBubyBwYXR0ZXJuIGlzIHNwZWNpZmllZCwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgbGlrZSBub3JtYWxcbiAgaWYgKCFwYXR0ZXJuKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZUFsbExpc3RlbmVycyh0eXBlKTtcbiAgICB9XG4gIH1cblxuICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBmb3IgYW4gZXZlbnQgdW5kZXIgYSBwYXR0ZXJuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVycyh0eXBlKTtcbiAgdmFyIHNlZ21lbnRzID0gcGF0dGVybi5zcGxpdCgnLicpO1xuICAvLyBNYWtlIHN1cmUgdG8gaXRlcmF0ZSBpbiByZXZlcnNlLCBzaW5jZSB0aGUgYXJyYXkgbWlnaHQgYmVcbiAgLy8gbXV0YXRlZCBhcyBsaXN0ZW5lcnMgYXJlIHJlbW92ZWRcbiAgZm9yICh2YXIgaSA9IGxpc3RlbmVycy5sZW5ndGg7IGktLTspIHtcbiAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgaWYgKHBhdHRlcm5Db250YWluZWQocGF0dGVybiwgc2VnbWVudHMsIGxpc3RlbmVyKSkge1xuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBwYXR0ZXJuQ29udGFpbmVkKHBhdHRlcm4sIHNlZ21lbnRzLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdGVuZXJTZWdtZW50cyA9IGxpc3RlbmVyLnBhdHRlcm5TZWdtZW50cztcbiAgaWYgKCFsaXN0ZW5lclNlZ21lbnRzKSByZXR1cm4gZmFsc2U7XG4gIGlmIChwYXR0ZXJuID09PSBsaXN0ZW5lci5wYXR0ZXJuIHx8IHBhdHRlcm4gPT09ICcqKicpIHJldHVybiB0cnVlO1xuICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAobGVuID4gbGlzdGVuZXJTZWdtZW50cy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChzZWdtZW50c1tpXSAhPT0gbGlzdGVuZXJTZWdtZW50c1tpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5Nb2RlbC5wcm90b3R5cGUucGFzcyA9IGZ1bmN0aW9uKG9iamVjdCwgaW52ZXJ0KSB7XG4gIHZhciBtb2RlbCA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gIGlmIChpbnZlcnQpIHtcbiAgICBtb2RlbC5fcGFzcyA9IG5ldyBQYXNzZWQob2JqZWN0LCB0aGlzLl9wYXNzKTtcbiAgfSBlbHNlIHtcbiAgICBtb2RlbC5fcGFzcyA9IG5ldyBQYXNzZWQodGhpcy5fcGFzcywgb2JqZWN0KTtcbiAgfVxuICByZXR1cm4gbW9kZWw7XG59O1xuXG5mdW5jdGlvbiBQYXNzZWQocHJldmlvdXMsIHZhbHVlKSB7XG4gIGZvciAodmFyIGtleSBpbiBwcmV2aW91cykge1xuICAgIHRoaXNba2V5XSA9IHByZXZpb3VzW2tleV07XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgdGhpc1trZXldID0gdmFsdWVba2V5XTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSByZXR1cm5lZCBNb2RlbCB3aWxsIG9yIHdvbid0IHRyaWdnZXIgZXZlbnQgaGFuZGxlcnMgd2hlbiB0aGUgbW9kZWwgZW1pdHNcbiAqIGV2ZW50cywgZGVwZW5kaW5nIG9uIGB2YWx1ZWBcbiAqIEBwYXJhbSB7Qm9vbGVhbnxOdWxsfSB2YWx1ZSBkZWZhdWx0cyB0byB0cnVlXG4gKiBAcmV0dXJuIHtNb2RlbH1cbiAqL1xuTW9kZWwucHJvdG90eXBlLnNpbGVudCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHZhciBtb2RlbCA9IE9iamVjdC5jcmVhdGUodGhpcyk7XG4gIG1vZGVsLl9zaWxlbnQgPSAodmFsdWUgPT0gbnVsbCkgPyB0cnVlIDogdmFsdWU7XG4gIHJldHVybiBtb2RlbDtcbn07XG5cbmZ1bmN0aW9uIGV2ZW50TGlzdGVuZXIobW9kZWwsIHN1YnBhdHRlcm4sIGNiKSB7XG4gIGlmIChjYikge1xuICAgIC8vIEZvciBzaWduYXR1cmVzOlxuICAgIC8vIG1vZGVsLm9uKCdjaGFuZ2UnLCAnZXhhbXBsZS5zdWJwYXRoJywgY2FsbGJhY2spXG4gICAgLy8gbW9kZWwuYXQoJ2V4YW1wbGUnKS5vbignY2hhbmdlJywgJ3N1YnBhdGgnLCBjYWxsYmFjaylcbiAgICB2YXIgcGF0dGVybiA9IG1vZGVsLnBhdGgoc3VicGF0dGVybik7XG4gICAgcmV0dXJuIG1vZGVsRXZlbnRMaXN0ZW5lcihwYXR0ZXJuLCBjYik7XG4gIH1cbiAgdmFyIHBhdGggPSBtb2RlbC5wYXRoKCk7XG4gIGNiID0gYXJndW1lbnRzWzFdO1xuICAvLyBGb3Igc2lnbmF0dXJlOlxuICAvLyBtb2RlbC5hdCgnZXhhbXBsZScpLm9uKCdjaGFuZ2UnLCBjYWxsYmFjaylcbiAgaWYgKHBhdGgpIHJldHVybiBtb2RlbEV2ZW50TGlzdGVuZXIocGF0aCwgY2IpO1xuICAvLyBGb3Igc2lnbmF0dXJlOlxuICAvLyBtb2RlbC5vbignbm9ybWFsRXZlbnQnLCBjYWxsYmFjaylcbiAgcmV0dXJuIGNiO1xufVxuXG5mdW5jdGlvbiBtb2RlbEV2ZW50TGlzdGVuZXIocGF0dGVybiwgY2IpIHtcbiAgdmFyIHBhdHRlcm5TZWdtZW50cyA9IHBhdHRlcm4uc3BsaXQoJy4nKTtcbiAgdmFyIHRlc3RGbiA9IHRlc3RQYXR0ZXJuRm4ocGF0dGVybiwgcGF0dGVyblNlZ21lbnRzKTtcblxuICBmdW5jdGlvbiBtb2RlbExpc3RlbmVyKHNlZ21lbnRzLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgY2FwdHVyZXMgPSB0ZXN0Rm4oc2VnbWVudHMpO1xuICAgIGlmICghY2FwdHVyZXMpIHJldHVybjtcblxuICAgIHZhciBhcmdzID0gKGNhcHR1cmVzLmxlbmd0aCkgPyBjYXB0dXJlcy5jb25jYXQoZXZlbnRBcmdzKSA6IGV2ZW50QXJncztcbiAgICBjYi5hcHBseShudWxsLCBhcmdzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFVzZWQgaW4gTW9kZWwjcmVtb3ZlQWxsTGlzdGVuZXJzXG4gIG1vZGVsTGlzdGVuZXIucGF0dGVybiA9IHBhdHRlcm47XG4gIG1vZGVsTGlzdGVuZXIucGF0dGVyblNlZ21lbnRzID0gcGF0dGVyblNlZ21lbnRzO1xuXG4gIHJldHVybiBtb2RlbExpc3RlbmVyO1xufVxuXG5mdW5jdGlvbiB0ZXN0UGF0dGVybkZuKHBhdHRlcm4sIHBhdHRlcm5TZWdtZW50cykge1xuICBpZiAocGF0dGVybiA9PT0gJyoqJykge1xuICAgIHJldHVybiBmdW5jdGlvbiB0ZXN0UGF0dGVybihzZWdtZW50cykge1xuICAgICAgcmV0dXJuIFtzZWdtZW50cy5qb2luKCcuJyldO1xuICAgIH07XG4gIH1cblxuICB2YXIgZW5kaW5nUmVzdCA9IHN0cmlwUmVzdFdpbGRjYXJkKHBhdHRlcm5TZWdtZW50cyk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHRlc3RQYXR0ZXJuKHNlZ21lbnRzKSB7XG4gICAgLy8gQW55IHBhdHRlcm4gd2l0aCBtb3JlIHNlZ21lbnRzIGRvZXMgbm90IG1hdGNoXG4gICAgdmFyIHBhdHRlcm5MZW4gPSBwYXR0ZXJuU2VnbWVudHMubGVuZ3RoO1xuICAgIGlmIChwYXR0ZXJuTGVuID4gc2VnbWVudHMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAvLyBBIHBhdHRlcm4gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2Ygc2VnbWVudHMgbWF0Y2hlcyBpZiBlYWNoXG4gICAgLy8gb2YgdGhlIHNlZ21lbnRzIGFyZSB3aWxkY2FyZHMgb3IgZXF1YWwuIEEgc2hvcnRlciBwYXR0ZXJuIG1hdGNoZXNcbiAgICAvLyBpZiBpdCBlbmRzIGluIGEgcmVzdCB3aWxkY2FyZCBhbmQgZWFjaCBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIHNlZ21lbnRzIGFyZSB3aWxkY2FyZHMgb3IgZXF1YWwuXG4gICAgaWYgKHBhdHRlcm5MZW4gPT09IHNlZ21lbnRzLmxlbmd0aCB8fCBlbmRpbmdSZXN0KSB7XG4gICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuU2VnbWVudCA9IHBhdHRlcm5TZWdtZW50c1tpXTtcbiAgICAgICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgaWYgKHBhdHRlcm5TZWdtZW50ID09PSAnKicgfHwgcGF0dGVyblNlZ21lbnQgPT09ICcqKicpIHtcbiAgICAgICAgICBjYXB0dXJlcy5wdXNoKHNlZ21lbnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXR0ZXJuU2VnbWVudCAhPT0gc2VnbWVudCkgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVuZGluZ1Jlc3QpIHtcbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IHNlZ21lbnRzLnNsaWNlKGkpLmpvaW4oJy4nKTtcbiAgICAgICAgY2FwdHVyZXMucHVzaChyZW1haW5kZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhcHR1cmVzO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gc3RyaXBSZXN0V2lsZGNhcmQoc2VnbWVudHMpIHtcbiAgLy8gWydleGFtcGxlJywgJ3N1YnBhdGgqKiddIC0+IFsnZXhhbXBsZScsICdzdWJwYXRoJ11cbiAgdmFyIGxhc3RJbmRleCA9IHNlZ21lbnRzLmxlbmd0aCAtIDE7XG4gIHZhciBtYXRjaCA9IC9eKFteXFwqXSspXFwqXFwqJC8uZXhlYyhzZWdtZW50c1tsYXN0SW5kZXhdKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIGZhbHNlO1xuICBzZWdtZW50c1tsYXN0SW5kZXhdID0gbWF0Y2hbMV07XG4gIHJldHVybiB0cnVlO1xufVxuIiwidmFyIE1vZGVsID0gcmVxdWlyZSgnLi9pbmRleCcpO1xudmFyIExvY2FsRG9jID0gcmVxdWlyZSgnLi9Mb2NhbERvYycpO1xudmFyIFJlbW90ZURvYyA9IHJlcXVpcmUoJy4vUmVtb3RlRG9jJyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwuY29sbGVjdGlvbnMgPSBuZXcgQ29sbGVjdGlvbk1hcDtcbn0pO1xuXG5Nb2RlbC5wcm90b3R5cGUuZ2V0Q29sbGVjdGlvbiA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lKSB7XG4gIHJldHVybiB0aGlzLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25OYW1lXTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZ2V0RG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uTmFtZV07XG4gIHJldHVybiBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24uZG9jc1tpZF07XG59O1xuTW9kZWwucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fZ2V0KHNlZ21lbnRzKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgY29sbGVjdGlvbk5hbWUgPSBzZWdtZW50c1swXTtcbiAgaWYgKCFjb2xsZWN0aW9uTmFtZSkge1xuICAgIHJldHVybiBnZXRFYWNoKHRoaXMuY29sbGVjdGlvbnMpO1xuICB9XG4gIHZhciBpZCA9IHNlZ21lbnRzWzFdO1xuICBpZiAoIWlkKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmdldENvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUpO1xuICAgIHJldHVybiBjb2xsZWN0aW9uICYmIGdldEVhY2goY29sbGVjdGlvbi5kb2NzKTtcbiAgfVxuICB2YXIgZG9jID0gdGhpcy5nZXREb2MoY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgcmV0dXJuIGRvYyAmJiBkb2MuZ2V0KHNlZ21lbnRzLnNsaWNlKDIpKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuZ2V0T3JDcmVhdGVDb2xsZWN0aW9uID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuY29sbGVjdGlvbnNbbmFtZV07XG4gIGlmIChjb2xsZWN0aW9uKSByZXR1cm4gY29sbGVjdGlvbjtcbiAgLy8gV2hldGhlciB0aGUgY29sbGVjdGlvbiBpcyBsb2NhbCBvciByZW1vdGUgaXMgZGV0ZXJtaW5lZCBieSBpdHMgbmFtZS5cbiAgLy8gQ29sbGVjdGlvbnMgc3RhcnRpbmcgd2l0aCBhbiB1bmRlcnNjb3JlICgnXycpIGFyZSBmb3IgdXNlci1kZWZpbmVkIGxvY2FsXG4gIC8vIGNvbGxlY3Rpb25zLCB0aG9zZSBzdGFydGluZyB3aXRoIGEgZG9sbGFyIHNpZ24gKCckJycpIGFyZSBmb3JcbiAgLy8gZnJhbWV3b3JrLWRlZmluZWQgbG9jYWwgY29sbGVjdGlvbnMsIGFuZCBhbGwgb3RoZXJzIGFyZSByZW1vdGUuXG4gIHZhciBmaXJzdENoYXJjdGVyID0gbmFtZS5jaGFyQXQoMCk7XG4gIHZhciBpc0xvY2FsID0gKGZpcnN0Q2hhcmN0ZXIgPT09ICdfJyB8fCBmaXJzdENoYXJjdGVyID09PSAnJCcpO1xuICB2YXIgRG9jID0gKGlzTG9jYWwpID8gTG9jYWxEb2MgOiBSZW1vdGVEb2M7XG4gIGNvbGxlY3Rpb24gPSBuZXcgQ29sbGVjdGlvbih0aGlzLCBuYW1lLCBEb2MpO1xuICB0aGlzLmNvbGxlY3Rpb25zW25hbWVdID0gY29sbGVjdGlvbjtcbiAgcmV0dXJuIGNvbGxlY3Rpb247XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gZXhpc3RpbmcgZG9jdW1lbnQgd2l0aCBpZCBpbiBhIGNvbGxlY3Rpb24uIElmIHRoZSBkb2N1bWVudCBkb2VzXG4gKiBub3QgZXhpc3QsIHRoZW4gY3JlYXRlcyB0aGUgZG9jdW1lbnQgd2l0aCBpZCBpbiBhIGNvbGxlY3Rpb24gYW5kIHJldHVybnMgdGhlXG4gKiBuZXcgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBkYXRhIHRvIGNyZWF0ZSBpZiBkb2Mgd2l0aCBpZCBkb2VzIG5vdCBleGlzdCBpbiBjb2xsZWN0aW9uXG4gKi9cbk1vZGVsLnByb3RvdHlwZS5nZXRPckNyZWF0ZURvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgZGF0YSkge1xuICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuZ2V0T3JDcmVhdGVDb2xsZWN0aW9uKGNvbGxlY3Rpb25OYW1lKTtcbiAgcmV0dXJuIGNvbGxlY3Rpb24uZG9jc1tpZF0gfHwgY29sbGVjdGlvbi5hZGQoaWQsIGRhdGEpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqL1xuTW9kZWwucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihjb2xsZWN0aW9uTmFtZSkge1xuICAvLyBUT0RPOiBub24tY29sbGVjdGlvbnNcbiAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmdldENvbGxlY3Rpb24oY29sbGVjdGlvbk5hbWUpO1xuICBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24uZGVzdHJveSgpO1xuICB0aGlzLnJlbW92ZUFsbFJlZnMoY29sbGVjdGlvbk5hbWUpO1xuICB0aGlzLnN0b3BBbGwoY29sbGVjdGlvbk5hbWUpO1xuICB0aGlzLnJlbW92ZUFsbEZpbHRlcnMoY29sbGVjdGlvbk5hbWUpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhudWxsLCBjb2xsZWN0aW9uTmFtZSk7XG59O1xuXG5mdW5jdGlvbiBDb2xsZWN0aW9uTWFwKCkge31cbmZ1bmN0aW9uIERvY01hcCgpIHt9XG5mdW5jdGlvbiBDb2xsZWN0aW9uKG1vZGVsLCBuYW1lLCBEb2MpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLkRvYyA9IERvYztcbiAgdGhpcy5kb2NzID0gbmV3IERvY01hcCgpO1xufVxuXG4vKipcbiAqIEFkZHMgYSBkb2N1bWVudCB3aXRoIGBpZGAgYW5kIGBkYXRhYCB0byBgdGhpc2AgQ29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBpZFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge0xvY2FsRG9jfFJlbW90ZURvY30gZG9jXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGlkLCBkYXRhKSB7XG4gIHZhciBkb2MgPSBuZXcgdGhpcy5Eb2ModGhpcy5uYW1lLCBpZCwgZGF0YSwgdGhpcy5tb2RlbCk7XG4gIHRoaXMuZG9jc1tpZF0gPSBkb2M7XG4gIHJldHVybiBkb2M7XG59O1xuQ29sbGVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBkZWxldGUgdGhpcy5tb2RlbC5jb2xsZWN0aW9uc1t0aGlzLm5hbWVdO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBkb2N1bWVudCB3aXRoIGBpZGAgZnJvbSBgdGhpc2AgQ29sbGVjdGlvbi4gSWYgdGhlcmUgYXJlIG5vIG1vcmVcbiAqIGRvY3VtZW50cyBpbiB0aGUgQ29sbGVjdGlvbiBhZnRlciB0aGUgZ2l2ZW4gZG9jdW1lbnQgaXMgcmVtb3ZlZCwgdGhlbiB0aGlzXG4gKiBhbHNvIGRlc3Ryb3lzIHRoZSBDb2xsZWN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIGRlbGV0ZSB0aGlzLmRvY3NbaWRdO1xuICBpZiAobm9LZXlzKHRoaXMuZG9jcykpIHRoaXMuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IG1hcHMgZG9jIGlkcyB0byBmdWxseSByZXNvbHZlZCBkb2N1bWVudHMuXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ2V0RWFjaCh0aGlzLmRvY3MpO1xufTtcblxuZnVuY3Rpb24gZ2V0RWFjaChvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHJldHVybjtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XS5nZXQoKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBub0tleXMob2JqZWN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuTW9kZWwucHJvdG90eXBlLl9tdXRhdGUgPSBmdW5jdGlvbihzZWdtZW50cywgZm4sIGNiKSB7XG4gIGlmICghY2IpIGNiID0gdGhpcy5fZGVmYXVsdENhbGxiYWNrO1xuICB2YXIgY29sbGVjdGlvbk5hbWUgPSBzZWdtZW50c1swXTtcbiAgdmFyIGlkID0gc2VnbWVudHNbMV07XG4gIGlmICghY29sbGVjdGlvbk5hbWUgfHwgIWlkKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBmbi5uYW1lICsgJyBtdXN0IGJlIHBlcmZvcm1lZCB1bmRlciBhIGNvbGxlY3Rpb24gJyArXG4gICAgICAnYW5kIGRvY3VtZW50IGlkLiBJbnZhbGlkIHBhdGg6ICcgKyBzZWdtZW50cy5qb2luKCcuJyk7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gIH1cbiAgdmFyIGRvYyA9IHRoaXMuZ2V0T3JDcmVhdGVEb2MoY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgdmFyIGRvY1NlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UoMik7XG4gIHJldHVybiBmbihkb2MsIGRvY1NlZ21lbnRzLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCB2YWx1ZSwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9zZXQoc2VnbWVudHMsIHZhbHVlLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzZXQoZG9jLCBkb2NTZWdtZW50cywgZm5DYikge1xuICAgIHZhciBwcmV2aW91cyA9IGRvYy5zZXQoZG9jU2VnbWVudHMsIHZhbHVlLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgc2V0LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc2V0RWFjaCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgb2JqZWN0LCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBvYmplY3QgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgb2JqZWN0ID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgb2JqZWN0ID0gYXJndW1lbnRzWzFdO1xuICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX3NldEVhY2goc2VnbWVudHMsIG9iamVjdCwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fc2V0RWFjaCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBvYmplY3QsIGNiKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoY2IgfHwgdGhpcy5fZGVmYXVsdENhbGxiYWNrKTtcbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgIHRoaXMuX3NldChzZWdtZW50cy5jb25jYXQoa2V5KSwgdmFsdWUsIGdyb3VwKCkpO1xuICB9XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCB2YWx1ZSwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9hZGQoc2VnbWVudHMsIHZhbHVlLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9hZGQgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIGNiKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnYWRkIHJlcXVpcmVzIGFuIG9iamVjdCB2YWx1ZS4gSW52YWxpZCB2YWx1ZTogJyArIHZhbHVlO1xuICAgIGNiIHx8IChjYiA9IHRoaXMuX2RlZmF1bHRDYWxsYmFjayk7XG4gICAgcmV0dXJuIGNiKG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gIH1cbiAgdmFyIGlkID0gdmFsdWUuaWQgfHwgdGhpcy5pZCgpO1xuICB2YWx1ZS5pZCA9IGlkO1xuICB0aGlzLl9zZXQoc2VnbWVudHMuY29uY2F0KGlkKSwgdmFsdWUsIGNiKTtcbiAgcmV0dXJuIGlkO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNldE51bGwgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIHZhbHVlLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX3NldE51bGwoc2VnbWVudHMsIHZhbHVlLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zZXROdWxsID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc2V0TnVsbChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHByZXZpb3VzID0gZG9jLmdldChkb2NTZWdtZW50cyk7XG4gICAgaWYgKHByZXZpb3VzICE9IG51bGwpIHtcbiAgICAgIGZuQ2IoKTtcbiAgICAgIHJldHVybiBwcmV2aW91cztcbiAgICB9XG4gICAgZG9jLnNldChkb2NTZWdtZW50cywgdmFsdWUsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzZXROdWxsLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fZGVsKHNlZ21lbnRzLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9kZWwgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cyk7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIGRlbChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHByZXZpb3VzID0gZG9jLmRlbChkb2NTZWdtZW50cywgZm5DYik7XG4gICAgLy8gV2hlbiBkZWxldGluZyBhbiBlbnRpcmUgZG9jdW1lbnQsIGFsc28gcmVtb3ZlIHRoZSByZWZlcmVuY2UgdG8gdGhlXG4gICAgLy8gZG9jdW1lbnQgb2JqZWN0IGZyb20gaXRzIGNvbGxlY3Rpb25cbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgY29sbGVjdGlvbk5hbWUgPSBzZWdtZW50c1swXTtcbiAgICAgIHZhciBpZCA9IHNlZ21lbnRzWzFdO1xuICAgICAgbW9kZWwuY29sbGVjdGlvbnNbY29sbGVjdGlvbk5hbWVdLnJlbW92ZShpZCk7XG4gICAgfVxuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdm9pZCAwLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgZGVsLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBieU51bWJlciwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGJ5TnVtYmVyID0gYXJndW1lbnRzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGJ5TnVtYmVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGJ5TnVtYmVyID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGJ5TnVtYmVyID0gYXJndW1lbnRzWzFdO1xuICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX2luY3JlbWVudChzZWdtZW50cywgYnlOdW1iZXIsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX2luY3JlbWVudCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBieU51bWJlciwgY2IpIHtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cyk7XG4gIGlmIChieU51bWJlciA9PSBudWxsKSBieU51bWJlciA9IDE7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIGluY3JlbWVudChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHZhbHVlID0gZG9jLmluY3JlbWVudChkb2NTZWdtZW50cywgYnlOdW1iZXIsIGZuQ2IpO1xuICAgIHZhciBwcmV2aW91cyA9IHZhbHVlIC0gYnlOdW1iZXI7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIGluY3JlbWVudCwgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIHZhbHVlLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX3B1c2goc2VnbWVudHMsIHZhbHVlLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9wdXNoID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICB2YXIgZm9yQXJyYXlNdXRhdG9yID0gdHJ1ZTtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gcHVzaChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGxlbmd0aCA9IGRvYy5wdXNoKGRvY1NlZ21lbnRzLCB2YWx1ZSwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgnaW5zZXJ0Jywgc2VnbWVudHMsIFtsZW5ndGggLSAxLCBbdmFsdWVdLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgcHVzaCwgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIHZhbHVlLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX3Vuc2hpZnQoc2VnbWVudHMsIHZhbHVlLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl91bnNoaWZ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICB2YXIgZm9yQXJyYXlNdXRhdG9yID0gdHJ1ZTtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gdW5zaGlmdChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGxlbmd0aCA9IGRvYy51bnNoaWZ0KGRvY1NlZ21lbnRzLCB2YWx1ZSwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgnaW5zZXJ0Jywgc2VnbWVudHMsIFswLCBbdmFsdWVdLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgdW5zaGlmdCwgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3VicGF0aCwgaW5kZXgsIHZhbHVlcywgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMgZm9yIGluc2VydCcpKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWVzID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhbHVlcyA9IGFyZ3VtZW50c1syXTtcbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhbHVlcyA9IGFyZ3VtZW50c1syXTtcbiAgICBjYiA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9pbnNlcnQoc2VnbWVudHMsIGluZGV4LCB2YWx1ZXMsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX2luc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWVzLCBjYikge1xuICB2YXIgZm9yQXJyYXlNdXRhdG9yID0gdHJ1ZTtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gaW5zZXJ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgaW5zZXJ0ZWQgPSAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuICAgIHZhciBsZW5ndGggPSBkb2MuaW5zZXJ0KGRvY1NlZ21lbnRzLCBpbmRleCwgaW5zZXJ0ZWQsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ2luc2VydCcsIHNlZ21lbnRzLCBbaW5kZXgsIGluc2VydGVkLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBsZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgaW5zZXJ0LCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fcG9wKHNlZ21lbnRzLCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9wb3AgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgdmFyIGZvckFycmF5TXV0YXRvciA9IHRydWU7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMsIGZvckFycmF5TXV0YXRvcik7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHBvcChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGFyciA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBhcnIgJiYgYXJyLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgZm5DYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBkb2MucG9wKGRvY1NlZ21lbnRzLCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdyZW1vdmUnLCBzZWdtZW50cywgW2xlbmd0aCAtIDEsIFt2YWx1ZV0sIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHBvcCwgY2IpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgY2IgPSBhcmd1bWVudHNbMV07XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc2hpZnQoc2VnbWVudHMsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3NoaWZ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIHZhciBmb3JBcnJheU11dGF0b3IgPSB0cnVlO1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzLCBmb3JBcnJheU11dGF0b3IpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzaGlmdChkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGFyciA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBsZW5ndGggPSBhcnIgJiYgYXJyLmxlbmd0aDtcbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgZm5DYigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSBkb2Muc2hpZnQoZG9jU2VnbWVudHMsIGZuQ2IpO1xuICAgIG1vZGVsLmVtaXQoJ3JlbW92ZScsIHNlZ21lbnRzLCBbMCwgW3ZhbHVlXSwgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX211dGF0ZShzZWdtZW50cywgc2hpZnQsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGluZGV4LCBob3dNYW55LCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBhcmd1bWVudHNbMl07XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICAgIGhvd01hbnkgPSBhcmd1bWVudHNbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgICAgaG93TWFueSA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICB9XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgaWYgKGluZGV4ID09IG51bGwpIGluZGV4ID0gK3NlZ21lbnRzLnBvcCgpO1xuICByZXR1cm4gdGhpcy5fcmVtb3ZlKHNlZ21lbnRzLCBpbmRleCwgaG93TWFueSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYikge1xuICB2YXIgZm9yQXJyYXlNdXRhdG9yID0gdHJ1ZTtcbiAgc2VnbWVudHMgPSB0aGlzLl9kZXJlZmVyZW5jZShzZWdtZW50cywgZm9yQXJyYXlNdXRhdG9yKTtcbiAgaWYgKGhvd01hbnkgPT0gbnVsbCkgaG93TWFueSA9IDE7XG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGZ1bmN0aW9uIHJlbW92ZShkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIHJlbW92ZWQgPSBkb2MucmVtb3ZlKGRvY1NlZ21lbnRzLCBpbmRleCwgaG93TWFueSwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgncmVtb3ZlJywgc2VnbWVudHMsIFtpbmRleCwgcmVtb3ZlZCwgbW9kZWwuX3Bhc3NdKTtcbiAgICByZXR1cm4gcmVtb3ZlZDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCByZW1vdmUsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBmcm9tLCB0bywgaG93TWFueSwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMgZm9yIG1vdmUnKSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgdG8gPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBjYiA9IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgZnJvbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRvID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzNdO1xuICAgICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHRvID0gYXJndW1lbnRzWzFdO1xuICAgICAgICBob3dNYW55ID0gYXJndW1lbnRzWzJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VicGF0aCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgZnJvbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzFdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGZyb20gPSBhcmd1bWVudHNbMV07XG4gICAgdG8gPSBhcmd1bWVudHNbMl07XG4gICAgaG93TWFueSA9IGFyZ3VtZW50c1szXTtcbiAgICBjYiA9IGFyZ3VtZW50c1s0XTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9tb3ZlKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpIHtcbiAgdmFyIGZvckFycmF5TXV0YXRvciA9IHRydWU7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMsIGZvckFycmF5TXV0YXRvcik7XG4gIGlmIChob3dNYW55ID09IG51bGwpIGhvd01hbnkgPSAxO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBtb3ZlKGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICAvLyBDYXN0IHRvIG51bWJlcnNcbiAgICBmcm9tID0gK2Zyb207XG4gICAgdG8gPSArdG87XG4gICAgLy8gQ29udmVydCBuZWdhdGl2ZSBpbmRpY2VzIGludG8gcG9zaXRpdmVcbiAgICBpZiAoZnJvbSA8IDAgfHwgdG8gPCAwKSB7XG4gICAgICB2YXIgbGVuID0gZG9jLmdldChkb2NTZWdtZW50cykubGVuZ3RoO1xuICAgICAgaWYgKGZyb20gPCAwKSBmcm9tICs9IGxlbjtcbiAgICAgIGlmICh0byA8IDApIHRvICs9IGxlbjtcbiAgICB9XG4gICAgdmFyIG1vdmVkID0gZG9jLm1vdmUoZG9jU2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55LCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdtb3ZlJywgc2VnbWVudHMsIFtmcm9tLCB0bywgbW92ZWQubGVuZ3RoLCBtb2RlbC5fcGFzc10pO1xuICAgIHJldHVybiBtb3ZlZDtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBtb3ZlLCBjYik7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RyaW5nSW5zZXJ0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCBpbmRleCwgdGV4dCwgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMgZm9yIHN0cmluZ0luc2VydCcpKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICB0ZXh0ID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIGluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHRleHQgPSBhcmd1bWVudHNbMl07XG4gICAgY2IgPSBhcmd1bWVudHNbM107XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc3RyaW5nSW5zZXJ0KHNlZ21lbnRzLCBpbmRleCwgdGV4dCwgY2IpO1xufTtcbk1vZGVsLnByb3RvdHlwZS5fc3RyaW5nSW5zZXJ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCB0ZXh0LCBjYikge1xuICBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc3RyaW5nSW5zZXJ0KGRvYywgZG9jU2VnbWVudHMsIGZuQ2IpIHtcbiAgICB2YXIgcHJldmlvdXMgPSBkb2Muc3RyaW5nSW5zZXJ0KGRvY1NlZ21lbnRzLCBpbmRleCwgdGV4dCwgZm5DYik7XG4gICAgbW9kZWwuZW1pdCgnc3RyaW5nSW5zZXJ0Jywgc2VnbWVudHMsIFtpbmRleCwgdGV4dCwgbW9kZWwuX3Bhc3NdKTtcbiAgICB2YXIgdmFsdWUgPSBkb2MuZ2V0KGRvY1NlZ21lbnRzKTtcbiAgICB2YXIgcGFzcyA9IG1vZGVsLnBhc3MoeyRvcmlnaW5hbDogJ3N0cmluZ0luc2VydCd9KS5fcGFzcztcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgcGFzc10pO1xuICAgIHJldHVybjtcbiAgfVxuICByZXR1cm4gdGhpcy5fbXV0YXRlKHNlZ21lbnRzLCBzdHJpbmdJbnNlcnQsIGNiKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN1YnBhdGgsIGluZGV4LCBob3dNYW55LCBjYjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb3Igc3RyaW5nUmVtb3ZlJykpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICBob3dNYW55ID0gYXJndW1lbnRzWzFdO1xuICAgICAgY2IgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgICBpbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGhvd01hbnkgPSBhcmd1bWVudHNbMl07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgaW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgaG93TWFueSA9IGFyZ3VtZW50c1syXTtcbiAgICBjYiA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHJldHVybiB0aGlzLl9zdHJpbmdSZW1vdmUoc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYik7XG59O1xuTW9kZWwucHJvdG90eXBlLl9zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgbW9kZWwgPSB0aGlzO1xuICBmdW5jdGlvbiBzdHJpbmdSZW1vdmUoZG9jLCBkb2NTZWdtZW50cywgZm5DYikge1xuICAgIHZhciBwcmV2aW91cyA9IGRvYy5zdHJpbmdSZW1vdmUoZG9jU2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBmbkNiKTtcbiAgICBtb2RlbC5lbWl0KCdzdHJpbmdSZW1vdmUnLCBzZWdtZW50cywgW2luZGV4LCBob3dNYW55LCBtb2RlbC5fcGFzc10pO1xuICAgIHZhciB2YWx1ZSA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIHZhciBwYXNzID0gbW9kZWwucGFzcyh7JG9yaWdpbmFsOiAnc3RyaW5nUmVtb3ZlJ30pLl9wYXNzO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBwYXNzXSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHN0cmluZ1JlbW92ZSwgY2IpO1xufTtcbiIsIihmdW5jdGlvbihwcm9jZXNzKXt2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcbnZhciBRdWVyeSA9IHJlcXVpcmUoJy4vUXVlcnknKTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICBtb2RlbC5mZXRjaE9ubHkgPSBvcHRpb25zLmZldGNoT25seTtcbiAgbW9kZWwudW5sb2FkRGVsYXkgPSBvcHRpb25zLnVubG9hZERlbGF5IHx8IDEwMDA7XG5cbiAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGNvdW50IG9mIGZldGNoZXMgKHRoYXQgaGF2ZW4ndCBiZWVuIHVuZG9uZSBieSBhblxuICAvLyB1bmZldGNoKSBwZXIgZG9jLiBNYXBzIGRvYyBpZCB0byB0aGUgZmV0Y2ggY291bnQuXG4gIG1vZGVsLl9mZXRjaGVkRG9jcyA9IG5ldyBGZXRjaGVkRG9jcztcblxuICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgY291bnQgb2Ygc3Vic2NyaWJlcyAodGhhdCBoYXZlbid0IGJlZW4gdW5kb25lIGJ5IGFuXG4gIC8vIHVuc3Vic2NyaWJlKSBwZXIgZG9jLiBNYXBzIGRvYyBpZCB0byB0aGUgc3Vic2NyaWJlIGNvdW50LlxuICBtb2RlbC5fc3Vic2NyaWJlZERvY3MgPSBuZXcgU3Vic2NyaWJlZERvY3M7XG5cbiAgLy8gTWFwcyBkb2MgcGF0aCB0byBkb2MgdmVyc2lvblxuICBtb2RlbC5fbG9hZFZlcnNpb25zID0gbmV3IExvYWRWZXJzaW9ucztcbn0pO1xuXG5mdW5jdGlvbiBGZXRjaGVkRG9jcygpIHt9XG5mdW5jdGlvbiBTdWJzY3JpYmVkRG9jcygpIHt9XG5mdW5jdGlvbiBMb2FkVmVyc2lvbnMoKSB7fVxuXG5Nb2RlbC5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZm9yU3Vic2NyaWJhYmxlKGFyZ3VtZW50cywgJ2ZldGNoJyk7XG4gIHJldHVybiB0aGlzO1xufTtcbk1vZGVsLnByb3RvdHlwZS51bmZldGNoID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2ZvclN1YnNjcmliYWJsZShhcmd1bWVudHMsICd1bmZldGNoJyk7XG4gIHJldHVybiB0aGlzO1xufTtcbk1vZGVsLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZm9yU3Vic2NyaWJhYmxlKGFyZ3VtZW50cywgJ3N1YnNjcmliZScpO1xuICByZXR1cm4gdGhpcztcbn07XG5Nb2RlbC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZm9yU3Vic2NyaWJhYmxlKGFyZ3VtZW50cywgJ3Vuc3Vic2NyaWJlJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcmd1bWVudHN9IGFyZ3VtZW50c09iamVjdCBjYW4gdGFrZSAxIG9mIHR3byBmb3Jtc1xuICogICAxLiBbW3N1YnNjcmliYWJsZU9iamVjdHMuLi5dLCBjYl1cbiAqICAgMi4gW3N1YnNjcmliYWJsZU9iamVjdHMuLi4sIGNiXVxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBjYW4gYmUgJ2ZldGNoJywgJ3VuZmV0Y2gnLCAnc3Vic2NyaWJlJywgJ3Vuc3Vic2NyaWJlJ1xuICovXG5Nb2RlbC5wcm90b3R5cGUuX2ZvclN1YnNjcmliYWJsZSA9IGZ1bmN0aW9uKGFyZ3VtZW50c09iamVjdCwgbWV0aG9kKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50c09iamVjdFswXSkpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50c09iamVjdFswXTtcbiAgICB2YXIgY2IgPSBhcmd1bWVudHNPYmplY3RbMV0gfHwgdGhpcy5fZGVmYXVsdENhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzT2JqZWN0KTtcbiAgICB2YXIgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICB2YXIgY2IgPSAodHlwZW9mIGxhc3QgPT09ICdmdW5jdGlvbicpID8gYXJncy5wb3AoKSA6IHRoaXMuX2RlZmF1bHRDYWxsYmFjaztcbiAgfVxuICAvLyBJZiBubyBxdWVyaWVzIG9yIHBhdGhzIGFyZSBwYXNzZWQgaW4sIHRyeSB0byB1c2UgdGhpcyBtb2RlbCdzIHNjb3BlXG4gIGlmICghYXJncy5sZW5ndGgpIGFyZ3MucHVzaChudWxsKTtcbiAgdmFyIGdyb3VwID0gdXRpbC5hc3luY0dyb3VwKGNiKTtcbiAgdmFyIGRvY01ldGhvZCA9IG1ldGhvZCArICdEb2MnO1xuXG4gIHZhciBmaW5pc2hlZCA9IGdyb3VwKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gYXJnc1tpXTtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFF1ZXJ5KSB7XG4gICAgICBpdGVtW21ldGhvZF0oZ3JvdXAoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzZWdtZW50cyA9IHRoaXMuX2RlcmVmZXJlbmNlKHRoaXMuX3NwbGl0UGF0aChpdGVtKSk7XG4gICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIC8vIERvIHRoZSBhcHByb3ByaWF0ZSBtZXRob2QgZm9yIGEgc2luZ2xlIGRvY3VtZW50LlxuICAgICAgICB0aGlzW2RvY01ldGhvZF0oc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdLCBncm91cCgpKTtcbiAgICAgIH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIE1ha2UgYSBxdWVyeSB0byBhbiBlbnRpcmUgY29sbGVjdGlvbi5cbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeShzZWdtZW50c1swXSwge30pO1xuICAgICAgICBxdWVyeVttZXRob2RdKGdyb3VwKCkpO1xuICAgICAgfSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnTm8gcGF0aCBzcGVjaWZpZWQgZm9yICcgKyBtZXRob2Q7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IobWVzc2FnZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnQ2Fubm90ICcgKyBtZXRob2QgKyAnIHRvIGEgcGF0aCB3aXRoaW4gYSBkb2N1bWVudDogJyArXG4gICAgICAgICAgc2VnbWVudHMuam9pbignLicpO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluaXNoZWQoKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcGFyYW0ge1N0cmluZ30gaWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVycilcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxyZWFkeUxvYWRlZFxuICovXG5Nb2RlbC5wcm90b3R5cGUuZmV0Y2hEb2MgPSBmdW5jdGlvbihjb2xsZWN0aW9uTmFtZSwgaWQsIGNiLCBhbHJlYWR5TG9hZGVkKSB7XG4gIGlmICghY2IpIGNiID0gdGhpcy5fZGVmYXVsdENhbGxiYWNrO1xuXG4gIC8vIE1haW50YWluIGEgY291bnQgb2YgZmV0Y2hlcyBzbyB0aGF0IHdlIGNhbiB1bmxvYWQgdGhlIGRvY3VtZW50IHdoZW5cbiAgLy8gdGhlcmUgYXJlIG5vIHJlbWFpbmluZyBmZXRjaGVzIG9yIHN1YnNjcmliZXMgZm9yIHRoYXQgZG9jdW1lbnRcbiAgdmFyIHBhdGggPSBjb2xsZWN0aW9uTmFtZSArICcuJyArIGlkO1xuICB0aGlzLmVtaXQoJ2ZldGNoRG9jJywgcGF0aCwgdGhpcy5fY29udGV4dCwgdGhpcy5fcGFzcyk7XG4gIHRoaXMuX2ZldGNoZWREb2NzW3BhdGhdID0gKHRoaXMuX2ZldGNoZWREb2NzW3BhdGhdIHx8IDApICsgMTtcblxuICB2YXIgbW9kZWwgPSB0aGlzO1xuICB2YXIgZG9jID0gdGhpcy5nZXRPckNyZWF0ZURvYyhjb2xsZWN0aW9uTmFtZSwgaWQpO1xuICBpZiAoYWxyZWFkeUxvYWRlZCkge1xuICAgIHByb2Nlc3MubmV4dFRpY2soZmV0Y2hEb2NDYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgZG9jLnNoYXJlRG9jLmZldGNoKGZldGNoRG9jQ2FsbGJhY2spO1xuICB9XG4gIGZ1bmN0aW9uIGZldGNoRG9jQ2FsbGJhY2soZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgaWYgKGRvYy5zaGFyZURvYy52ZXJzaW9uICE9PSBtb2RlbC5fbG9hZFZlcnNpb25zW3BhdGhdKSB7XG4gICAgICBtb2RlbC5fbG9hZFZlcnNpb25zW3BhdGhdID0gZG9jLnNoYXJlRG9jLnZlcnNpb247XG4gICAgICBtb2RlbC5lbWl0KCdsb2FkJywgW2NvbGxlY3Rpb25OYW1lLCBpZF0sIFtkb2MuZ2V0KCksIG1vZGVsLl9wYXNzXSk7XG4gICAgfVxuICAgIGNiKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbGxlY3Rpb25OYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgb2YgdGhlIGRvY3VtZW50IHdlIHdhbnQgdG8gc3Vic2NyaWJlIHRvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYihlcnIpXG4gKi9cbk1vZGVsLnByb3RvdHlwZS5zdWJzY3JpYmVEb2MgPSBmdW5jdGlvbihjb2xsZWN0aW9uTmFtZSwgaWQsIGNiKSB7XG4gIGlmICghY2IpIGNiID0gdGhpcy5fZGVmYXVsdENhbGxiYWNrO1xuXG4gIHZhciBwYXRoID0gY29sbGVjdGlvbk5hbWUgKyAnLicgKyBpZDtcbiAgdGhpcy5lbWl0KCdzdWJzY3JpYmVEb2MnLCBwYXRoLCB0aGlzLl9jb250ZXh0LCB0aGlzLl9wYXNzKTtcbiAgdmFyIGNvdW50ID0gdGhpcy5fc3Vic2NyaWJlZERvY3NbcGF0aF0gPSAodGhpcy5fc3Vic2NyaWJlZERvY3NbcGF0aF0gfHwgMCkgKyAxO1xuICAvLyBBbHJlYWR5IHJlcXVlc3RlZCBhIHN1YnNjcmliZSwgc28ganVzdCByZXR1cm5cbiAgaWYgKGNvdW50ID4gMSkgcmV0dXJuIGNiKCk7XG5cbiAgLy8gU3Vic2NyaWJlIGlmIGN1cnJlbnRseSB1bnN1YnNjcmliZWRcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgdmFyIGRvYyA9IHRoaXMuZ2V0T3JDcmVhdGVEb2MoY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgaWYgKHRoaXMuZmV0Y2hPbmx5KSB7XG4gICAgLy8gT25seSBmZXRjaCBpZiB0aGUgZG9jdW1lbnQgaXNuJ3QgYWxyZWFkeSBsb2FkZWRcbiAgICBpZiAoZG9jLmdldCgpID09PSB2b2lkIDApIHtcbiAgICAgIGRvYy5zaGFyZURvYy5mZXRjaChzdWJzY3JpYmVEb2NDYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soc3Vic2NyaWJlRG9jQ2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkb2Muc2hhcmVEb2Muc3Vic2NyaWJlKHN1YnNjcmliZURvY0NhbGxiYWNrKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmVEb2NDYWxsYmFjayhlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICBpZiAoIWRvYy5jcmVhdGVkTG9jYWxseSAmJiBkb2Muc2hhcmVEb2MudmVyc2lvbiAhPT0gbW9kZWwuX2xvYWRWZXJzaW9uc1twYXRoXSkge1xuICAgICAgbW9kZWwuX2xvYWRWZXJzaW9uc1twYXRoXSA9IGRvYy5zaGFyZURvYy52ZXJzaW9uO1xuICAgICAgbW9kZWwuZW1pdCgnbG9hZCcsIFtjb2xsZWN0aW9uTmFtZSwgaWRdLCBbZG9jLmdldCgpLCBtb2RlbC5fcGFzc10pO1xuICAgIH1cbiAgICBjYigpO1xuICB9XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUudW5mZXRjaERvYyA9IGZ1bmN0aW9uKGNvbGxlY3Rpb25OYW1lLCBpZCwgY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLl9kZWZhdWx0Q2FsbGJhY2s7XG4gIHZhciBwYXRoID0gY29sbGVjdGlvbk5hbWUgKyAnLicgKyBpZDtcbiAgdGhpcy5lbWl0KCd1bmZldGNoRG9jJywgcGF0aCwgdGhpcy5fY29udGV4dCwgdGhpcy5fcGFzcyk7XG4gIHZhciBmZXRjaGVkRG9jcyA9IHRoaXMuX2ZldGNoZWREb2NzO1xuXG4gIC8vIE5vIGVmZmVjdCBpZiB0aGUgZG9jdW1lbnQgaGFzIG5vIGZldGNoIGNvdW50XG4gIGlmICghZmV0Y2hlZERvY3NbcGF0aF0pIHJldHVybiBjYigpO1xuXG4gIHZhciBtb2RlbCA9IHRoaXM7XG4gIGlmICh0aGlzLnVubG9hZERlbGF5ICYmICF0aGlzLl9wYXNzLiRxdWVyeSkge1xuICAgIHNldFRpbWVvdXQoZmluaXNoVW5mZXRjaERvYywgdGhpcy51bmxvYWREZWxheSk7XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoVW5mZXRjaERvYygpO1xuICB9XG4gIGZ1bmN0aW9uIGZpbmlzaFVuZmV0Y2hEb2MoKSB7XG4gICAgdmFyIGNvdW50ID0gLS1mZXRjaGVkRG9jc1twYXRoXTtcbiAgICBpZiAoY291bnQpIHJldHVybiBjYihudWxsLCBjb3VudCk7XG4gICAgZGVsZXRlIGZldGNoZWREb2NzW3BhdGhdO1xuICAgIG1vZGVsLl9tYXliZVVubG9hZERvYyhjb2xsZWN0aW9uTmFtZSwgaWQsIHBhdGgpO1xuICAgIGNiKG51bGwsIDApO1xuICB9XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUudW5zdWJzY3JpYmVEb2MgPSBmdW5jdGlvbihjb2xsZWN0aW9uTmFtZSwgaWQsIGNiKSB7XG4gIGlmICghY2IpIGNiID0gdGhpcy5fZGVmYXVsdENhbGxiYWNrO1xuICB2YXIgcGF0aCA9IGNvbGxlY3Rpb25OYW1lICsgJy4nICsgaWQ7XG4gIHRoaXMuZW1pdCgndW5zdWJzY3JpYmVEb2MnLCBwYXRoLCB0aGlzLl9jb250ZXh0LCB0aGlzLl9wYXNzKTtcbiAgdmFyIHN1YnNjcmliZWREb2NzID0gdGhpcy5fc3Vic2NyaWJlZERvY3M7XG5cbiAgLy8gTm8gZWZmZWN0IGlmIHRoZSBkb2N1bWVudCBpcyBub3QgY3VycmVudGx5IHN1YnNjcmliZWRcbiAgaWYgKCFzdWJzY3JpYmVkRG9jc1twYXRoXSkgcmV0dXJuIGNiKCk7XG5cbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgaWYgKHRoaXMudW5sb2FkRGVsYXkgJiYgIXRoaXMuX3Bhc3MuJHF1ZXJ5KSB7XG4gICAgc2V0VGltZW91dChmaW5pc2hVbnN1YnNjcmliZURvYywgdGhpcy51bmxvYWREZWxheSk7XG4gIH0gZWxzZSB7XG4gICAgZmluaXNoVW5zdWJzY3JpYmVEb2MoKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hVbnN1YnNjcmliZURvYygpIHtcbiAgICB2YXIgY291bnQgPSAtLXN1YnNjcmliZWREb2NzW3BhdGhdO1xuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHJlbWFpbmluZyBzdWJzY3JpcHRpb25zLCBvbmx5IGRlY3JlbWVudCB0aGUgY291bnRcbiAgICAvLyBhbmQgY2FsbGJhY2sgd2l0aCBob3cgbWFueSBzdWJzY3JpcHRpb25zIGFyZSByZW1haW5pbmdcbiAgICBpZiAoY291bnQpIHJldHVybiBjYihudWxsLCBjb3VudCk7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBvbmx5IG9uZSByZW1haW5pbmcgc3Vic2NyaXB0aW9uLCBhY3R1YWxseSB1bnN1YnNjcmliZVxuICAgIGRlbGV0ZSBzdWJzY3JpYmVkRG9jc1twYXRoXTtcbiAgICBpZiAobW9kZWwuZmV0Y2hPbmx5KSB7XG4gICAgICB1bnN1YnNjcmliZURvY0NhbGxiYWNrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzaGFyZURvYyA9IG1vZGVsLnNoYXJlQ29ubmVjdGlvbi5nZXQoY29sbGVjdGlvbk5hbWUsIGlkKTtcbiAgICAgIGlmICghc2hhcmVEb2MpIHtcbiAgICAgICAgcmV0dXJuIGNiKG5ldyBFcnJvcignU2hhcmUgZG9jdW1lbnQgbm90IGZvdW5kIGZvcjogJyArIHBhdGgpKTtcbiAgICAgIH1cbiAgICAgIHNoYXJlRG9jLnVuc3Vic2NyaWJlKHVuc3Vic2NyaWJlRG9jQ2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB1bnN1YnNjcmliZURvY0NhbGxiYWNrKGVycikge1xuICAgIG1vZGVsLl9tYXliZVVubG9hZERvYyhjb2xsZWN0aW9uTmFtZSwgaWQsIHBhdGgpO1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgIGNiKG51bGwsIDApO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIGRvY3VtZW50IGZyb20gdGhlIGxvY2FsIG1vZGVsIGlmIHRoZSBtb2RlbCBubyBsb25nZXIgaGFzIGFueVxuICogcmVtYWluaW5nIGZldGNoZXMgb3Igc3Vic2NyaWJlcyBvbiBwYXRoLlxuICogQ2FsbGVkIGZyb20gTW9kZWwucHJvdG90eXBlLnVuZmV0Y2hEb2MgYW5kIE1vZGVsLnByb3RvdHlwZS51bnN1YnNjcmliZURvYyBhc1xuICogcGFydCBvZiBhdHRlbXB0ZWQgY2xlYW51cC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb2xsZWN0aW9uTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGlkXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICovXG5Nb2RlbC5wcm90b3R5cGUuX21heWJlVW5sb2FkRG9jID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGlkLCBwYXRoKSB7XG4gIHZhciBkb2MgPSB0aGlzLmdldERvYyhjb2xsZWN0aW9uTmFtZSwgaWQpO1xuICBpZiAoIWRvYykgcmV0dXJuO1xuICAvLyBSZW1vdmUgdGhlIGRvY3VtZW50IGZyb20gdGhlIGxvY2FsIG1vZGVsIGlmIGl0IG5vIGxvbmdlciBoYXMgYW55XG4gIC8vIHJlbWFpbmluZyBmZXRjaGVzIG9yIHN1YnNjcmliZXNcbiAgaWYgKHRoaXMuX2ZldGNoZWREb2NzW3BhdGhdIHx8IHRoaXMuX3N1YnNjcmliZWREb2NzW3BhdGhdKSByZXR1cm47XG4gIHZhciBwcmV2aW91cyA9IGRvYy5nZXQoKTtcbiAgdGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uTmFtZV0ucmVtb3ZlKGlkKTtcbiAgaWYgKGRvYy5zaGFyZURvYykgZG9jLnNoYXJlRG9jLmRlc3Ryb3koKTtcbiAgZGVsZXRlIHRoaXMuX2xvYWRWZXJzaW9uc1twYXRoXTtcbiAgdGhpcy5lbWl0KCd1bmxvYWQnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW3ByZXZpb3VzLCB0aGlzLl9wYXNzXSk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuX2dldE9yQ3JlYXRlU2hhcmVEb2MgPSBmdW5jdGlvbihjb2xsZWN0aW9uTmFtZSwgaWQsIGRhdGEpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZUNvbm5lY3Rpb24uZ2V0T3JDcmVhdGUoY29sbGVjdGlvbk5hbWUsIGlkLCBkYXRhKTtcbiAgc2hhcmVEb2MuaW5jcmVtZW50YWwgPSB0cnVlO1xuICByZXR1cm4gc2hhcmVEb2M7XG59O1xuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwiLyoqXG4gKiBDb250ZXh0cyBhcmUgdXNlZnVsIGZvciBrZWVwaW5nIHRyYWNrIG9mIHRoZSBvcmlnaW4gb2Ygc3Vic2NyaWJlcy5cbiAqL1xuXG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG52YXIgUXVlcnkgPSByZXF1aXJlKCcuL1F1ZXJ5Jyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwuX2NvbnRleHRzID0gbmV3IENvbnRleHRzO1xuICBtb2RlbC5zZXRDb250ZXh0KCdyb290Jyk7XG4gIFsgJ2ZldGNoRG9jJywgJ3N1YnNjcmliZURvYycsICd1bmZldGNoRG9jJywgJ3Vuc3Vic2NyaWJlRG9jJ1xuICAsICdmZXRjaFF1ZXJ5JywgJ3N1YnNjcmliZVF1ZXJ5JywgJ3VuZmV0Y2hRdWVyeScsICd1bnN1YnNjcmliZVF1ZXJ5J1xuICBdLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBtb2RlbC5vbihldmVudCwgZnVuY3Rpb24oaXRlbSwgY29udGV4dCwgcGFzcykge1xuICAgICAgY29udGV4dFtldmVudF0oaXRlbSwgcGFzcyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG5cbk1vZGVsLnByb3RvdHlwZS5jb250ZXh0ID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1vZGVsID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgbW9kZWwuc2V0Q29udGV4dChpZCk7XG4gIHJldHVybiBtb2RlbDtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5zZXRDb250ZXh0ID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0c1tpZF0gfHwgbmV3IENvbnRleHQodGhpcywgaWQpO1xuICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fY29udGV4dHNbaWRdID0gY29udGV4dDtcbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUudW5sb2FkID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGNvbnRleHQgPSAoaWQpID8gdGhpcy5fY29udGV4dHNbaWRdIDogdGhpcy5fY29udGV4dDtcbiAgY29udGV4dC51bmxvYWQoKTtcbn07XG5cbmZ1bmN0aW9uIENvbnRleHRzKCkge31cblxuZnVuY3Rpb24gRmV0Y2hlZERvY3MoKSB7fVxuZnVuY3Rpb24gU3Vic2NyaWJlZERvY3MoKSB7fVxuZnVuY3Rpb24gRmV0Y2hlZFF1ZXJpZXMoKSB7fVxuZnVuY3Rpb24gU3Vic2NyaWJlZFF1ZXJpZXMoKSB7fVxuXG5mdW5jdGlvbiBDb250ZXh0KG1vZGVsLCBpZCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5mZXRjaGVkRG9jcyA9IG5ldyBGZXRjaGVkRG9jcztcbiAgdGhpcy5zdWJzY3JpYmVkRG9jcyA9IG5ldyBTdWJzY3JpYmVkRG9jcztcbiAgdGhpcy5mZXRjaGVkUXVlcmllcyA9IG5ldyBGZXRjaGVkUXVlcmllcztcbiAgdGhpcy5zdWJzY3JpYmVkUXVlcmllcyA9IG5ldyBTdWJzY3JpYmVkUXVlcmllcztcbn1cblxuQ29udGV4dC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgZmV0Y2hlZERvY3M6IHRoaXMuZmV0Y2hlZERvY3NcbiAgLCBzdWJzY3JpYmVkRG9jczogdGhpcy5zdWJzY3JpYmVkRG9jc1xuICAsIGZldGNoZWRRdWVyaWVzOiB0aGlzLmZldGNoZWRRdWVyaWVzXG4gICwgc3Vic2NyaWJlZFF1ZXJpZXM6IHRoaXMuc3Vic2NyaWJlZFF1ZXJpZXNcbiAgfTtcbn07XG5cbkNvbnRleHQucHJvdG90eXBlLmZldGNoRG9jID0gZnVuY3Rpb24ocGF0aCwgcGFzcykge1xuICBpZiAocGFzcy4kcXVlcnkpIHJldHVybjtcbiAgbWFwSW5jcmVtZW50KHRoaXMuZmV0Y2hlZERvY3MsIHBhdGgpO1xufTtcbkNvbnRleHQucHJvdG90eXBlLnN1YnNjcmliZURvYyA9IGZ1bmN0aW9uKHBhdGgsIHBhc3MpIHtcbiAgaWYgKHBhc3MuJHF1ZXJ5KSByZXR1cm47XG4gIG1hcEluY3JlbWVudCh0aGlzLnN1YnNjcmliZWREb2NzLCBwYXRoKTtcbn07XG5Db250ZXh0LnByb3RvdHlwZS51bmZldGNoRG9jID0gZnVuY3Rpb24ocGF0aCwgcGFzcykge1xuICBpZiAocGFzcy4kcXVlcnkpIHJldHVybjtcbiAgbWFwRGVjcmVtZW50KHRoaXMuZmV0Y2hlZERvY3MsIHBhdGgpO1xufTtcbkNvbnRleHQucHJvdG90eXBlLnVuc3Vic2NyaWJlRG9jID0gZnVuY3Rpb24ocGF0aCwgcGFzcykge1xuICBpZiAocGFzcy4kcXVlcnkpIHJldHVybjtcbiAgbWFwRGVjcmVtZW50KHRoaXMuc3Vic2NyaWJlZERvY3MsIHBhdGgpO1xufTtcbkNvbnRleHQucHJvdG90eXBlLmZldGNoUXVlcnkgPSBmdW5jdGlvbihxdWVyeSkge1xuICBtYXBJbmNyZW1lbnQodGhpcy5mZXRjaGVkUXVlcmllcywgcXVlcnkuaGFzaCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUuc3Vic2NyaWJlUXVlcnkgPSBmdW5jdGlvbihxdWVyeSkge1xuICBtYXBJbmNyZW1lbnQodGhpcy5zdWJzY3JpYmVkUXVlcmllcywgcXVlcnkuaGFzaCk7XG59O1xuQ29udGV4dC5wcm90b3R5cGUudW5mZXRjaFF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgbWFwRGVjcmVtZW50KHRoaXMuZmV0Y2hlZFF1ZXJpZXMsIHF1ZXJ5Lmhhc2gpO1xufTtcbkNvbnRleHQucHJvdG90eXBlLnVuc3Vic2NyaWJlUXVlcnkgPSBmdW5jdGlvbihxdWVyeSkge1xuICBtYXBEZWNyZW1lbnQodGhpcy5zdWJzY3JpYmVkUXVlcmllcywgcXVlcnkuaGFzaCk7XG59O1xuZnVuY3Rpb24gbWFwSW5jcmVtZW50KG1hcCwga2V5KSB7XG4gIG1hcFtrZXldID0gKG1hcFtrZXldIHx8IDApICsgMTtcbn1cbmZ1bmN0aW9uIG1hcERlY3JlbWVudChtYXAsIGtleSkge1xuICBtYXBba2V5XSAmJiBtYXBba2V5XS0tO1xuICBpZiAoIW1hcFtrZXldKSBkZWxldGUgbWFwW2tleV07XG59XG5cbkNvbnRleHQucHJvdG90eXBlLnVubG9hZCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xuICBmb3IgKHZhciBoYXNoIGluIHRoaXMuZmV0Y2hlZFF1ZXJpZXMpIHtcbiAgICB2YXIgcXVlcnkgPSBtb2RlbC5fcXVlcmllcy5tYXBbaGFzaF07XG4gICAgaWYgKCFxdWVyeSkgY29udGludWU7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5mZXRjaGVkUXVlcmllc1toYXNoXTtcbiAgICB3aGlsZSAoY291bnQtLSkgcXVlcnkudW5mZXRjaChudWxsKTtcbiAgfVxuICBmb3IgKHZhciBoYXNoIGluIHRoaXMuc3Vic2NyaWJlZFF1ZXJpZXMpIHtcbiAgICB2YXIgcXVlcnkgPSBtb2RlbC5fcXVlcmllcy5tYXBbaGFzaF07XG4gICAgaWYgKCFxdWVyeSkgY29udGludWU7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5zdWJzY3JpYmVkUXVlcmllc1toYXNoXTtcbiAgICB3aGlsZSAoY291bnQtLSkgcXVlcnkudW5zdWJzY3JpYmUobnVsbCk7XG4gIH1cbiAgZm9yICh2YXIgcGF0aCBpbiB0aGlzLmZldGNoZWREb2NzKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHZhciBjb3VudCA9IHRoaXMuZmV0Y2hlZERvY3NbcGF0aF07XG4gICAgd2hpbGUgKGNvdW50LS0pIG1vZGVsLnVuZmV0Y2hEb2Moc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdKTtcbiAgfVxuICBmb3IgKHZhciBwYXRoIGluIHRoaXMuc3Vic2NyaWJlZERvY3MpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgdmFyIGNvdW50ID0gdGhpcy5zdWJzY3JpYmVkRG9jc1twYXRoXTtcbiAgICB3aGlsZSAoY291bnQtLSkgbW9kZWwudW5zdWJzY3JpYmVEb2Moc2VnbWVudHNbMF0sIHNlZ21lbnRzWzFdKTtcbiAgfVxuICB0aGlzLm1vZGVsLl9jb250ZXh0ID0gdGhpcy5tb2RlbC5fY29udGV4dHNbdGhpcy5pZF0gPVxuICAgIG5ldyBDb250ZXh0KHRoaXMubW9kZWwsIHRoaXMuaWQpO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9pbmRleCcpO1xudmFyIGRlZmF1bHRGbnMgPSByZXF1aXJlKCcuL2RlZmF1bHRGbnMnKTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICBtb2RlbC5fbmFtZWRGbnMgPSBPYmplY3QuY3JlYXRlKGRlZmF1bHRGbnMpO1xuICBtb2RlbC5fZm5zID0gbmV3IEZucyhtb2RlbCk7XG4gIG1vZGVsLm9uKCdhbGwnLCBmbkxpc3RlbmVyKTtcbiAgZnVuY3Rpb24gZm5MaXN0ZW5lcihzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBtYXAgPSBtb2RlbC5fZm5zLmZyb21NYXA7XG4gICAgZm9yICh2YXIgcGF0aCBpbiBtYXApIHtcbiAgICAgIHZhciBmbiA9IG1hcFtwYXRoXTtcbiAgICAgIGlmIChwYXNzLiRmbiA9PT0gZm4pIGNvbnRpbnVlO1xuICAgICAgaWYgKHV0aWwubWF5SW1wYWN0QW55KGZuLmlucHV0c1NlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICAgICAgLy8gTXV0YXRpb24gYWZmZWN0aW5nIGlucHV0IHBhdGhcbiAgICAgICAgZm4ub25JbnB1dChwYXNzKTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbC5tYXlJbXBhY3QoZm4uZnJvbVNlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICAgICAgLy8gTXV0YXRpb24gYWZmZWN0aW5nIG91dHB1dCBwYXRoXG4gICAgICAgIGZuLm9uT3V0cHV0KHBhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbk1vZGVsLnByb3RvdHlwZS5mbiA9IGZ1bmN0aW9uKG5hbWUsIGZucykge1xuICB0aGlzLl9uYW1lZEZuc1tuYW1lXSA9IGZucztcbn07XG5cbmZ1bmN0aW9uIHBhcnNlU3RhcnRBcmd1bWVudHMobW9kZWwsIGFyZ3MsIGhhc1BhdGgpIHtcbiAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZucyA9IGFyZ3NbMF07XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBhcmdzWzBdO1xuICB9XG4gIGlmIChoYXNQYXRoKSB7XG4gICAgdmFyIHBhdGggPSBtb2RlbC5wYXRoKGFyZ3NbMV0pO1xuICAgIHZhciBpbnB1dFBhdGhzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGlucHV0UGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKTtcbiAgfVxuICB2YXIgaSA9IGlucHV0UGF0aHMubGVuZ3RoIC0gMTtcbiAgaWYgKG1vZGVsLmlzUGF0aChpbnB1dFBhdGhzW2ldKSkge1xuICAgIGlucHV0UGF0aHNbaV0gPSBtb2RlbC5wYXRoKGlucHV0UGF0aHNbaV0pO1xuICB9IGVsc2Uge1xuICAgIHZhciBvcHRpb25zID0gaW5wdXRQYXRocy5wb3AoKTtcbiAgfVxuICB3aGlsZSAoaS0tKSB7XG4gICAgaW5wdXRQYXRoc1tpXSA9IG1vZGVsLnBhdGgoaW5wdXRQYXRoc1tpXSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBuYW1lXG4gICwgcGF0aDogcGF0aFxuICAsIGlucHV0UGF0aHM6IGlucHV0UGF0aHNcbiAgLCBmbnM6IGZuc1xuICAsIG9wdGlvbnM6IG9wdGlvbnNcbiAgfTtcbn1cblxuTW9kZWwucHJvdG90eXBlLmV2YWx1YXRlID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgYXJncyA9IHBhcnNlU3RhcnRBcmd1bWVudHModGhpcywgYXJndW1lbnRzLCBmYWxzZSk7XG4gIHJldHVybiB0aGlzLl9mbnMuZ2V0KGFyZ3MubmFtZSwgYXJncy5pbnB1dFBhdGhzLCBhcmdzLmZucywgYXJncy5vcHRpb25zKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKG5hbWUsIHN1YnBhdGgpIHtcbiAgdmFyIGFyZ3MgPSBwYXJzZVN0YXJ0QXJndW1lbnRzKHRoaXMsIGFyZ3VtZW50cywgdHJ1ZSk7XG4gIHJldHVybiB0aGlzLl9mbnMuc3RhcnQoYXJncy5uYW1lLCBhcmdzLnBhdGgsIGFyZ3MuaW5wdXRQYXRocywgYXJncy5mbnMsIGFyZ3Mub3B0aW9ucyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKHN1YnBhdGgpIHtcbiAgdmFyIHBhdGggPSB0aGlzLnBhdGgoc3VicGF0aCk7XG4gIHRoaXMuX2Zucy5zdG9wKHBhdGgpO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnN0b3BBbGwgPSBmdW5jdGlvbihzdWJwYXRoKSB7XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgdmFyIGZucyA9IHRoaXMuX2Zucy5mcm9tTWFwO1xuICBmb3IgKHZhciBmcm9tIGluIGZucykge1xuICAgIGlmICh1dGlsLmNvbnRhaW5zKHNlZ21lbnRzLCBmbnNbZnJvbV0uZnJvbVNlZ21lbnRzKSkge1xuICAgICAgdGhpcy5zdG9wKGZyb20pO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gRnJvbU1hcCgpIHt9XG5mdW5jdGlvbiBGbnMobW9kZWwpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICB0aGlzLm5hbWVNYXAgPSBtb2RlbC5fbmFtZWRGbnM7XG4gIHRoaXMuZnJvbU1hcCA9IG5ldyBGcm9tTWFwO1xufVxuXG5GbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUsIGlucHV0UGF0aHMsIGZucywgb3B0aW9ucykge1xuICBmbnMgfHwgKGZucyA9IHRoaXMubmFtZU1hcFtuYW1lXSk7XG4gIHZhciBmbiA9IG5ldyBGbih0aGlzLm1vZGVsLCBuYW1lLCBudWxsLCBpbnB1dFBhdGhzLCBmbnMsIG9wdGlvbnMpO1xuICByZXR1cm4gZm4uZ2V0KCk7XG59O1xuXG5GbnMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24obmFtZSwgcGF0aCwgaW5wdXRQYXRocywgZm5zLCBvcHRpb25zKSB7XG4gIGZucyB8fCAoZm5zID0gdGhpcy5uYW1lTWFwW25hbWVdKTtcbiAgdmFyIGZuID0gbmV3IEZuKHRoaXMubW9kZWwsIG5hbWUsIHBhdGgsIGlucHV0UGF0aHMsIGZucywgb3B0aW9ucyk7XG4gIHRoaXMuZnJvbU1hcFtwYXRoXSA9IGZuO1xuICByZXR1cm4gZm4ub25JbnB1dCgpO1xufTtcblxuRm5zLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgZm4gPSB0aGlzLmZyb21NYXBbcGF0aF07XG4gIGRlbGV0ZSB0aGlzLmZyb21NYXBbcGF0aF07XG4gIHJldHVybiBmbjtcbn07XG5cbkZucy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvdXQgPSBbXTtcbiAgZm9yICh2YXIgZnJvbSBpbiB0aGlzLmZyb21NYXApIHtcbiAgICB2YXIgZm4gPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gICAgLy8gRG9uJ3QgdHJ5IHRvIGJ1bmRsZSBub24tbmFtZWQgZnVuY3Rpb25zIHRoYXQgd2VyZSBzdGFydGVkIHZpYVxuICAgIC8vIG1vZGVsLnN0YXJ0IGRpcmVjdGx5IGluc3RlYWQgb2YgYnkgbmFtZVxuICAgIGlmICghZm4ubmFtZSkgY29udGludWU7XG4gICAgb3V0LnB1c2goW2ZuLm5hbWUsIGZuLmZyb21dLmNvbmNhdChmbi5pbnB1dFBhdGhzKSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbmZ1bmN0aW9uIEZuKG1vZGVsLCBuYW1lLCBmcm9tLCBpbnB1dFBhdGhzLCBmbnMsIG9wdGlvbnMpIHtcbiAgdGhpcy5tb2RlbCA9IG1vZGVsLnBhc3MoeyRmbjogdGhpc30pO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmZyb20gPSBmcm9tO1xuICB0aGlzLmlucHV0UGF0aHMgPSBpbnB1dFBhdGhzO1xuICBpZiAoIWZucykge1xuICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKCdNb2RlbCBmdW5jdGlvbiBub3QgZm91bmQ6ICcgKyBuYW1lKTtcbiAgICBtb2RlbC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbiAgdGhpcy5nZXRGbiA9IGZucy5nZXQgfHwgZm5zO1xuICB0aGlzLnNldEZuID0gZm5zLnNldDtcbiAgdGhpcy5mcm9tU2VnbWVudHMgPSBmcm9tICYmIGZyb20uc3BsaXQoJy4nKTtcbiAgdGhpcy5pbnB1dHNTZWdtZW50cyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5wdXRQYXRocy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzZWdtZW50cyA9IHRoaXMuaW5wdXRQYXRoc1tpXS5zcGxpdCgnLicpO1xuICAgIHRoaXMuaW5wdXRzU2VnbWVudHMucHVzaChzZWdtZW50cyk7XG4gIH1cbiAgdmFyIGNvcHkgPSAob3B0aW9ucyAmJiBvcHRpb25zLmNvcHkpIHx8ICdvdXRwdXQnO1xuICB0aGlzLmNvcHlJbnB1dCA9IChjb3B5ID09PSAnaW5wdXQnIHx8IGNvcHkgPT09ICdib3RoJyk7XG4gIHRoaXMuY29weU91dHB1dCA9IChjb3B5ID09PSAnb3V0cHV0JyB8fCBjb3B5ID09PSAnYm90aCcpO1xufVxuXG5Gbi5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbihmbiwgaW5wdXRzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmlucHV0c1NlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMuaW5wdXRzU2VnbWVudHNbaV0pO1xuICAgIGlucHV0cy5wdXNoKHRoaXMuY29weUlucHV0ID8gdXRpbC5kZWVwQ29weShpbnB1dCkgOiBpbnB1dCk7XG4gIH1cbiAgcmV0dXJuIGZuLmFwcGx5KHRoaXMubW9kZWwsIGlucHV0cyk7XG59O1xuXG5Gbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmFwcGx5KHRoaXMuZ2V0Rm4sIFtdKTtcbn07XG5cbnZhciBkaWZmT3B0aW9ucyA9IHtlcXVhbDogdXRpbC5kZWVwRXF1YWx9O1xudmFyIGVhY2hEaWZmT3B0aW9ucyA9IHtlYWNoOiB0cnVlLCBlcXVhbDogdXRpbC5kZWVwRXF1YWx9O1xuXG5Gbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24odmFsdWUsIHBhc3MpIHtcbiAgaWYgKCF0aGlzLnNldEZuKSByZXR1cm47XG4gIHZhciBvdXQgPSB0aGlzLmFwcGx5KHRoaXMuc2V0Rm4sIFt2YWx1ZV0pO1xuICBpZiAoIW91dCkgcmV0dXJuO1xuICB2YXIgaW5wdXRzU2VnbWVudHMgPSB0aGlzLmlucHV0c1NlZ21lbnRzO1xuICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG4gIGZvciAodmFyIGtleSBpbiBvdXQpIHtcbiAgICBpZiAoa2V5ID09PSAnZWFjaCcpIHtcbiAgICAgIHZhciBlYWNoID0gb3V0W2tleV07XG4gICAgICBmb3IgKGtleSBpbiBlYWNoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICh0aGlzLmNvcHlPdXRwdXQpID8gdXRpbC5kZWVwQ29weShlYWNoW2tleV0pIDogZWFjaFtrZXldO1xuICAgICAgICBtb2RlbC5fc2V0RGlmZihpbnB1dHNTZWdtZW50c1trZXldLCB2YWx1ZSwgZWFjaERpZmZPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSAodGhpcy5jb3B5T3V0cHV0KSA/IHV0aWwuZGVlcENvcHkob3V0W2tleV0pIDogb3V0W2tleV07XG4gICAgbW9kZWwuX3NldERpZmYoaW5wdXRzU2VnbWVudHNba2V5XSwgdmFsdWUsIGRpZmZPcHRpb25zKTtcbiAgfVxufTtcblxuRm4ucHJvdG90eXBlLm9uSW5wdXQgPSBmdW5jdGlvbihwYXNzKSB7XG4gIHZhciB2YWx1ZSA9ICh0aGlzLmNvcHlPdXRwdXQpID8gdXRpbC5kZWVwQ29weSh0aGlzLmdldCgpKSA6IHRoaXMuZ2V0KCk7XG4gIHRoaXMubW9kZWwucGFzcyhwYXNzLCB0cnVlKS5fc2V0RGlmZih0aGlzLmZyb21TZWdtZW50cywgdmFsdWUsIGRpZmZPcHRpb25zKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuRm4ucHJvdG90eXBlLm9uT3V0cHV0ID0gZnVuY3Rpb24ocGFzcykge1xuICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy5mcm9tU2VnbWVudHMpO1xuICByZXR1cm4gdGhpcy5zZXQodmFsdWUsIHBhc3MpO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5Nb2RlbC5JTklUUy5wdXNoKGZ1bmN0aW9uKG1vZGVsKSB7XG4gIG1vZGVsLl9maWx0ZXJzID0gbmV3IEZpbHRlcnMobW9kZWwpO1xuICBtb2RlbC5vbignYWxsJywgZmlsdGVyTGlzdGVuZXIpO1xuICBmdW5jdGlvbiBmaWx0ZXJMaXN0ZW5lcihzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gICAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBtYXAgPSBtb2RlbC5fZmlsdGVycy5mcm9tTWFwO1xuICAgIGZvciAodmFyIHBhdGggaW4gbWFwKSB7XG4gICAgICB2YXIgZmlsdGVyID0gbWFwW3BhdGhdO1xuICAgICAgaWYgKHBhc3MuJGZpbHRlciA9PT0gZmlsdGVyKSBjb250aW51ZTtcbiAgICAgIGlmICh1dGlsLm1heUltcGFjdChmaWx0ZXIuaW5wdXRTZWdtZW50cywgc2VnbWVudHMpKSB7XG4gICAgICAgIGZpbHRlci51cGRhdGUocGFzcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuTW9kZWwucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uKGlucHV0LCBmbikge1xuICB2YXIgaW5wdXRQYXRoID0gdGhpcy5wYXRoKGlucHV0KTtcbiAgcmV0dXJuIHRoaXMuX2ZpbHRlcnMuYWRkKGlucHV0UGF0aCwgZm4pO1xufTtcblxuTW9kZWwucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihpbnB1dCwgZm4pIHtcbiAgdmFyIGlucHV0UGF0aCA9IHRoaXMucGF0aChpbnB1dCk7XG4gIHJldHVybiB0aGlzLl9maWx0ZXJzLmFkZChpbnB1dFBhdGgsIG51bGwsIGZuIHx8ICdhc2MnKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5yZW1vdmVBbGxGaWx0ZXJzID0gZnVuY3Rpb24oc3VicGF0aCkge1xuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHZhciBmaWx0ZXJzID0gdGhpcy5fZmlsdGVycy5mcm9tTWFwO1xuICBmb3IgKHZhciBmcm9tIGluIGZpbHRlcnMpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhzZWdtZW50cywgZmlsdGVyc1tmcm9tXS5mcm9tU2VnbWVudHMpKSB7XG4gICAgICBmaWx0ZXJzW2Zyb21dLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIEZyb21NYXAoKSB7fVxuZnVuY3Rpb24gRmlsdGVycyhtb2RlbCkge1xuICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gIHRoaXMuZnJvbU1hcCA9IG5ldyBGcm9tTWFwO1xufVxuXG5GaWx0ZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihpbnB1dFBhdGgsIGZpbHRlckZuLCBzb3J0Rm4pIHtcbiAgcmV0dXJuIG5ldyBGaWx0ZXIodGhpcywgaW5wdXRQYXRoLCBmaWx0ZXJGbiwgc29ydEZuKTtcbn07XG5cbkZpbHRlcnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIGZpbHRlciA9IHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgICAvLyBEb24ndCB0cnkgdG8gYnVuZGxlIGlmIGZ1bmN0aW9ucyB3ZXJlIHBhc3NlZCBkaXJlY3RseSBpbnN0ZWFkIG9mIGJ5IG5hbWVcbiAgICBpZiAoIWZpbHRlci5idW5kbGUpIGNvbnRpbnVlO1xuICAgIG91dC5wdXNoKFtmaWx0ZXIuaW5wdXRQYXRoLCBmaWx0ZXIuZmlsdGVyTmFtZSwgZmlsdGVyLnNvcnROYW1lLCBmcm9tXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbmZ1bmN0aW9uIEZpbHRlcihmaWx0ZXJzLCBpbnB1dFBhdGgsIGZpbHRlckZuLCBzb3J0Rm4pIHtcbiAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgdGhpcy5tb2RlbCA9IGZpbHRlcnMubW9kZWwucGFzcyh7JGZpbHRlcjogdGhpc30pO1xuICB0aGlzLmlucHV0UGF0aCA9IGlucHV0UGF0aDtcbiAgdGhpcy5pbnB1dFNlZ21lbnRzID0gaW5wdXRQYXRoLnNwbGl0KCcuJyk7XG4gIHRoaXMuZmlsdGVyTmFtZSA9IG51bGw7XG4gIHRoaXMuc29ydE5hbWUgPSBudWxsO1xuICB0aGlzLmJ1bmRsZSA9IHRydWU7XG4gIHRoaXMuZmlsdGVyRm4gPSBudWxsO1xuICB0aGlzLnNvcnRGbiA9IG51bGw7XG4gIGlmIChmaWx0ZXJGbikgdGhpcy5maWx0ZXIoZmlsdGVyRm4pO1xuICBpZiAoc29ydEZuKSB0aGlzLnNvcnQoc29ydEZuKTtcbiAgdGhpcy5pZHNTZWdtZW50cyA9IG51bGw7XG4gIHRoaXMuZnJvbSA9IG51bGw7XG4gIHRoaXMuZnJvbVNlZ21lbnRzID0gbnVsbDtcbn1cblxuRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmbikge1xuICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5maWx0ZXJGbiA9IGZuO1xuICAgIHRoaXMuYnVuZGxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICB0aGlzLmZpbHRlck5hbWUgPSBmbjtcbiAgICB0aGlzLmZpbHRlckZuID0gdGhpcy5tb2RlbC5fbmFtZWRGbnNbZm5dO1xuICAgIGlmICghdGhpcy5maWx0ZXJGbikge1xuICAgICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IoJ0ZpbHRlciBmdW5jdGlvbiBub3QgZm91bmQ6ICcgKyBmbik7XG4gICAgICB0aGlzLm1vZGVsLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbihmbikge1xuICBpZiAoIWZuKSBmbiA9ICdhc2MnO1xuICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5zb3J0Rm4gPSBmbjtcbiAgICB0aGlzLmJ1bmRsZSA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlmICh0eXBlb2YgZm4gPT09ICdzdHJpbmcnKSB7XG4gICAgdGhpcy5zb3J0TmFtZSA9IGZuO1xuICAgIHRoaXMuc29ydEZuID0gdGhpcy5tb2RlbC5fbmFtZWRGbnNbZm5dO1xuICAgIGlmICghdGhpcy5zb3J0Rm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKCdTb3J0IGZ1bmN0aW9uIG5vdCBmb3VuZDogJyArIGZuKTtcbiAgICAgIHRoaXMubW9kZWwuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuaWRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMubW9kZWwuX2dldCh0aGlzLmlucHV0U2VnbWVudHMpO1xuICB2YXIgaWRzID0gW107XG4gIGlmICghaXRlbXMpIHJldHVybiBpZHM7XG4gIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgIGlmICh0aGlzLmZpbHRlckZuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbHRlckZuLmNhbGwodGhpcy5tb2RlbCwgaXRlbXNbaV0sIGksIGl0ZW1zKSkge1xuICAgICAgICAgIGlkcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIGlkcy5wdXNoKGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5maWx0ZXJGbikge1xuICAgICAgZm9yICh2YXIga2V5IGluIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgdGhpcy5maWx0ZXJGbi5jYWxsKHRoaXMubW9kZWwsIGl0ZW1zW2tleV0sIGtleSwgaXRlbXMpXG4gICAgICAgICkge1xuICAgICAgICAgIGlkcy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWRzID0gT2JqZWN0LmtleXMoaXRlbXMpO1xuICAgIH1cbiAgfVxuICB2YXIgc29ydEZuID0gdGhpcy5zb3J0Rm47XG4gIGlmIChzb3J0Rm4pIHtcbiAgICBpZHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICByZXR1cm4gc29ydEZuKGl0ZW1zW2FdLCBpdGVtc1tiXSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGlkcztcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpdGVtcyA9IHRoaXMubW9kZWwuX2dldCh0aGlzLmlucHV0U2VnbWVudHMpO1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICBpZiAodGhpcy5maWx0ZXJGbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJGbi5jYWxsKHRoaXMubW9kZWwsIGl0ZW1zW2ldLCBpLCBpdGVtcykpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMgPSBpdGVtcy5zbGljZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5maWx0ZXJGbikge1xuICAgICAgZm9yICh2YXIga2V5IGluIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmXG4gICAgICAgICAgdGhpcy5maWx0ZXJGbi5jYWxsKHRoaXMubW9kZWwsIGl0ZW1zW2tleV0sIGtleSwgaXRlbXMpXG4gICAgICAgICkge1xuICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtc1trZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gaXRlbXMpIHtcbiAgICAgICAgaWYgKGl0ZW1zLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goaXRlbXNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHRoaXMuc29ydEZuKSByZXN1bHRzLnNvcnQodGhpcy5zb3J0Rm4pO1xuICByZXR1cm4gcmVzdWx0cztcbn07XG5cbkZpbHRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24ocGFzcykge1xuICB2YXIgaWRzID0gdGhpcy5pZHMoKTtcbiAgdGhpcy5tb2RlbC5wYXNzKHBhc3MsIHRydWUpLl9zZXREaWZmKHRoaXMuaWRzU2VnbWVudHMsIGlkcyk7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgZnJvbSA9IHRoaXMubW9kZWwucGF0aChmcm9tKTtcbiAgdGhpcy5mcm9tID0gZnJvbTtcbiAgdGhpcy5mcm9tU2VnbWVudHMgPSBmcm9tLnNwbGl0KCcuJyk7XG4gIHRoaXMuZmlsdGVycy5mcm9tTWFwW2Zyb21dID0gdGhpcztcbiAgdGhpcy5pZHNTZWdtZW50cyA9IFsnJGZpbHRlcnMnLCBmcm9tLnJlcGxhY2UoL1xcLi9nLCAnfCcpXTtcbiAgdGhpcy51cGRhdGUoKTtcbiAgcmV0dXJuIHRoaXMubW9kZWwucmVmTGlzdChmcm9tLCB0aGlzLmlucHV0UGF0aCwgdGhpcy5pZHNTZWdtZW50cy5qb2luKCcuJykpO1xufTtcblxuRmlsdGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGRlbGV0ZSB0aGlzLmZpbHRlcnMuZnJvbU1hcFt0aGlzLmZyb21dO1xuICB0aGlzLm1vZGVsLnJlbW92ZVJlZkxpc3QodGhpcy5mcm9tKTtcbiAgdGhpcy5tb2RlbC5fZGVsKHRoaXMuaWRzU2VnbWVudHMpO1xufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xudmFyIE1vZGVsID0gcmVxdWlyZSgnLi9pbmRleCcpO1xuXG5Nb2RlbC5JTklUUy5wdXNoKGZ1bmN0aW9uKG1vZGVsKSB7XG4gIG1vZGVsLl9yZWZMaXN0cyA9IG5ldyBSZWZMaXN0cyhtb2RlbCk7XG4gIGZvciAodmFyIHR5cGUgaW4gTW9kZWwuTVVUQVRPUl9FVkVOVFMpIHtcbiAgICBhZGRMaXN0ZW5lcihtb2RlbCwgdHlwZSk7XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihtb2RlbCwgdHlwZSkge1xuICBtb2RlbC5vbih0eXBlLCByZWZMaXN0TGlzdGVuZXIpO1xuICBmdW5jdGlvbiByZWZMaXN0TGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICAvLyBDaGVjayBmb3IgdXBkYXRlcyBvbiBvciB1bmRlcm5lYXRoIHBhdGhzXG4gICAgdmFyIGZyb21NYXAgPSBtb2RlbC5fcmVmTGlzdHMuZnJvbU1hcDtcbiAgICBmb3IgKHZhciBmcm9tIGluIGZyb21NYXApIHtcbiAgICAgIHZhciByZWZMaXN0ID0gZnJvbU1hcFtmcm9tXTtcbiAgICAgIGlmIChwYXNzLiRyZWZMaXN0ID09PSByZWZMaXN0KSBjb250aW51ZTtcbiAgICAgIHJlZkxpc3Qub25NdXRhdGlvbih0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtBcnJheX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7QXJyYXl9IGV2ZW50QXJnc1xuICogQHBhcmFtIHtSZWZMaXN0fSByZWZMaXN0XG4gKi9cbmZ1bmN0aW9uIHBhdGNoRnJvbUV2ZW50KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MsIHJlZkxpc3QpIHtcbiAgdmFyIGZyb21MZW5ndGggPSByZWZMaXN0LmZyb21TZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gTXV0YXRpb24gb24gdGhlIGBmcm9tYCBvdXRwdXQgaXRzZWxmXG4gIGlmIChzZWdtZW50c0xlbmd0aCA9PT0gZnJvbUxlbmd0aCkge1xuICAgIGlmICh0eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIHZhbHVlcyA9IGV2ZW50QXJnc1sxXTtcbiAgICAgIHZhciBpZHMgPSBzZXROZXdUb1ZhbHVlcyhtb2RlbCwgcmVmTGlzdCwgdmFsdWVzKTtcbiAgICAgIG1vZGVsLl9pbnNlcnQocmVmTGlzdC5pZHNTZWdtZW50cywgaW5kZXgsIGlkcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1sxXS5sZW5ndGg7XG4gICAgICB2YXIgaWRzID0gbW9kZWwuX3JlbW92ZShyZWZMaXN0Lmlkc1NlZ21lbnRzLCBpbmRleCwgaG93TWFueSk7XG4gICAgICAvLyBEZWxldGUgdGhlIGFwcHJvcHJpYXRlIGl0ZW1zIHVuZGVybmVhdGggYHRvYCBpZiB0aGUgYGRlbGV0ZVJlbW92ZWRgXG4gICAgICAvLyBvcHRpb24gd2FzIHNldCB0cnVlXG4gICAgICBpZiAocmVmTGlzdC5kZWxldGVSZW1vdmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSByZWZMaXN0Lml0ZW1CeUlkKGlkc1tpXSk7XG4gICAgICAgICAgbW9kZWwuX2RlbChyZWZMaXN0LnRvU2VnbWVudHNCeUl0ZW0oaXRlbSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdtb3ZlJykge1xuICAgICAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgdG8gPSBldmVudEFyZ3NbMV07XG4gICAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1syXTtcbiAgICAgIG1vZGVsLl9tb3ZlKHJlZkxpc3QuaWRzU2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGFuZ2Ugb2YgdGhlIGVudGlyZSBvdXRwdXRcbiAgICB2YXIgdmFsdWVzID0gKHR5cGUgPT09ICdjaGFuZ2UnKSA/XG4gICAgICBldmVudEFyZ3NbMF0gOiBtb2RlbC5fZ2V0KHJlZkxpc3QuZnJvbVNlZ21lbnRzKTtcbiAgICAvLyBTZXQgaWRzIHRvIGVtcHR5IGxpc3QgaWYgb3V0cHV0IGlzIHNldCB0byBudWxsXG4gICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgIG1vZGVsLl9zZXQocmVmTGlzdC5pZHNTZWdtZW50cywgW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgZW50aXJlIG91dHB1dCBpcyBzZXQsIGNyZWF0ZSBhIGxpc3Qgb2YgaWRzIGJhc2VkIG9uIHRoZSBvdXRwdXQsXG4gICAgLy8gYW5kIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBpdGVtc1xuICAgIHZhciBpZHMgPSBzZXROZXdUb1ZhbHVlcyhtb2RlbCwgcmVmTGlzdCwgdmFsdWVzKTtcbiAgICBtb2RlbC5fc2V0KHJlZkxpc3QuaWRzU2VnbWVudHMsIGlkcyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgbXV0YXRpb24gaXMgb24gYSBwYXJlbnQgb2YgYGZyb21gLCB3ZSBtaWdodCBuZWVkIHRvIHJlLWNyZWF0ZSB0aGVcbiAgLy8gZW50aXJlIHJlZkxpc3Qgb3V0cHV0XG4gIGlmIChzZWdtZW50c0xlbmd0aCA8IGZyb21MZW5ndGgpIHtcbiAgICBtb2RlbC5fc2V0RGlmZihyZWZMaXN0LmZyb21TZWdtZW50cywgcmVmTGlzdC5nZXQoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGluZGV4ID0gc2VnbWVudHNbZnJvbUxlbmd0aF07XG4gIHZhciB2YWx1ZSA9IG1vZGVsLl9nZXQocmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGV4KSk7XG4gIHZhciB0b1NlZ21lbnRzID0gcmVmTGlzdC50b1NlZ21lbnRzQnlJdGVtKHZhbHVlKTtcblxuICAvLyBNdXRhdGlvbiB1bmRlcm5lYXRoIGEgY2hpbGQgb2YgdGhlIGBmcm9tYCBvYmplY3QuXG4gIGlmIChzZWdtZW50c0xlbmd0aCA+IGZyb21MZW5ndGggKyAxKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnTXV0YXRpb24gb24gZGVzY2VuZGFudCBvZiByZWZMaXN0IGBmcm9tYCBzaG91bGQgaGF2ZSBiZWVuIGRlcmVmZXJlbmNlZDogJyArIHNlZ21lbnRzLmpvaW4oJy4nKTtcbiAgICBtb2RlbC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBtdXRhdGlvbiBvZiBhIGNoaWxkIG9mIHRoZSBgZnJvbWAgb2JqZWN0XG5cbiAgLy8gSWYgY2hhbmdpbmcgdGhlIGl0ZW0gaXRzZWxmLCBpdCB3aWxsIGFsc28gaGF2ZSB0byBiZSByZS1zZXQgb24gdGhlXG4gIC8vIG9yaWdpbmFsIG9iamVjdFxuICBpZiAodHlwZSA9PT0gJ2NoYW5nZScpIHtcbiAgICBtb2RlbC5fc2V0KHRvU2VnbWVudHMsIHZhbHVlKTtcbiAgICB1cGRhdGVJZEZvclZhbHVlKG1vZGVsLCByZWZMaXN0LCBpbmRleCwgdmFsdWUpO1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUaGUgc2FtZSBnb2VzIGZvciBzdHJpbmcgbXV0YXRpb25zLCBzaW5jZSBzdHJpbmdzIGFyZSBpbW11dGFibGVcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmdJbnNlcnQnKSB7XG4gICAgdmFyIHN0cmluZ0luZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgIHZhciBzdHJpbmdWYWx1ZSA9IGV2ZW50QXJnc1sxXTtcbiAgICBtb2RlbC5fc3RyaW5nSW5zZXJ0KHRvU2VnbWVudHMsIHN0cmluZ0luZGV4LCBzdHJpbmdWYWx1ZSk7XG4gICAgdXBkYXRlSWRGb3JWYWx1ZShtb2RlbCwgcmVmTGlzdCwgaW5kZXgsIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdzdHJpbmdSZW1vdmUnKSB7XG4gICAgdmFyIHN0cmluZ0luZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzFdO1xuICAgIG1vZGVsLl9zdHJpbmdSZW1vdmUodG9TZWdtZW50cywgc3RyaW5nSW5kZXgsIGhvd01hbnkpO1xuICAgIHVwZGF0ZUlkRm9yVmFsdWUobW9kZWwsIHJlZkxpc3QsIGluZGV4LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0eXBlID09PSAnaW5zZXJ0JyB8fCB0eXBlID09PSAncmVtb3ZlJyB8fCB0eXBlID09PSAnbW92ZScpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdBcnJheSBtdXRhdGlvbiBvbiBjaGlsZCBvZiByZWZMaXN0IGBmcm9tYCBzaG91bGQgaGF2ZSBiZWVuIGRlcmVmZXJlbmNlZDogJyArIHNlZ21lbnRzLmpvaW4oJy4nKTtcbiAgICBtb2RlbC5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcihtZXNzYWdlKSk7XG4gICAgcmV0dXJuO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge1JlZkxpc3R9IHJlZkxpc3RcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlc1xuICovXG5mdW5jdGlvbiBzZXROZXdUb1ZhbHVlcyhtb2RlbCwgcmVmTGlzdCwgdmFsdWVzLCBmbikge1xuICB2YXIgaWRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgIHZhciBpZCA9IHJlZkxpc3QuaWRCeUl0ZW0odmFsdWUpO1xuICAgIGlmIChpZCA9PT0gdm9pZCAwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlkID0gdmFsdWUuaWQgPSBtb2RlbC5pZCgpO1xuICAgIH1cbiAgICB2YXIgdG9TZWdtZW50cyA9IHJlZkxpc3QudG9TZWdtZW50c0J5SXRlbSh2YWx1ZSk7XG4gICAgaWYgKGlkID09PSB2b2lkIDAgfHwgdG9TZWdtZW50cyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdVbmFibGUgdG8gYWRkIGl0ZW0gdG8gcmVmTGlzdDogJyArIHZhbHVlO1xuICAgICAgcmV0dXJuIG1vZGVsLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbW9kZWwuX3NldERpZmYodG9TZWdtZW50cywgdmFsdWUpO1xuICAgIGlkcy5wdXNoKGlkKTtcbiAgfVxuICByZXR1cm4gaWRzO1xufVxuZnVuY3Rpb24gdXBkYXRlSWRGb3JWYWx1ZShtb2RlbCwgcmVmTGlzdCwgaW5kZXgsIHZhbHVlKSB7XG4gIHZhciBpZCA9IHJlZkxpc3QuaWRCeUl0ZW0odmFsdWUpO1xuICB2YXIgb3V0U2VnbWVudHMgPSByZWZMaXN0Lmlkc1NlZ21lbnRzLmNvbmNhdChpbmRleCk7XG4gIG1vZGVsLl9zZXREaWZmKG91dFNlZ21lbnRzLCBpZCk7XG59XG5cbmZ1bmN0aW9uIHBhdGNoVG9FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCByZWZMaXN0KSB7XG4gIHZhciB0b0xlbmd0aCA9IHJlZkxpc3QudG9TZWdtZW50cy5sZW5ndGg7XG4gIHZhciBzZWdtZW50c0xlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHBhc3MgPSBldmVudEFyZ3NbZXZlbnRBcmdzLmxlbmd0aCAtIDFdO1xuICB2YXIgbW9kZWwgPSByZWZMaXN0Lm1vZGVsLnBhc3MocGFzcywgdHJ1ZSk7XG5cbiAgLy8gTXV0YXRpb24gb24gdGhlIGB0b2Agb2JqZWN0IGl0c2VsZlxuICBpZiAoc2VnbWVudHNMZW5ndGggPT09IHRvTGVuZ3RoKSB7XG4gICAgaWYgKHR5cGUgPT09ICdpbnNlcnQnKSB7XG4gICAgICB2YXIgaW5zZXJ0SW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgdmFsdWVzID0gZXZlbnRBcmdzWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHJlZkxpc3QuaW5kaWNlc0J5SXRlbSh2YWx1ZSk7XG4gICAgICAgIGlmICghaW5kaWNlcykgY29udGludWU7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzLmNvbmNhdChpbmRpY2VzW2pdKTtcbiAgICAgICAgICBtb2RlbC5fc2V0RGlmZihvdXRTZWdtZW50cywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICB2YXIgcmVtb3ZlSW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgdmFsdWVzID0gZXZlbnRBcmdzWzFdO1xuICAgICAgdmFyIGhvd01hbnkgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IHJlbW92ZUluZGV4LCBsZW4gPSByZW1vdmVJbmRleCArIGhvd01hbnk7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IHJlZkxpc3QuaW5kaWNlc0J5SXRlbSh2YWx1ZXNbaV0pO1xuICAgICAgICBpZiAoIWluZGljZXMpIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgaW5kaWNlc0xlbiA9IGluZGljZXMubGVuZ3RoOyBqIDwgaW5kaWNlc0xlbjsgaisrKSB7XG4gICAgICAgICAgdmFyIG91dFNlZ21lbnRzID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGljZXNbal0pO1xuICAgICAgICAgIG1vZGVsLl9zZXQob3V0U2VnbWVudHMsIHZvaWQgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gJ21vdmUnKSB7XG4gICAgICAvLyBNb3ZpbmcgaXRlbXMgaW4gdGhlIGB0b2Agb2JqZWN0IHNob3VsZCBoYXZlIG5vIGVmZmVjdCBvbiB0aGUgb3V0cHV0XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gTXV0YXRpb24gb24gb3IgYWJvdmUgdGhlIGB0b2Agb2JqZWN0XG4gIGlmIChzZWdtZW50c0xlbmd0aCA8PSB0b0xlbmd0aCkge1xuICAgIC8vIElmIHRoZSBlbnRpcmUgYHRvYCBvYmplY3QgaXMgdXBkYXRlZCwgd2UgbmVlZCB0byByZS1jcmVhdGUgdGhlXG4gICAgLy8gZW50aXJlIHJlZkxpc3Qgb3V0cHV0IGFuZCBhcHBseSB3aGF0IGlzIGRpZmZlcmVudC4gVGhpcyB3aWxsIGVuZCB1cFxuICAgIC8vIGRvaW5nIGFuIGFycmF5RGlmZlxuICAgIG1vZGVsLl9zZXREaWZmKHJlZkxpc3QuZnJvbVNlZ21lbnRzLCByZWZMaXN0LmdldCgpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBNdXRhdGlvbiB1bmRlcm5lYXRoIGEgY2hpbGQgb2YgdGhlIGB0b2Agb2JqZWN0LiBUaGUgaXRlbSB3aWxsIGFscmVhZHlcbiAgLy8gYmUgdXAgdG8gZGF0ZSwgc2luY2UgaXQgaXMgdW5kZXIgYW4gb2JqZWN0IHJlZmVyZW5jZS4gSnVzdCByZS1lbWl0XG4gIGlmIChzZWdtZW50c0xlbmd0aCA+IHRvTGVuZ3RoICsgMSkge1xuICAgIHZhciB2YWx1ZSA9IG1vZGVsLl9nZXQoc2VnbWVudHMuc2xpY2UoMCwgdG9MZW5ndGggKyAxKSk7XG4gICAgdmFyIGluZGljZXMgPSByZWZMaXN0LmluZGljZXNCeUl0ZW0odmFsdWUpO1xuICAgIGlmICghaW5kaWNlcykgcmV0dXJuO1xuICAgIHZhciByZW1haW5pbmcgPSBzZWdtZW50cy5zbGljZSh0b0xlbmd0aCArIDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZGV4ID0gaW5kaWNlc1tpXTtcbiAgICAgIHZhciBkZXJlZmVyZW5jZWQgPSByZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQoaW5kZXgsIHJlbWFpbmluZyk7XG4gICAgICBkZXJlZmVyZW5jZWQgPSBtb2RlbC5fZGVyZWZlcmVuY2UoZGVyZWZlcmVuY2VkLCBudWxsLCByZWZMaXN0KTtcbiAgICAgIGV2ZW50QXJncyA9IGV2ZW50QXJncy5zbGljZSgpO1xuICAgICAgZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXSA9IG1vZGVsLl9wYXNzO1xuICAgICAgbW9kZWwuZW1pdCh0eXBlLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgbXV0YXRpb24gb2YgYSBjaGlsZCBvZiB0aGUgYHRvYCBvYmplY3RcblxuICAvLyBJZiBjaGFuZ2luZyB0aGUgaXRlbSBpdHNlbGYsIGl0IHdpbGwgYWxzbyBoYXZlIHRvIGJlIHJlLXNldCBvbiB0aGVcbiAgLy8gYXJyYXkgY3JlYXRlZCBieSB0aGUgcmVmTGlzdFxuICBpZiAodHlwZSA9PT0gJ2NoYW5nZScgfHwgdHlwZSA9PT0gJ2xvYWQnIHx8IHR5cGUgPT09ICd1bmxvYWQnKSB7XG4gICAgdmFyIHZhbHVlLCBwcmV2aW91cztcbiAgICBpZiAodHlwZSA9PT0gJ2NoYW5nZScpIHtcbiAgICAgIHZhbHVlID0gZXZlbnRBcmdzWzBdO1xuICAgICAgcHJldmlvdXMgPSBldmVudEFyZ3NbMV07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbG9hZCcpIHtcbiAgICAgIHZhbHVlID0gZXZlbnRBcmdzWzBdO1xuICAgICAgcHJldmlvdXMgPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAndW5sb2FkJykge1xuICAgICAgdmFsdWUgPSB2b2lkIDA7XG4gICAgICBwcmV2aW91cyA9IGV2ZW50QXJnc1swXTtcbiAgICB9XG4gICAgdmFyIG5ld0luZGljZXMgPSByZWZMaXN0LmluZGljZXNCeUl0ZW0odmFsdWUpO1xuICAgIHZhciBvbGRJbmRpY2VzID0gcmVmTGlzdC5pbmRpY2VzQnlJdGVtKHByZXZpb3VzKTtcbiAgICBpZiAoIW5ld0luZGljZXMgJiYgIW9sZEluZGljZXMpIHJldHVybjtcbiAgICBpZiAob2xkSW5kaWNlcyAmJiAhZXF1aXZhbGVudEFycmF5cyhvbGRJbmRpY2VzLCBuZXdJbmRpY2VzKSkge1xuICAgICAgLy8gVGhlIGNoYW5nZWQgaXRlbSB1c2VkIHRvIHJlZmVyIHRvIHNvbWUgaW5kaWNlcywgYnV0IG5vIGxvbmdlciBkb2VzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZEluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG91dFNlZ21lbnRzID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KG9sZEluZGljZXNbaV0pO1xuICAgICAgICBtb2RlbC5fc2V0KG91dFNlZ21lbnRzLCB2b2lkIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3SW5kaWNlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRTZWdtZW50cyA9IHJlZkxpc3QuZnJvbVNlZ21lbnRzLmNvbmNhdChuZXdJbmRpY2VzW2ldKTtcbiAgICAgICAgbW9kZWwuX3NldChvdXRTZWdtZW50cywgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBtb2RlbC5fZ2V0KHNlZ21lbnRzLnNsaWNlKDAsIHRvTGVuZ3RoICsgMSkpO1xuICB2YXIgaW5kaWNlcyA9IHJlZkxpc3QuaW5kaWNlc0J5SXRlbSh2YWx1ZSk7XG4gIGlmICghaW5kaWNlcykgcmV0dXJuO1xuXG4gIC8vIFRoZSBzYW1lIGdvZXMgZm9yIHN0cmluZyBtdXRhdGlvbnMsIHNpbmNlIHN0cmluZ3MgYXJlIGltbXV0YWJsZVxuICBpZiAodHlwZSA9PT0gJ3N0cmluZ0luc2VydCcpIHtcbiAgICB2YXIgc3RyaW5nSW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIHZhbHVlID0gZXZlbnRBcmdzWzFdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG91dFNlZ21lbnRzID0gcmVmTGlzdC5mcm9tU2VnbWVudHMoaW5kaWNlc1tpXSk7XG4gICAgICBtb2RlbC5fc3RyaW5nSW5zZXJ0KG91dFNlZ21lbnRzLCBzdHJpbmdJbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdzdHJpbmdSZW1vdmUnKSB7XG4gICAgdmFyIHN0cmluZ0luZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgIHZhciBob3dNYW55ID0gZXZlbnRBcmdzWzFdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG91dFNlZ21lbnRzID0gcmVmTGlzdC5mcm9tU2VnbWVudHMoaW5kaWNlc1tpXSk7XG4gICAgICBtb2RlbC5fc3RyaW5nUmVtb3ZlKG91dFNlZ21lbnRzLCBzdHJpbmdJbmRleCwgaG93TWFueSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZSA9PT0gJ2luc2VydCcgfHwgdHlwZSA9PT0gJ3JlbW92ZScgfHwgdHlwZSA9PT0gJ21vdmUnKSB7XG4gICAgLy8gQXJyYXkgbXV0YXRpb25zIHdpbGwgaGF2ZSBhbHJlYWR5IGJlZW4gdXBkYXRlZCB2aWEgYW4gb2JqZWN0XG4gICAgLy8gcmVmZXJlbmNlLCBzbyBvbmx5IHJlLWVtaXRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXJlZmVyZW5jZWQgPSByZWZMaXN0LmZyb21TZWdtZW50cy5jb25jYXQoaW5kaWNlc1tpXSk7XG4gICAgICBkZXJlZmVyZW5jZWQgPSBtb2RlbC5fZGVyZWZlcmVuY2UoZGVyZWZlcmVuY2VkLCBudWxsLCByZWZMaXN0KTtcbiAgICAgIGV2ZW50QXJncyA9IGV2ZW50QXJncy5zbGljZSgpO1xuICAgICAgZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXSA9IG1vZGVsLl9wYXNzO1xuICAgICAgbW9kZWwuZW1pdCh0eXBlLCBkZXJlZmVyZW5jZWQsIGV2ZW50QXJncyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlcXVpdmFsZW50QXJyYXlzKGEsIGIpIHtcbiAgaWYgKCFhIHx8ICFiKSByZXR1cm4gZmFsc2U7XG4gIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcGF0Y2hJZHNFdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCByZWZMaXN0KSB7XG4gIHZhciBpZHNMZW5ndGggPSByZWZMaXN0Lmlkc1NlZ21lbnRzLmxlbmd0aDtcbiAgdmFyIHNlZ21lbnRzTGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoO1xuICB2YXIgcGFzcyA9IGV2ZW50QXJnc1tldmVudEFyZ3MubGVuZ3RoIC0gMV07XG4gIHZhciBtb2RlbCA9IHJlZkxpc3QubW9kZWwucGFzcyhwYXNzLCB0cnVlKTtcblxuICAvLyBBbiBhcnJheSBtdXRhdGlvbiBvZiB0aGUgaWRzIHNob3VsZCBiZSBtaXJyb3JlZCB3aXRoIGEgbGlrZSBjaGFuZ2UgaW5cbiAgLy8gdGhlIG91dHB1dCBhcnJheVxuICBpZiAoc2VnbWVudHNMZW5ndGggPT09IGlkc0xlbmd0aCkge1xuICAgIGlmICh0eXBlID09PSAnaW5zZXJ0Jykge1xuICAgICAgdmFyIGluZGV4ID0gZXZlbnRBcmdzWzBdO1xuICAgICAgdmFyIGluc2VydGVkID0gZXZlbnRBcmdzWzFdO1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnNlcnRlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsdWUgPSByZWZMaXN0Lml0ZW1CeUlkKGluc2VydGVkW2ldKTtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgbW9kZWwuX2luc2VydChyZWZMaXN0LmZyb21TZWdtZW50cywgaW5kZXgsIHZhbHVlcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1sxXS5sZW5ndGg7XG4gICAgICBtb2RlbC5fcmVtb3ZlKHJlZkxpc3QuZnJvbVNlZ21lbnRzLCBpbmRleCwgaG93TWFueSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdtb3ZlJykge1xuICAgICAgdmFyIGZyb20gPSBldmVudEFyZ3NbMF07XG4gICAgICB2YXIgdG8gPSBldmVudEFyZ3NbMV07XG4gICAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1syXTtcbiAgICAgIG1vZGVsLl9tb3ZlKHJlZkxpc3QuZnJvbVNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgLy8gTXV0YXRpb24gb24gdGhlIGBpZHNgIGxpc3QgaXRzZWxmXG4gIGlmIChzZWdtZW50c0xlbmd0aCA8PSBpZHNMZW5ndGgpIHtcbiAgICAvLyBJZiB0aGUgZW50aXJlIGBpZHNgIGFycmF5IGlzIHVwZGF0ZWQsIHdlIG5lZWQgdG8gcmUtY3JlYXRlIHRoZVxuICAgIC8vIGVudGlyZSByZWZMaXN0IG91dHB1dCBhbmQgYXBwbHkgd2hhdCBpcyBkaWZmZXJlbnQuIFRoaXMgd2lsbCBlbmQgdXBcbiAgICAvLyBkb2luZyBhbiBhcnJheURpZmZcbiAgICBtb2RlbC5fc2V0RGlmZihyZWZMaXN0LmZyb21TZWdtZW50cywgcmVmTGlzdC5nZXQoKSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBkaXJlY3QgbXV0YXRpb24gb2YgYSBjaGlsZCBpbiB0aGUgYGlkc2Agb2JqZWN0IG9yIG11dGF0aW9uXG4gIC8vIHVuZGVybmVhdGggYW4gaXRlbSBpbiB0aGUgYGlkc2AgbGlzdC4gVXBkYXRlIHRoZSBpdGVtIGZvciB0aGUgYXBwcm9wcmlhdGVcbiAgLy8gaWQgaWYgaXQgaGFzIGNoYW5nZWRcbiAgdmFyIGluZGV4ID0gc2VnbWVudHNbaWRzTGVuZ3RoXTtcbiAgdmFyIGlkID0gcmVmTGlzdC5pZEJ5SW5kZXgoaW5kZXgpO1xuICB2YXIgaXRlbSA9IHJlZkxpc3QuaXRlbUJ5SWQoaWQpO1xuICB2YXIgaXRlbVNlZ21lbnRzID0gcmVmTGlzdC5mcm9tU2VnbWVudHMuY29uY2F0KGluZGV4KTtcbiAgaWYgKG1vZGVsLl9nZXQoaXRlbVNlZ21lbnRzKSAhPT0gaXRlbSkge1xuICAgIG1vZGVsLl9zZXQoaXRlbVNlZ21lbnRzLCBpdGVtKTtcbiAgfVxufVxuXG5Nb2RlbC5wcm90b3R5cGUucmVmTGlzdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZnJvbSwgdG8sIGlkcywgb3B0aW9ucztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB0byA9IGFyZ3VtZW50c1swXTtcbiAgICBpZHMgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmICh0aGlzLmlzUGF0aChhcmd1bWVudHNbMl0pKSB7XG4gICAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgICAgdG8gPSBhcmd1bWVudHNbMV07XG4gICAgICBpZHMgPSBhcmd1bWVudHNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWRzID0gYXJndW1lbnRzWzFdO1xuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1syXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9IGFyZ3VtZW50c1swXTtcbiAgICB0byA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZHMgPSBhcmd1bWVudHNbMl07XG4gICAgb3B0aW9ucyA9IGFyZ3VtZW50c1szXTtcbiAgfVxuICB2YXIgZnJvbVBhdGggPSB0aGlzLnBhdGgoZnJvbSk7XG4gIGlmIChBcnJheS5pc0FycmF5KHRvKSkge1xuICAgIHZhciB0b1BhdGggPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b1BhdGgucHVzaCh0aGlzLnBhdGgodG9baV0pKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRvUGF0aCA9IHRoaXMucGF0aCh0byk7XG4gIH1cbiAgdmFyIGlkc1BhdGggPSB0aGlzLnBhdGgoaWRzKTtcbiAgdmFyIHJlZkxpc3QgPSB0aGlzLl9yZWZMaXN0cy5hZGQoZnJvbVBhdGgsIHRvUGF0aCwgaWRzUGF0aCwgb3B0aW9ucyk7XG4gIHRoaXMucGFzcyh7JHJlZkxpc3Q6IHJlZkxpc3R9KS5fc2V0RGlmZihyZWZMaXN0LmZyb21TZWdtZW50cywgcmVmTGlzdC5nZXQoKSk7XG4gIHJldHVybiB0aGlzLnNjb3BlKGZyb21QYXRoKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5yZW1vdmVSZWZMaXN0ID0gZnVuY3Rpb24oZnJvbSkge1xuICB2YXIgZnJvbVBhdGggPSB0aGlzLnBhdGgoZnJvbSk7XG4gIHZhciByZWZMaXN0ID0gdGhpcy5fcmVmTGlzdHMucmVtb3ZlKGZyb21QYXRoKTtcbiAgaWYgKHJlZkxpc3QpIHRoaXMuX2RlbChyZWZMaXN0LmZyb21TZWdtZW50cyk7XG59O1xuXG5mdW5jdGlvbiBSZWZMaXN0KG1vZGVsLCBmcm9tLCB0bywgaWRzLCBvcHRpb25zKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbCAmJiBtb2RlbC5wYXNzKHskcmVmTGlzdDogdGhpc30pO1xuICB0aGlzLmZyb20gPSBmcm9tO1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMuaWRzID0gaWRzO1xuICB0aGlzLmZyb21TZWdtZW50cyA9IGZyb20gJiYgZnJvbS5zcGxpdCgnLicpO1xuICB0aGlzLnRvU2VnbWVudHMgPSB0byAmJiB0by5zcGxpdCgnLicpO1xuICB0aGlzLmlkc1NlZ21lbnRzID0gaWRzICYmIGlkcy5zcGxpdCgnLicpO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmRlbGV0ZVJlbW92ZWQgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVsZXRlUmVtb3ZlZDtcbn1cblxuLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGF0IHRoZSBpZHMgYXJyYXkgaXMgYSBmbGF0IGxpc3Qgb2Zcbi8vIGtleXMgb24gdGhlIHRvIG9iamVjdC4gSWRlYWxseSwgdGhpcyBtYXBwaW5nIGNvdWxkIGJlIGN1c3RvbWl6ZWQgdmlhXG4vLyBpbmhlcml0aW5nIGZyb20gUmVmTGlzdCBhbmQgb3ZlcnJpZGluZyB0aGVzZSBtZXRob2RzIHdpdGhvdXQgaGF2aW5nIHRvXG4vLyBtb2RpZnkgdGhlIGFib3ZlIGV2ZW50IGhhbmRsaW5nIGNvZGUuXG4vLyBcbi8vIEluIHRoZSBkZWZhdWx0IHJlZkxpc3QgaW1wbGVtZW50YXRpb24sIGBrZXlgIGFuZCBgaWRgIGFyZSBlcXVhbC5cbi8vIFxuLy8gVGVybXMgaW4gdGhlIGJlbG93IG1ldGhvZHM6XG4vLyAgIGBpdGVtYCAgLSBPYmplY3Qgb24gdGhlIGB0b2AgcGF0aCwgd2hpY2ggZ2V0cyBtaXJyb3JlZCBvbiB0aGUgYGZyb21gIHBhdGhcbi8vICAgYGtleWAgICAtIFRoZSBwcm9wZXJ0eSB1bmRlciBgdG9gIGF0IHdoaWNoIGFuIGl0ZW0gaXMgbG9jYXRlZFxuLy8gICBgaWRgICAgIC0gU3RyaW5nIG9yIG9iamVjdCBpbiB0aGUgYXJyYXkgYXQgdGhlIGBpZHNgIHBhdGhcbi8vICAgYGluZGV4YCAtIFRoZSBpbmRleCBvZiBhbiBpZCwgd2hpY2ggY29ycmVzcG9uZHMgdG8gYW4gaW5kZXggb24gYGZyb21gXG5SZWZMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlkcyA9IHRoaXMubW9kZWwuX2dldCh0aGlzLmlkc1NlZ21lbnRzKTtcbiAgaWYgKCFpZHMpIHJldHVybiBbXTtcbiAgdmFyIGl0ZW1zID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMudG9TZWdtZW50cyk7XG4gIHZhciBvdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaWRzW2ldO1xuICAgIG91dC5wdXNoKGl0ZW1zICYmIGl0ZW1zW2tleV0pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuZGVyZWZlcmVuY2UgPSBmdW5jdGlvbihzZWdtZW50cywgaSkge1xuICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UoaSArIDEpO1xuICB2YXIga2V5ID0gdGhpcy5pZEJ5SW5kZXgocmVtYWluaW5nWzBdKTtcbiAgaWYgKGtleSA9PSBudWxsKSByZXR1cm4gW107XG4gIHJlbWFpbmluZ1swXSA9IGtleTtcbiAgcmV0dXJuIHRoaXMudG9TZWdtZW50cy5jb25jYXQocmVtYWluaW5nKTtcbn07XG5SZWZMaXN0LnByb3RvdHlwZS50b1NlZ21lbnRzQnlJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB2YXIga2V5ID0gdGhpcy5pZEJ5SXRlbShpdGVtKTtcbiAgaWYgKGtleSA9PT0gdm9pZCAwKSByZXR1cm47XG4gIHJldHVybiB0aGlzLnRvU2VnbWVudHMuY29uY2F0KGtleSk7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuaWRCeUl0ZW0gPSBmdW5jdGlvbihpdGVtKSB7XG4gIGlmIChpdGVtICYmIGl0ZW0uaWQpIHJldHVybiBpdGVtLmlkO1xuICB2YXIgaXRlbXMgPSB0aGlzLm1vZGVsLl9nZXQodGhpcy50b1NlZ21lbnRzKTtcbiAgZm9yICh2YXIga2V5IGluIGl0ZW1zKSB7XG4gICAgaWYgKGl0ZW0gPT09IGl0ZW1zW2tleV0pIHJldHVybiBrZXk7XG4gIH1cbn07XG5SZWZMaXN0LnByb3RvdHlwZS5pbmRpY2VzQnlJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB2YXIgaWQgPSB0aGlzLmlkQnlJdGVtKGl0ZW0pO1xuICB2YXIgaWRzID0gdGhpcy5tb2RlbC5fZ2V0KHRoaXMuaWRzU2VnbWVudHMpO1xuICBpZiAoIWlkcykgcmV0dXJuO1xuICB2YXIgaW5kaWNlcztcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaW5kZXggPSBpZHMuaW5kZXhPZihpZCwgaW5kZXggKyAxKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSBicmVhaztcbiAgICBpZiAoaW5kaWNlcykge1xuICAgICAgaW5kaWNlcy5wdXNoKGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNlcyA9IFtpbmRleF07XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRpY2VzO1xufTtcblJlZkxpc3QucHJvdG90eXBlLml0ZW1CeUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgcmV0dXJuIHRoaXMubW9kZWwuX2dldCh0aGlzLnRvU2VnbWVudHMuY29uY2F0KGlkKSk7XG59O1xuUmVmTGlzdC5wcm90b3R5cGUuaWRCeUluZGV4ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMubW9kZWwuX2dldCh0aGlzLmlkc1NlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xufTtcblJlZkxpc3QucHJvdG90eXBlLm9uTXV0YXRpb24gPSBmdW5jdGlvbih0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzKSB7XG4gIGlmICh1dGlsLm1heUltcGFjdCh0aGlzLnRvU2VnbWVudHMsIHNlZ21lbnRzKSkge1xuICAgIHBhdGNoVG9FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCB0aGlzKTtcbiAgfSBlbHNlIGlmICh1dGlsLm1heUltcGFjdCh0aGlzLmlkc1NlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICBwYXRjaElkc0V2ZW50KHR5cGUsIHNlZ21lbnRzLCBldmVudEFyZ3MsIHRoaXMpO1xuICB9IGVsc2UgaWYgKHV0aWwubWF5SW1wYWN0KHRoaXMuZnJvbVNlZ21lbnRzLCBzZWdtZW50cykpIHtcbiAgICBwYXRjaEZyb21FdmVudCh0eXBlLCBzZWdtZW50cywgZXZlbnRBcmdzLCB0aGlzKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gRnJvbU1hcCgpIHt9XG5cbmZ1bmN0aW9uIFJlZkxpc3RzKG1vZGVsKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbDtcbiAgdGhpcy5mcm9tTWFwID0gbmV3IEZyb21NYXA7XG59XG5cblJlZkxpc3RzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihmcm9tLCB0bywgaWRzLCBvcHRpb25zKSB7XG4gIHZhciByZWZMaXN0ID0gbmV3IFJlZkxpc3QodGhpcy5tb2RlbCwgZnJvbSwgdG8sIGlkcywgb3B0aW9ucyk7XG4gIHRoaXMuZnJvbU1hcFtmcm9tXSA9IHJlZkxpc3Q7XG4gIHJldHVybiByZWZMaXN0O1xufTtcblxuUmVmTGlzdHMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIHJlZkxpc3QgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gIGRlbGV0ZSB0aGlzLmZyb21NYXBbZnJvbV07XG4gIHJldHVybiByZWZMaXN0O1xufTtcblxuUmVmTGlzdHMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIHJlZkxpc3QgPSB0aGlzLmZyb21NYXBbZnJvbV07XG4gICAgb3V0LnB1c2goW3JlZkxpc3QuZnJvbSwgcmVmTGlzdC50bywgcmVmTGlzdC5pZHMsIHJlZkxpc3Qub3B0aW9uc10pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG5cbk1vZGVsLklOSVRTLnB1c2goZnVuY3Rpb24obW9kZWwpIHtcbiAgbW9kZWwuX3JlZnMgPSBuZXcgUmVmcztcbiAgYWRkQXJyYXlMaXN0ZW5lcnMobW9kZWwpO1xuICBmb3IgKHZhciB0eXBlIGluIE1vZGVsLk1VVEFUT1JfRVZFTlRTKSB7XG4gICAgYWRkTGlzdGVuZXIobW9kZWwsIHR5cGUpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gYWRkQXJyYXlMaXN0ZW5lcnMobW9kZWwpIHtcbiAgbW9kZWwub24oJ2luc2VydCcsIGZ1bmN0aW9uIHJlZkluc2VydExpc3RlbmVyKHNlZ21lbnRzLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgaW5kZXggPSBldmVudEFyZ3NbMF07XG4gICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMV0ubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIHBhdGNoSW5zZXJ0KHJlZkluZGV4KSB7XG4gICAgICByZXR1cm4gKGluZGV4IDw9IHJlZkluZGV4KSA/IHJlZkluZGV4ICsgaG93TWFueSA6IHJlZkluZGV4O1xuICAgIH1cbiAgICBvbkluZGV4Q2hhbmdlKHNlZ21lbnRzLCBwYXRjaEluc2VydCk7XG4gIH0pO1xuICBtb2RlbC5vbigncmVtb3ZlJywgZnVuY3Rpb24gcmVmUmVtb3ZlTGlzdGVuZXIoc2VnbWVudHMsIGV2ZW50QXJncykge1xuICAgIHZhciBpbmRleCA9IGV2ZW50QXJnc1swXTtcbiAgICB2YXIgaG93TWFueSA9IGV2ZW50QXJnc1sxXS5sZW5ndGg7XG4gICAgZnVuY3Rpb24gcGF0Y2hSZW1vdmUocmVmSW5kZXgpIHtcbiAgICAgIHJldHVybiAoaW5kZXggPD0gcmVmSW5kZXgpID8gcmVmSW5kZXggLSBob3dNYW55IDogcmVmSW5kZXg7XG4gICAgfVxuICAgIG9uSW5kZXhDaGFuZ2Uoc2VnbWVudHMsIHBhdGNoUmVtb3ZlKTtcbiAgfSk7XG4gIG1vZGVsLm9uKCdtb3ZlJywgZnVuY3Rpb24gcmVmTW92ZUxpc3RlbmVyKHNlZ21lbnRzLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgZnJvbSA9IGV2ZW50QXJnc1swXTtcbiAgICB2YXIgdG8gPSBldmVudEFyZ3NbMV07XG4gICAgdmFyIGhvd01hbnkgPSBldmVudEFyZ3NbMl07XG4gICAgZnVuY3Rpb24gcGF0Y2hNb3ZlKHJlZkluZGV4KSB7XG4gICAgICAvLyBJZiB0aGUgaW5kZXggd2FzIG1vdmVkIGl0c2VsZlxuICAgICAgaWYgKGZyb20gPD0gcmVmSW5kZXggJiYgcmVmSW5kZXggPCBmcm9tICsgaG93TWFueSkge1xuICAgICAgICByZXR1cm4gcmVmSW5kZXggKyB0byAtIGZyb207XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgcGFydCBvZiBhIG1vdmVcbiAgICAgIGlmIChmcm9tIDw9IHJlZkluZGV4KSByZWZJbmRleCAtPSBob3dNYW55O1xuICAgICAgLy8gSW5zZXJ0IHBhcnQgb2YgYSBtb3ZlXG4gICAgICBpZiAodG8gPD0gcmVmSW5kZXgpIHJlZkluZGV4ICs9IGhvd01hbnk7XG4gICAgICByZXR1cm4gcmVmSW5kZXg7XG4gICAgfVxuICAgIG9uSW5kZXhDaGFuZ2Uoc2VnbWVudHMsIHBhdGNoTW92ZSk7XG4gIH0pO1xuICBmdW5jdGlvbiBvbkluZGV4Q2hhbmdlKHNlZ21lbnRzLCBwYXRjaCkge1xuICAgIHZhciBmcm9tTWFwID0gbW9kZWwuX3JlZnMuZnJvbU1hcDtcbiAgICBmb3IgKHZhciBmcm9tIGluIGZyb21NYXApIHtcbiAgICAgIHZhciByZWYgPSBmcm9tTWFwW2Zyb21dO1xuICAgICAgaWYgKCEocmVmLnVwZGF0ZUluZGljZXMgJiZcbiAgICAgICAgdXRpbC5jb250YWlucyhzZWdtZW50cywgcmVmLnRvU2VnbWVudHMpICYmXG4gICAgICAgIHJlZi50b1NlZ21lbnRzLmxlbmd0aCA+IHNlZ21lbnRzLmxlbmd0aCkpIGNvbnRpbnVlO1xuICAgICAgdmFyIGluZGV4ID0gK3JlZi50b1NlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aF07XG4gICAgICB2YXIgcGF0Y2hlZCA9IHBhdGNoKGluZGV4KTtcbiAgICAgIGlmIChpbmRleCA9PT0gcGF0Y2hlZCkgY29udGludWU7XG4gICAgICBtb2RlbC5fcmVmcy5yZW1vdmUoZnJvbSk7XG4gICAgICByZWYudG9TZWdtZW50c1tzZWdtZW50cy5sZW5ndGhdID0gJycgKyBwYXRjaGVkO1xuICAgICAgcmVmLnRvID0gcmVmLnRvU2VnbWVudHMuam9pbignLicpO1xuICAgICAgbW9kZWwuX3JlZnMuX2FkZChyZWYpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihtb2RlbCwgdHlwZSkge1xuICBtb2RlbC5vbih0eXBlLCByZWZMaXN0ZW5lcik7XG4gIGZ1bmN0aW9uIHJlZkxpc3RlbmVyKHNlZ21lbnRzLCBldmVudEFyZ3MpIHtcbiAgICAvLyBGaW5kIGNhc2VzIHdoZXJlIGFuIGV2ZW50IGlzIGVtaXR0ZWQgb24gYSBwYXRoIHdoZXJlIGEgcmVmZXJlbmNlXG4gICAgLy8gaXMgcG9pbnRpbmcuIEFsbCBvcmlnaW5hbCBtdXRhdGlvbnMgaGFwcGVuIG9uIHRoZSBmdWxseSBkZXJlZmVyZW5jZWRcbiAgICAvLyBsb2NhdGlvbiwgc28gdGhpcyBkZXRlY3Rpb24gb25seSBuZWVkcyB0byBoYXBwZW4gaW4gb25lIGRpcmVjdGlvblxuICAgIHZhciB0b01hcCA9IG1vZGVsLl9yZWZzLnRvTWFwO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHN1YnBhdGggPSAoc3VicGF0aCkgPyBzdWJwYXRoICsgJy4nICsgc2VnbWVudHNbaV0gOiBzZWdtZW50c1tpXTtcbiAgICAgIC8vIElmIGEgcmVmIGlzIGZvdW5kIHBvaW50aW5nIHRvIGEgbWF0Y2hpbmcgc3VicGF0aCwgcmUtZW1pdCBvbiB0aGVcbiAgICAgIC8vIHBsYWNlIHdoZXJlIHRoZSByZWZlcmVuY2UgaXMgY29taW5nIGZyb20gYXMgaWYgdGhlIG11dGF0aW9uIGFsc29cbiAgICAgIC8vIG9jY3VyZWQgYXQgdGhhdCBwYXRoXG4gICAgICB2YXIgcmVmcyA9IHRvTWFwW3N1YnBhdGhdO1xuICAgICAgaWYgKCFyZWZzKSBjb250aW51ZTtcbiAgICAgIHZhciByZW1haW5pbmcgPSBzZWdtZW50cy5zbGljZShpICsgMSk7XG4gICAgICBmb3IgKHZhciByZWZJbmRleCA9IDAsIG51bVJlZnMgPSByZWZzLmxlbmd0aDsgcmVmSW5kZXggPCBudW1SZWZzOyByZWZJbmRleCsrKSB7XG4gICAgICAgIHZhciByZWYgPSByZWZzW3JlZkluZGV4XTtcbiAgICAgICAgdmFyIGRlcmVmZXJlbmNlZCA9IHJlZi5mcm9tU2VnbWVudHMuY29uY2F0KHJlbWFpbmluZyk7XG4gICAgICAgIG1vZGVsLmVtaXQodHlwZSwgZGVyZWZlcmVuY2VkLCBldmVudEFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiBhIHJlZiBwb2ludHMgdG8gYSBjaGlsZCBvZiBhIG1hdGNoaW5nIHN1YnBhdGgsIGdldCB0aGUgdmFsdWUgaW5cbiAgICAvLyBjYXNlIGl0IGhhcyBjaGFuZ2VkIGFuZCByZS1lbWl0IG9uIHRoZSBwbGFjZSB3aGVyZSB0aGUgcmVmZXJlbmNlXG4gICAgLy8gaXMgY29taW5nIGZyb21cbiAgICB2YXIgcGFyZW50VG9NYXAgPSBtb2RlbC5fcmVmcy5wYXJlbnRUb01hcDtcbiAgICB2YXIgcmVmcyA9IHBhcmVudFRvTWFwW3N1YnBhdGhdO1xuICAgIGlmICghcmVmcykgcmV0dXJuO1xuICAgIHZhciBwYXNzID0gZXZlbnRBcmdzW2V2ZW50QXJncy5sZW5ndGggLSAxXTtcbiAgICBmb3IgKHZhciByZWZJbmRleCA9IDAsIG51bVJlZnMgPSByZWZzLmxlbmd0aDsgcmVmSW5kZXggPCBudW1SZWZzOyByZWZJbmRleCsrKSB7XG4gICAgICB2YXIgcmVmID0gcmVmc1tyZWZJbmRleF07XG4gICAgICB2YXIgdmFsdWUgPSBtb2RlbC5fZ2V0KHJlZi5mcm9tU2VnbWVudHMpO1xuICAgICAgLy8gVE9ETzogTm90IHN1cmUgaG93IHRvIGdldCB0aGUgcHJldmlvdXMgdmFsdWUgaGVyZS4gSnVzdCBwYXNzaW5nXG4gICAgICAvLyB1bmRlZmluZWQgZm9yIG5vd1xuICAgICAgdmFyIHByZXZpb3VzID0gdm9pZCAwO1xuICAgICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgcmVmLmZyb21TZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgcGFzc10pO1xuICAgIH1cbiAgfVxufVxuXG5Nb2RlbC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmcm9tLCB0bywgb3B0aW9ucztcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB0byA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKHRoaXMuaXNQYXRoKGFyZ3VtZW50c1sxXSkpIHtcbiAgICAgIGZyb20gPSBhcmd1bWVudHNbMF07XG4gICAgICB0byA9IGFyZ3VtZW50c1sxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG8gPSBhcmd1bWVudHNbMF07XG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmcm9tID0gYXJndW1lbnRzWzBdO1xuICAgIHRvID0gYXJndW1lbnRzWzFdO1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG4gIH1cbiAgdmFyIGZyb21QYXRoID0gdGhpcy5wYXRoKGZyb20pO1xuICB2YXIgdG9QYXRoID0gdGhpcy5wYXRoKHRvKTtcbiAgdmFyIGZyb21TZWdtZW50cyA9IGZyb21QYXRoLnNwbGl0KCcuJyk7XG4gIGlmIChmcm9tU2VnbWVudHMubGVuZ3RoIDwgMikge1xuICAgIHZhciBtZXNzYWdlID0gJ3JlZiBtdXN0IGJlIHBlcmZvcm1lZCB1bmRlciBhIGNvbGxlY3Rpb24gJyArXG4gICAgICAnYW5kIGRvY3VtZW50IGlkLiBJbnZhbGlkIHBhdGg6ICcgKyBmcm9tUGF0aDtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1lc3NhZ2UpKTtcbiAgfVxuICB2YXIgcHJldmlvdXMgPSB0aGlzLl9nZXQoZnJvbVNlZ21lbnRzKTtcbiAgdGhpcy5fcmVmcy5hZGQoZnJvbVBhdGgsIHRvUGF0aCwgb3B0aW9ucyk7XG4gIHZhciB2YWx1ZSA9IHRoaXMuX2dldChmcm9tU2VnbWVudHMpO1xuICB0aGlzLmVtaXQoJ2NoYW5nZScsIGZyb21TZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgdGhpcy5fcGFzc10pO1xuICByZXR1cm4gdGhpcy5zY29wZShmcm9tUGF0aCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUucmVtb3ZlUmVmID0gZnVuY3Rpb24oZnJvbSkge1xuICB2YXIgZnJvbVBhdGggPSB0aGlzLnBhdGgoZnJvbSk7XG4gIHZhciBmcm9tU2VnbWVudHMgPSBmcm9tUGF0aC5zcGxpdCgnLicpO1xuICB2YXIgcHJldmlvdXMgPSB0aGlzLl9nZXQoZnJvbVNlZ21lbnRzKTtcbiAgdGhpcy5fcmVmcy5yZW1vdmUoZnJvbVBhdGgpO1xuICB2YXIgdmFsdWUgPSB0aGlzLl9nZXQoZnJvbVNlZ21lbnRzKTtcbiAgdGhpcy5lbWl0KCdjaGFuZ2UnLCBmcm9tU2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIHRoaXMuX3Bhc3NdKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5yZW1vdmVBbGxSZWZzID0gZnVuY3Rpb24oc3VicGF0aCkge1xuICB2YXIgc2VnbWVudHMgPSB0aGlzLl9zcGxpdFBhdGgoc3VicGF0aCk7XG4gIHZhciByZWZzID0gdGhpcy5fcmVmcy5mcm9tTWFwO1xuICB2YXIgcmVmTGlzdHMgPSB0aGlzLl9yZWZMaXN0cy5mcm9tTWFwO1xuICBmb3IgKHZhciBmcm9tIGluIHJlZnMpIHtcbiAgICBpZiAodXRpbC5jb250YWlucyhzZWdtZW50cywgcmVmc1tmcm9tXS5mcm9tU2VnbWVudHMpKSB7XG4gICAgICB0aGlzLnJlbW92ZVJlZihmcm9tKTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgZnJvbSBpbiByZWZMaXN0cykge1xuICAgIGlmICh1dGlsLmNvbnRhaW5zKHNlZ21lbnRzLCByZWZMaXN0c1tmcm9tXS5mcm9tU2VnbWVudHMpKSB7XG4gICAgICB0aGlzLnJlbW92ZVJlZkxpc3QoZnJvbSk7XG4gICAgfVxuICB9XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuZGVyZWZlcmVuY2UgPSBmdW5jdGlvbihzdWJwYXRoKSB7XG4gIHZhciBzZWdtZW50cyA9IHRoaXMuX3NwbGl0UGF0aChzdWJwYXRoKTtcbiAgcmV0dXJuIHRoaXMuX2RlcmVmZXJlbmNlKHNlZ21lbnRzKS5qb2luKCcuJyk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuX2RlcmVmZXJlbmNlID0gZnVuY3Rpb24oc2VnbWVudHMsIGZvckFycmF5TXV0YXRvciwgaWdub3JlKSB7XG4gIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBzZWdtZW50cztcbiAgdmFyIHJlZnMgPSB0aGlzLl9yZWZzLmZyb21NYXA7XG4gIHZhciByZWZMaXN0cyA9IHRoaXMuX3JlZkxpc3RzLmZyb21NYXA7XG4gIGRvIHtcbiAgICB2YXIgc3VicGF0aCA9ICcnO1xuICAgIHZhciBkb0FnYWluID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBzdWJwYXRoID0gKHN1YnBhdGgpID8gc3VicGF0aCArICcuJyArIHNlZ21lbnRzW2ldIDogc2VnbWVudHNbaV07XG5cbiAgICAgIHZhciByZWYgPSByZWZzW3N1YnBhdGhdO1xuICAgICAgaWYgKHJlZikge1xuICAgICAgICB2YXIgcmVtYWluaW5nID0gc2VnbWVudHMuc2xpY2UoaSArIDEpO1xuICAgICAgICBzZWdtZW50cyA9IHJlZi50b1NlZ21lbnRzLmNvbmNhdChyZW1haW5pbmcpO1xuICAgICAgICBkb0FnYWluID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWZMaXN0ID0gcmVmTGlzdHNbc3VicGF0aF07XG4gICAgICBpZiAocmVmTGlzdCAmJiByZWZMaXN0ICE9PSBpZ25vcmUpIHtcbiAgICAgICAgdmFyIGJlbG93RGVzY2VuZGFudCA9IGkgKyAyIDwgbGVuO1xuICAgICAgICB2YXIgYmVsb3dDaGlsZCA9IGkgKyAxIDwgbGVuO1xuICAgICAgICBpZiAoIShiZWxvd0Rlc2NlbmRhbnQgfHwgZm9yQXJyYXlNdXRhdG9yICYmIGJlbG93Q2hpbGQpKSBjb250aW51ZTtcbiAgICAgICAgc2VnbWVudHMgPSByZWZMaXN0LmRlcmVmZXJlbmNlKHNlZ21lbnRzLCBpKTtcbiAgICAgICAgZG9BZ2FpbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoZG9BZ2Fpbik7XG4gIC8vIElmIGEgZGVyZWZlcmVuY2UgZmFpbHMsIHJldHVybiBhIHBhdGggdGhhdCB3aWxsIHJlc3VsdCBpbiBhIG51bGwgdmFsdWVcbiAgLy8gaW5zdGVhZCBvZiBhIHBhdGggdG8gZXZlcnl0aGluZyBpbiB0aGUgbW9kZWxcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFsnJG51bGwnXTtcbiAgcmV0dXJuIHNlZ21lbnRzO1xufTtcblxuZnVuY3Rpb24gUmVmKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gIHRoaXMuZnJvbSA9IGZyb207XG4gIHRoaXMudG8gPSB0bztcbiAgdGhpcy5mcm9tU2VnbWVudHMgPSBmcm9tLnNwbGl0KCcuJyk7XG4gIHRoaXMudG9TZWdtZW50cyA9IHRvLnNwbGl0KCcuJyk7XG4gIHRoaXMucGFyZW50VG9zID0gW107XG4gIGZvciAodmFyIGkgPSAxLCBsZW4gPSB0aGlzLnRvU2VnbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcGFyZW50VG8gPSB0aGlzLnRvU2VnbWVudHMuc2xpY2UoMCwgaSkuam9pbignLicpO1xuICAgIHRoaXMucGFyZW50VG9zLnB1c2gocGFyZW50VG8pO1xuICB9XG4gIHRoaXMudXBkYXRlSW5kaWNlcyA9IG9wdGlvbnMgJiYgb3B0aW9ucy51cGRhdGVJbmRpY2VzO1xufVxuZnVuY3Rpb24gRnJvbU1hcCgpIHt9XG5mdW5jdGlvbiBUb01hcCgpIHt9XG5cbmZ1bmN0aW9uIFJlZnMoKSB7XG4gIHRoaXMuZnJvbU1hcCA9IG5ldyBGcm9tTWFwO1xuICB0aGlzLnRvTWFwID0gbmV3IFRvTWFwO1xuICB0aGlzLnBhcmVudFRvTWFwID0gbmV3IFRvTWFwO1xufVxuXG5SZWZzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuICB0aGlzLnJlbW92ZShmcm9tKTtcbiAgdmFyIHJlZiA9IG5ldyBSZWYoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcy5fYWRkKHJlZik7XG59O1xuXG5SZWZzLnByb3RvdHlwZS5fYWRkID0gZnVuY3Rpb24ocmVmKSB7XG4gIHRoaXMuZnJvbU1hcFtyZWYuZnJvbV0gPSByZWY7XG4gIGxpc3RNYXBBZGQodGhpcy50b01hcCwgcmVmLnRvLCByZWYpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcmVmLnBhcmVudFRvcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxpc3RNYXBBZGQodGhpcy5wYXJlbnRUb01hcCwgcmVmLnBhcmVudFRvc1tpXSwgcmVmKTtcbiAgfVxuICByZXR1cm4gcmVmO1xufTtcblxuUmVmcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oZnJvbSkge1xuICB2YXIgcmVmID0gdGhpcy5mcm9tTWFwW2Zyb21dO1xuICBpZiAoIXJlZikgcmV0dXJuO1xuICBkZWxldGUgdGhpcy5mcm9tTWFwW2Zyb21dO1xuICBsaXN0TWFwUmVtb3ZlKHRoaXMudG9NYXAsIHJlZi50bywgcmVmKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJlZi5wYXJlbnRUb3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsaXN0TWFwUmVtb3ZlKHRoaXMucGFyZW50VG9NYXAsIHJlZi5wYXJlbnRUb3NbaV0sIHJlZik7XG4gIH1cbiAgcmV0dXJuIHJlZjtcbn07XG5cblJlZnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW107XG4gIGZvciAodmFyIGZyb20gaW4gdGhpcy5mcm9tTWFwKSB7XG4gICAgdmFyIHJlZiA9IHRoaXMuZnJvbU1hcFtmcm9tXTtcbiAgICBvdXQucHVzaChbcmVmLmZyb20sIHJlZi50b10pO1xuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG5mdW5jdGlvbiBsaXN0TWFwQWRkKG1hcCwgbmFtZSwgaXRlbSkge1xuICBtYXBbbmFtZV0gfHwgKG1hcFtuYW1lXSA9IFtdKTtcbiAgbWFwW25hbWVdLnB1c2goaXRlbSk7XG59XG5cbmZ1bmN0aW9uIGxpc3RNYXBSZW1vdmUobWFwLCBuYW1lLCBpdGVtKSB7XG4gIHZhciBpdGVtcyA9IG1hcFtuYW1lXTtcbiAgaWYgKCFpdGVtcykgcmV0dXJuO1xuICB2YXIgaW5kZXggPSBpdGVtcy5pbmRleE9mKGl0ZW0pO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm47XG4gIGl0ZW1zLnNwbGljZShpbmRleCwgMSk7XG4gIGlmICghaXRlbXMubGVuZ3RoKSBkZWxldGUgbWFwW25hbWVdO1xufVxuIiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBPYmplY3Rfa2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gT2JqZWN0LmtleXNcbiAgICA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIGtleXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgIH1cbjtcblxudmFyIGRlZXBFcXVhbCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gZW5mb3JjZSBPYmplY3QuaXMgKzAgIT09IC0wXG4gIGlmIChhY3R1YWwgPT09IDAgJiYgZXhwZWN0ZWQgPT09IDApIHtcbiAgICByZXR1cm4gYXJlWmVyb3NFcXVhbChhY3R1YWwsIGV4cGVjdGVkKTtcblxuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgfSBlbHNlIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgfSBlbHNlIGlmIChpc051bWJlck5hTihhY3R1YWwpKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyTmFOKGV4cGVjdGVkKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyTmFOKHZhbHVlKSB7XG4gIC8vIE5hTiA9PT0gTmFOIC0+IGZhbHNlXG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhcmVaZXJvc0VxdWFsKHplcm9BLCB6ZXJvQikge1xuICAvLyAoMSAvICswfDApIC0+IEluZmluaXR5LCBidXQgKDEgLyAtMCkgLT4gLUluZmluaXR5IGFuZCAoSW5maW5pdHkgIT09IC1JbmZpbml0eSlcbiAgcmV0dXJuICgxIC8gemVyb0EpID09PSAoMSAvIHplcm9CKTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYikge1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYik7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIga2EgPSBPYmplY3Rfa2V5cyhhKSxcbiAgICAgICAga2IgPSBPYmplY3Rfa2V5cyhiKSxcbiAgICAgICAga2V5LCBpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG4iLCIoZnVuY3Rpb24oX19kaXJuYW1lKXt2YXIgdXVpZCA9IHJlcXVpcmUoJ25vZGUtdXVpZCcpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbk1vZGVsLklOSVRTID0gW107XG5cbm1vZHVsZS5leHBvcnRzID0gTW9kZWw7XG5cbmZ1bmN0aW9uIE1vZGVsKHN0b3JlLCBvcHRpb25zKSB7XG4gIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgdmFyIGluaXRzID0gTW9kZWwuSU5JVFM7XG4gIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdHMubGVuZ3RoOyBpKyspIHtcbiAgICBpbml0c1tpXSh0aGlzLCBvcHRpb25zKTtcbiAgfVxufVxuXG5Nb2RlbC5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHV1aWQudjQoKTtcbn07XG5cbi8vIEV4dGVuZCBtb2RlbCBvbiBib3RoIHNlcnZlciBhbmQgY2xpZW50XG5yZXF1aXJlKCcuL2V2ZW50cycpO1xucmVxdWlyZSgnLi9wYXRocycpO1xucmVxdWlyZSgnLi9jb25uZWN0aW9uJyk7XG5yZXF1aXJlKCcuL2NvbGxlY3Rpb25zJyk7XG5yZXF1aXJlKCcuL211dGF0b3JzJyk7XG5yZXF1aXJlKCcuL3NldERpZmYnKTtcbnJlcXVpcmUoJy4vc3Vic2NyaXB0aW9ucycpO1xucmVxdWlyZSgnLi9RdWVyeScpO1xucmVxdWlyZSgnLi9jb250ZXh0cycpO1xucmVxdWlyZSgnLi9mbicpO1xucmVxdWlyZSgnLi9maWx0ZXInKTtcbnJlcXVpcmUoJy4vcmVmTGlzdCcpO1xuLy8gcmVmIGlzIGF0IHRoZSAqdmVyeSogZW5kIGJlY2F1c2UgcmVmIGNoYW5nZXMgdGhlIGVmZmVjdGl2ZSBvcmRlciBvZiBldmVudHNcbi8vIHRoYXQgZXZlbnQgbGlzdGVuZXJzIHNlZSB0aGF0IGFyZSBhZGRlZCBhZnRlciByZWYuIFNvIHRoaXMgbWFrZXMgaXQgc2FmZXIuXG5yZXF1aXJlKCcuL3JlZicpO1xuXG4vLyBFeHRlbmQgbW9kZWwgZm9yIHNlcnZlclxudXRpbC5zZXJ2ZXJSZXF1aXJlKF9fZGlybmFtZSArICcvYnVuZGxlJyk7XG51dGlsLnNlcnZlclJlcXVpcmUoX19kaXJuYW1lICsgJy9jb25uZWN0aW9uLnNlcnZlcicpO1xuXG59KShcIi9ub2RlX21vZHVsZXMvcmFjZXIvbGliL01vZGVsXCIpIiwidmFyIGRlZmF1bHRGbnMgPSBtb2R1bGUuZXhwb3J0cyA9IG5ldyBEZWZhdWx0Rm5zO1xuXG5kZWZhdWx0Rm5zLnJldmVyc2UgPSBuZXcgRm5QYWlyKGdldFJldmVyc2UsIHNldFJldmVyc2UpO1xuZGVmYXVsdEZucy5hc2MgPSBhc2M7XG5kZWZhdWx0Rm5zLmRlc2MgPSBkZXNjO1xuXG5mdW5jdGlvbiBEZWZhdWx0Rm5zKCkge31cbmZ1bmN0aW9uIEZuUGFpcihnZXQsIHNldCkge1xuICB0aGlzLmdldCA9IGdldDtcbiAgdGhpcy5zZXQgPSBzZXQ7XG59XG5cbmZ1bmN0aW9uIGdldFJldmVyc2UoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5ICYmIGFycmF5LnNsaWNlKCkucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gc2V0UmV2ZXJzZSh2YWx1ZXMpIHtcbiAgcmV0dXJuIHswOiBnZXRSZXZlcnNlKHZhbHVlcyl9O1xufVxuXG5mdW5jdGlvbiBhc2MoYSwgYikge1xuICBpZiAoYSA8IGIpIHJldHVybiAtMTtcbiAgaWYgKGEgPiBiKSByZXR1cm4gMTtcbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBkZXNjKGEsIGIpIHtcbiAgaWYgKGEgPiBiKSByZXR1cm4gLTE7XG4gIGlmIChhIDwgYikgcmV0dXJuIDE7XG4gIHJldHVybiAwO1xufVxuIiwicmVxdWlyZT0oZnVuY3Rpb24oZSx0LG4scil7ZnVuY3Rpb24gaShyKXtpZighbltyXSl7aWYoIXRbcl0pe2lmKGUpcmV0dXJuIGUocik7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIityK1wiJ1wiKX12YXIgcz1uW3JdPXtleHBvcnRzOnt9fTt0W3JdWzBdKGZ1bmN0aW9uKGUpe3ZhciBuPXRbcl1bMV1bZV07cmV0dXJuIGkobj9uOmUpfSxzLHMuZXhwb3J0cyl9cmV0dXJuIG5bcl0uZXhwb3J0c31mb3IodmFyIHM9MDtzPHIubGVuZ3RoO3MrKylpKHJbc10pO3JldHVybiBpfSkodHlwZW9mIHJlcXVpcmUhPT1cInVuZGVmaW5lZFwiJiZyZXF1aXJlLHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmV4cG9ydHMucmVhZElFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIG5CaXRzID0gLTcsXG4gICAgICBpID0gaXNCRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNCRSA/IDEgOiAtMSxcbiAgICAgIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIGUgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBtTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXM7XG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbik7XG59O1xuXG5leHBvcnRzLndyaXRlSUVFRTc1NCA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0JFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0JFID8gLTEgOiAxLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0se31dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCl7Ly8gVVRJTElUWVxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXI7XG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gb2JqZWN0KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICByZXN1bHQucHVzaChuYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gMS4gVGhlIGFzc2VydCBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIHRoYXQgdGhyb3dcbi8vIEFzc2VydGlvbkVycm9yJ3Mgd2hlbiBwYXJ0aWN1bGFyIGNvbmRpdGlvbnMgYXJlIG5vdCBtZXQuIFRoZVxuLy8gYXNzZXJ0IG1vZHVsZSBtdXN0IGNvbmZvcm0gdG8gdGhlIGZvbGxvd2luZyBpbnRlcmZhY2UuXG5cbnZhciBhc3NlcnQgPSBtb2R1bGUuZXhwb3J0cyA9IG9rO1xuXG4vLyAyLiBUaGUgQXNzZXJ0aW9uRXJyb3IgaXMgZGVmaW5lZCBpbiBhc3NlcnQuXG4vLyBuZXcgYXNzZXJ0LkFzc2VydGlvbkVycm9yKHsgbWVzc2FnZTogbWVzc2FnZSxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IGFjdHVhbCxcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWQgfSlcblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yID0gZnVuY3Rpb24gQXNzZXJ0aW9uRXJyb3Iob3B0aW9ucykge1xuICB0aGlzLm5hbWUgPSAnQXNzZXJ0aW9uRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG5cbiAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgc3RhY2tTdGFydEZ1bmN0aW9uKTtcbiAgfVxufTtcbnV0aWwuaW5oZXJpdHMoYXNzZXJ0LkFzc2VydGlvbkVycm9yLCBFcnJvcik7XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcy5sZW5ndGggPCBuID8gcyA6IHMuc2xpY2UoMCwgbik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cblxuYXNzZXJ0LkFzc2VydGlvbkVycm9yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIFt0aGlzLm5hbWUgKyAnOicsIHRoaXMubWVzc2FnZV0uam9pbignICcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXG4gICAgICB0aGlzLm5hbWUgKyAnOicsXG4gICAgICB0cnVuY2F0ZShKU09OLnN0cmluZ2lmeSh0aGlzLmFjdHVhbCwgcmVwbGFjZXIpLCAxMjgpLFxuICAgICAgdGhpcy5vcGVyYXRvcixcbiAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHRoaXMuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KVxuICAgIF0uam9pbignICcpO1xuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxuXG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IuX19wcm90b19fID0gRXJyb3IucHJvdG90eXBlO1xuXG4vLyBBdCBwcmVzZW50IG9ubHkgdGhlIHRocmVlIGtleXMgbWVudGlvbmVkIGFib3ZlIGFyZSB1c2VkIGFuZFxuLy8gdW5kZXJzdG9vZCBieSB0aGUgc3BlYy4gSW1wbGVtZW50YXRpb25zIG9yIHN1YiBtb2R1bGVzIGNhbiBwYXNzXG4vLyBvdGhlciBrZXlzIHRvIHRoZSBBc3NlcnRpb25FcnJvcidzIGNvbnN0cnVjdG9yIC0gdGhleSB3aWxsIGJlXG4vLyBpZ25vcmVkLlxuXG4vLyAzLiBBbGwgb2YgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnMgbXVzdCB0aHJvdyBhbiBBc3NlcnRpb25FcnJvclxuLy8gd2hlbiBhIGNvcnJlc3BvbmRpbmcgY29uZGl0aW9uIGlzIG5vdCBtZXQsIHdpdGggYSBtZXNzYWdlIHRoYXRcbi8vIG1heSBiZSB1bmRlZmluZWQgaWYgbm90IHByb3ZpZGVkLiAgQWxsIGFzc2VydGlvbiBtZXRob2RzIHByb3ZpZGVcbi8vIGJvdGggdGhlIGFjdHVhbCBhbmQgZXhwZWN0ZWQgdmFsdWVzIHRvIHRoZSBhc3NlcnRpb24gZXJyb3IgZm9yXG4vLyBkaXNwbGF5IHB1cnBvc2VzLlxuXG5mdW5jdGlvbiBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsIG9wZXJhdG9yLCBzdGFja1N0YXJ0RnVuY3Rpb24pIHtcbiAgdGhyb3cgbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7XG4gICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICBhY3R1YWw6IGFjdHVhbCxcbiAgICBleHBlY3RlZDogZXhwZWN0ZWQsXG4gICAgb3BlcmF0b3I6IG9wZXJhdG9yLFxuICAgIHN0YWNrU3RhcnRGdW5jdGlvbjogc3RhY2tTdGFydEZ1bmN0aW9uXG4gIH0pO1xufVxuXG4vLyBFWFRFTlNJT04hIGFsbG93cyBmb3Igd2VsbCBiZWhhdmVkIGVycm9ycyBkZWZpbmVkIGVsc2V3aGVyZS5cbmFzc2VydC5mYWlsID0gZmFpbDtcblxuLy8gNC4gUHVyZSBhc3NlcnRpb24gdGVzdHMgd2hldGhlciBhIHZhbHVlIGlzIHRydXRoeSwgYXMgZGV0ZXJtaW5lZFxuLy8gYnkgISFndWFyZC5cbi8vIGFzc2VydC5vayhndWFyZCwgbWVzc2FnZV9vcHQpO1xuLy8gVGhpcyBzdGF0ZW1lbnQgaXMgZXF1aXZhbGVudCB0byBhc3NlcnQuZXF1YWwodHJ1ZSwgZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghISF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09JywgYXNzZXJ0Lm9rKTtcbn1cbmFzc2VydC5vayA9IG9rO1xuXG4vLyA1LiBUaGUgZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIHNoYWxsb3csIGNvZXJjaXZlIGVxdWFsaXR5IHdpdGhcbi8vID09LlxuLy8gYXNzZXJ0LmVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gZXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9IGV4cGVjdGVkKSBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5lcXVhbCk7XG59O1xuXG4vLyA2LiBUaGUgbm9uLWVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBmb3Igd2hldGhlciB0d28gb2JqZWN0cyBhcmUgbm90IGVxdWFsXG4vLyB3aXRoICE9IGFzc2VydC5ub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3RFcXVhbCA9IGZ1bmN0aW9uIG5vdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCA9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9JywgYXNzZXJ0Lm5vdEVxdWFsKTtcbiAgfVxufTtcblxuLy8gNy4gVGhlIGVxdWl2YWxlbmNlIGFzc2VydGlvbiB0ZXN0cyBhIGRlZXAgZXF1YWxpdHkgcmVsYXRpb24uXG4vLyBhc3NlcnQuZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LmRlZXBFcXVhbCA9IGZ1bmN0aW9uIGRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmICghX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ2RlZXBFcXVhbCcsIGFzc2VydC5kZWVwRXF1YWwpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChCdWZmZXIuaXNCdWZmZXIoYWN0dWFsKSAmJiBCdWZmZXIuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgRGF0ZSAmJiBleHBlY3RlZCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMy4gT3RoZXIgcGFpcnMgdGhhdCBkbyBub3QgYm90aCBwYXNzIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JyxcbiAgLy8gZXF1aXZhbGVuY2UgaXMgZGV0ZXJtaW5lZCBieSA9PS5cbiAgfSBlbHNlIGlmICh0eXBlb2YgYWN0dWFsICE9ICdvYmplY3QnICYmIHR5cGVvZiBleHBlY3RlZCAhPSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gNy40LiBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyhvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiKSB7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpLFxuICAgICAgICBrZXksIGk7XG4gIH0gY2F0Y2ggKGUpIHsvL2hhcHBlbnMgd2hlbiBvbmUgaXMgYSBzdHJpbmcgbGl0ZXJhbCBhbmQgdGhlIG90aGVyIGlzbid0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWQuY2FsbCh7fSwgYWN0dWFsKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfdGhyb3dzKHNob3VsZFRocm93LCBibG9jaywgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgdmFyIGFjdHVhbDtcblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbCgnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbCgnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MuYXBwbHkodGhpcywgW2ZhbHNlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuYXNzZXJ0LmlmRXJyb3IgPSBmdW5jdGlvbihlcnIpIHsgaWYgKGVycikge3Rocm93IGVycjt9fTtcblxufSkoKVxufSx7XCJ1dGlsXCI6MyxcImJ1ZmZlclwiOjR9XSxcImJ1ZmZlci1icm93c2VyaWZ5XCI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9cmVxdWlyZSgncTlUeENDJyk7XG59LHt9XSxcInE5VHhDQ1wiOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpe2Z1bmN0aW9uIFNsb3dCdWZmZXIgKHNpemUpIHtcbiAgICB0aGlzLmxlbmd0aCA9IHNpemU7XG59O1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MDtcblxuXG5mdW5jdGlvbiB0b0hleChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KTtcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpO1xufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICBpZiAoc3RyLmNoYXJDb2RlQXQoaSkgPD0gMHg3RilcbiAgICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgICBlbHNlIHtcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5jaGFyQXQoaSkpLnN1YnN0cigxKS5zcGxpdCgnJScpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKVxuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpO1xuICAgIH1cblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goIHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRiApO1xuXG4gIHJldHVybiBieXRlQXJyYXk7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMoc3RyKSB7XG4gIHJldHVybiByZXF1aXJlKFwiYmFzZTY0LWpzXCIpLnRvQnl0ZUFycmF5KHN0cik7XG59XG5cblNsb3dCdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcgfHwgXCJ1dGY4XCIpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggLyAyO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aDtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gYmxpdEJ1ZmZlcihzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvcywgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaWYgKChpK29mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrO1xuXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldO1xuICAgIGkrKztcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGJ5dGVzLCBwb3M7XG4gIHJldHVybiBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSAgYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgdGhpcywgb2Zmc2V0LCBsZW5ndGgpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBTbG93QnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlO1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gU2xvd0J1ZmZlci5wcm90b3R5cGUuYXNjaWlTbGljZTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxTbG93QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDA7XG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW47XG5cbiAgdmFyIG91dCA9ICcnO1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIG91dCArPSB0b0hleCh0aGlzW2ldKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcbiAgc3RhcnQgPSArc3RhcnQgfHwgMDtcbiAgaWYgKHR5cGVvZiBlbmQgPT0gJ3VuZGVmaW5lZCcpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKCtlbmQgPT0gc3RhcnQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMudXRmOFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0dXJuIHRoaXMuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5iYXNlNjRTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIHJldHVybiB0aGlzLnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5oZXhXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAoc3RyTGVuICUgMikge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNik7XG4gICAgaWYgKGlzTmFOKGJ5dGUpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSBieXRlO1xuICB9XG4gIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9IGkgKiAyO1xuICByZXR1cm4gaTtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhXcml0ZShzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyV3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcblNsb3dCdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIGVuZCA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cbiAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMsIGVuZCAtIHN0YXJ0LCArc3RhcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHRhcmdldCwgdGFyZ2V0c3RhcnQsIHNvdXJjZXN0YXJ0LCBzb3VyY2VlbmQpIHtcbiAgdmFyIHRlbXAgPSBbXTtcbiAgZm9yICh2YXIgaT1zb3VyY2VzdGFydDsgaTxzb3VyY2VlbmQ7IGkrKykge1xuICAgIGFzc2VydC5vayh0eXBlb2YgdGhpc1tpXSAhPT0gJ3VuZGVmaW5lZCcsIFwiY29weWluZyB1bmRlZmluZWQgYnVmZmVyIGJ5dGVzIVwiKTtcbiAgICB0ZW1wLnB1c2godGhpc1tpXSk7XG4gIH1cblxuICBmb3IgKHZhciBpPXRhcmdldHN0YXJ0OyBpPHRhcmdldHN0YXJ0K3RlbXAubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRbaV0gPSB0ZW1wW2ktdGFyZ2V0c3RhcnRdO1xuICB9XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24odmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgfVxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgIHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0gPSBzdWJqZWN0LnJlYWRVSW50OChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UgYXJlIGEgc3RyaW5nXG4gICAgICB0aGlzLmxlbmd0aCA9IHRoaXMud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlJc2goc3ViamVjdCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInO1xufVxuXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDggKiAxMDI0O1xudmFyIHBvb2w7XG5cbmZ1bmN0aW9uIGFsbG9jUG9vbCgpIHtcbiAgcG9vbCA9IG5ldyBTbG93QnVmZmVyKEJ1ZmZlci5wb29sU2l6ZSk7XG4gIHBvb2wudXNlZCA9IDA7XG59XG5cblxuLy8gU3RhdGljIG1ldGhvZHNcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgcmV0dXJuIGIgaW5zdGFuY2VvZiBCdWZmZXIgfHwgYiBpbnN0YW5jZW9mIFNsb3dCdWZmZXI7XG59O1xuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuIFxcXG4gICAgICBsaXN0IHNob3VsZCBiZSBhbiBBcnJheS5cIik7XG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKTtcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0b3RhbExlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICB0b3RhbExlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYnVmID0gbGlzdFtpXTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpO1xuICB2YXIgcG9zID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpO1xuICAgIHBvcyArPSBidWYubGVuZ3RoO1xuICB9XG4gIHJldHVybiBidWZmZXI7XG59O1xuXG4vLyBJbnNwZWN0XG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICB2YXIgb3V0ID0gW10sXG4gICAgICBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpcy5wYXJlbnRbaSArIHRoaXMub2Zmc2V0XSk7XG4gICAgaWYgKGkgPT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nO1xufTtcblxuXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChpKSB7XG4gIGlmIChpIDwgMCB8fCBpID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICByZXR1cm4gdGhpcy5wYXJlbnRbdGhpcy5vZmZzZXQgKyBpXTtcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQoaSwgdikge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV0gPSB2O1xufTtcblxuXG4vLyB3cml0ZShzdHJpbmcsIG9mZnNldCA9IDAsIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgtb2Zmc2V0LCBlbmNvZGluZyA9ICd1dGY4JylcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gb2Zmc2V0O1xuICAgIG9mZnNldCA9IGxlbmd0aDtcbiAgICBsZW5ndGggPSBzd2FwO1xuICB9XG5cbiAgb2Zmc2V0ID0gK29mZnNldCB8fCAwO1xuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9ICtsZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgdmFyIHJldDtcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5oZXhXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51dGY4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYXNjaWlXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmluYXJ5V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICByZXQgPSB0aGlzLnBhcmVudC5iYXNlNjRXcml0ZShzdHJpbmcsIHRoaXMub2Zmc2V0ICsgb2Zmc2V0LCBsZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXQgPSB0aGlzLnBhcmVudC51Y3MyV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG5cbiAgQnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW47XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cblxuLy8gdG9TdHJpbmcoZW5jb2RpbmcsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKTtcblxuICBpZiAodHlwZW9mIHN0YXJ0ID09ICd1bmRlZmluZWQnIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3RhcnQgPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IDA7XG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ICsgdGhpcy5vZmZzZXQ7XG4gIGVuZCA9IGVuZCArIHRoaXMub2Zmc2V0O1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmhleFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5hc2NpaVNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5iaW5hcnlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQudWNzMlNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIGJ5dGVMZW5ndGhcbkJ1ZmZlci5ieXRlTGVuZ3RoID0gU2xvd0J1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICB2YWx1ZSB8fCAodmFsdWUgPSAwKTtcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG4gIGlmICghKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHx8IGlzTmFOKHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigndmFsdWUgaXMgbm90IGEgbnVtYmVyJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignZW5kIDwgc3RhcnQnKTtcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGhpcy5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5wYXJlbnQuZmlsbCh2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpcztcbiAgc3RhcnQgfHwgKHN0YXJ0ID0gMCk7XG4gIGVuZCB8fCAoZW5kID0gdGhpcy5sZW5ndGgpO1xuICB0YXJnZXRfc3RhcnQgfHwgKHRhcmdldF9zdGFydCA9IDApO1xuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpO1xuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDA7XG4gIGlmICh0YXJnZXQubGVuZ3RoID09IDAgfHwgc291cmNlLmxlbmd0aCA9PSAwKSByZXR1cm4gMDtcblxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJyk7XG4gIH1cblxuICBpZiAoZW5kIDwgMCB8fCBlbmQgPiBzb3VyY2UubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmNvcHkodGFyZ2V0LnBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0X3N0YXJ0ICsgdGFyZ2V0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgKyB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBzbGljZShzdGFydCwgZW5kKVxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICBpZiAoc3RhcnQgPiBlbmQpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIodGhpcy5wYXJlbnQsIGVuZCAtIHN0YXJ0LCArc3RhcnQgKyB0aGlzLm9mZnNldCk7XG59O1xuXG5cbi8vIExlZ2FjeSBtZXRob2RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblxuQnVmZmVyLnByb3RvdHlwZS51dGY4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYmluYXJ5Jywgc3RhcnQsIGVuZCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHJldHVybiB0aGlzLnRvU3RyaW5nKCdhc2NpaScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ3V0ZjgnKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYmluYXJ5V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCkge1xuICByZXR1cm4gdGhpcy53cml0ZShzdHJpbmcsIG9mZnNldCwgJ2JpbmFyeScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdhc2NpaScpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhciBidWZmZXIgPSB0aGlzO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHJldHVybiBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm4gMDtcblxuICBpZiAoaXNCaWdFbmRpYW4pIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF07XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZFVJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciB2YWwgPSAwO1xuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkgcmV0dXJuIDA7XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgaWYgKG9mZnNldCArIDIgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgaWYgKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoKVxuICAgICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgpXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKG9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSByZXR1cm47XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSA9IHZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDIpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGlzQmlnRW5kaWFuID8gMSAtIGkgOiBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChpc0JpZ0VuZGlhbiA/IDEgLSBpIDogaSkgKiA4O1xuICB9XG5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmZmZmZik7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBvZmZzZXQsIDQpOyBpKyspIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyBpXSA9XG4gICAgICAgICh2YWx1ZSA+Pj4gKGlzQmlnRW5kaWFuID8gMyAtIGkgOiBpKSAqIDgpICYgMHhmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuXG4vKlxuICogV2Ugbm93IG1vdmUgb250byBvdXIgZnJpZW5kcyBpbiB0aGUgc2lnbmVkIG51bWJlciBjYXRlZ29yeS4gVW5saWtlIHVuc2lnbmVkXG4gKiBudW1iZXJzLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHdvcnJ5IGEgYml0IG1vcmUgYWJvdXQgaG93IHdlIHB1dCB2YWx1ZXMgaW50b1xuICogYXJyYXlzLiBTaW5jZSB3ZSBhcmUgb25seSB3b3JyeWluZyBhYm91dCBzaWduZWQgMzItYml0IHZhbHVlcywgd2UncmUgaW5cbiAqIHNsaWdodGx5IGJldHRlciBzaGFwZS4gVW5mb3J0dW5hdGVseSwgd2UgcmVhbGx5IGNhbid0IGRvIG91ciBmYXZvcml0ZSBiaW5hcnlcbiAqICYgaW4gdGhpcyBzeXN0ZW0uIEl0IHJlYWxseSBzZWVtcyB0byBkbyB0aGUgd3JvbmcgdGhpbmcuIEZvciBleGFtcGxlOlxuICpcbiAqID4gLTMyICYgMHhmZlxuICogMjI0XG4gKlxuICogV2hhdCdzIGhhcHBlbmluZyBhYm92ZSBpcyByZWFsbHk6IDB4ZTAgJiAweGZmID0gMHhlMC4gSG93ZXZlciwgdGhlIHJlc3VsdHMgb2ZcbiAqIHRoaXMgYXJlbid0IHRyZWF0ZWQgYXMgYSBzaWduZWQgbnVtYmVyLiBVbHRpbWF0ZWx5IGEgYmFkIHRoaW5nLlxuICpcbiAqIFdoYXQgd2UncmUgZ29pbmcgdG8gd2FudCB0byBkbyBpcyBiYXNpY2FsbHkgY3JlYXRlIHRoZSB1bnNpZ25lZCBlcXVpdmFsZW50IG9mXG4gKiBvdXIgcmVwcmVzZW50YXRpb24gYW5kIHBhc3MgdGhhdCBvZmYgdG8gdGhlIHd1aW50KiBmdW5jdGlvbnMuIFRvIGRvIHRoYXRcbiAqIHdlJ3JlIGdvaW5nIHRvIGRvIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogIC0gaWYgdGhlIHZhbHVlIGlzIHBvc2l0aXZlXG4gKiAgICAgIHdlIGNhbiBwYXNzIGl0IGRpcmVjdGx5IG9mZiB0byB0aGUgZXF1aXZhbGVudCB3dWludFxuICogIC0gaWYgdGhlIHZhbHVlIGlzIG5lZ2F0aXZlXG4gKiAgICAgIHdlIGRvIHRoZSBmb2xsb3dpbmcgY29tcHV0YXRpb246XG4gKiAgICAgICAgIG1iICsgdmFsICsgMSwgd2hlcmVcbiAqICAgICAgICAgbWIgICBpcyB0aGUgbWF4aW11bSB1bnNpZ25lZCB2YWx1ZSBpbiB0aGF0IGJ5dGUgc2l6ZVxuICogICAgICAgICB2YWwgIGlzIHRoZSBKYXZhc2NyaXB0IG5lZ2F0aXZlIGludGVnZXJcbiAqXG4gKlxuICogQXMgYSBjb25jcmV0ZSB2YWx1ZSwgdGFrZSAtMTI4LiBJbiBzaWduZWQgMTYgYml0cyB0aGlzIHdvdWxkIGJlIDB4ZmY4MC4gSWZcbiAqIHlvdSBkbyBvdXQgdGhlIGNvbXB1dGF0aW9uczpcbiAqXG4gKiAweGZmZmYgLSAxMjggKyAxXG4gKiAweGZmZmYgLSAxMjdcbiAqIDB4ZmY4MFxuICpcbiAqIFlvdSBjYW4gdGhlbiBlbmNvZGUgdGhpcyB2YWx1ZSBhcyB0aGUgc2lnbmVkIHZlcnNpb24uIFRoaXMgaXMgcmVhbGx5IHJhdGhlclxuICogaGFja3ksIGJ1dCBpdCBzaG91bGQgd29yayBhbmQgZ2V0IHRoZSBqb2IgZG9uZSB3aGljaCBpcyBvdXIgZ29hbCBoZXJlLlxuICovXG5cbi8qXG4gKiBBIHNlcmllcyBvZiBjaGVja3MgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgYSBzaWduZWQgMzItYml0IG51bWJlclxuICovXG5mdW5jdGlvbiB2ZXJpZnNpbnQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jyk7XG59XG5cbmZ1bmN0aW9uIHZlcmlmSUVFRTc1NCh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0Lm9rKHR5cGVvZiAodmFsdWUpID09ICdudW1iZXInLFxuICAgICAgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKTtcblxuICBhc3NlcnQub2sodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB3cml0ZUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MTYoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgMHhmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCk7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQzMihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDMgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9IGVsc2Uge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICAyMywgNCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgNyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCk7XG4gIH1cblxuICByZXF1aXJlKCcuL2J1ZmZlcl9pZWVlNzU0Jykud3JpdGVJRUVFNzU0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sXG4gICAgICA1MiwgOCk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRTtcblxufSkoKVxufSx7XCJhc3NlcnRcIjoyLFwiLi9idWZmZXJfaWVlZTc1NFwiOjEsXCJiYXNlNjQtanNcIjo1fV0sMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5leHBvcnRzLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBEYXRlXSd9O1xuZXhwb3J0cy5pc1JlZ0V4cCA9IGZ1bmN0aW9uKG9iail7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJ307XG5cblxuZXhwb3J0cy5wcmludCA9IGZ1bmN0aW9uICgpIHt9O1xuZXhwb3J0cy5wdXRzID0gZnVuY3Rpb24gKCkge307XG5leHBvcnRzLmRlYnVnID0gZnVuY3Rpb24oKSB7fTtcblxuZXhwb3J0cy5pbnNwZWN0ID0gZnVuY3Rpb24ob2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKSB7XG4gIHZhciBzZWVuID0gW107XG5cbiAgdmFyIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkge1xuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuICAgIHZhciBzdHlsZXMgPVxuICAgICAgICB7ICdib2xkJyA6IFsxLCAyMl0sXG4gICAgICAgICAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAgICAgICAgICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgICAgICAgICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAgICAgICAgICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgICAgICAgICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgICAgICAgICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICAgICAgICAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICAgICAgICAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICAgICAgICAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAgICAgICAgICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAgICAgICAgICdyZWQnIDogWzMxLCAzOV0sXG4gICAgICAgICAgJ3llbGxvdycgOiBbMzMsIDM5XSB9O1xuXG4gICAgdmFyIHN0eWxlID1cbiAgICAgICAgeyAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgICAgICAgICAnbnVtYmVyJzogJ2JsdWUnLFxuICAgICAgICAgICdib29sZWFuJzogJ3llbGxvdycsXG4gICAgICAgICAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgICAgICAgICAnbnVsbCc6ICdib2xkJyxcbiAgICAgICAgICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgICAgICAgICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgICAgICAgICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAgICAgICAgICdyZWdleHAnOiAncmVkJyB9W3N0eWxlVHlwZV07XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiAnXFwwMzNbJyArIHN0eWxlc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAgICdcXDAzM1snICsgc3R5bGVzW3N0eWxlXVsxXSArICdtJztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gIH07XG4gIGlmICghIGNvbG9ycykge1xuICAgIHN0eWxpemUgPSBmdW5jdGlvbihzdHIsIHN0eWxlVHlwZSkgeyByZXR1cm4gc3RyOyB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gICAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnNwZWN0ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgICB2YWx1ZSAhPT0gZXhwb3J0cyAmJlxuICAgICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzKTtcbiAgICB9XG5cbiAgICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgICAgICByZXR1cm4gc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcblxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuXG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgICB9XG4gICAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xuICAgIH1cblxuICAgIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgICB2YXIgdmlzaWJsZV9rZXlzID0gT2JqZWN0X2tleXModmFsdWUpO1xuICAgIHZhciBrZXlzID0gc2hvd0hpZGRlbiA/IE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKSA6IHZpc2libGVfa2V5cztcblxuICAgIC8vIEZ1bmN0aW9ucyB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYga2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERhdGVzIHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWRcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSAmJiBrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxpemUodmFsdWUudG9VVENTdHJpbmcoKSwgJ2RhdGUnKTtcbiAgICB9XG5cbiAgICB2YXIgYmFzZSwgdHlwZSwgYnJhY2VzO1xuICAgIC8vIERldGVybWluZSB0aGUgb2JqZWN0IHR5cGVcbiAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHR5cGUgPSAnQXJyYXknO1xuICAgICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9ICdPYmplY3QnO1xuICAgICAgYnJhY2VzID0gWyd7JywgJ30nXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgYmFzZSA9IChpc1JlZ0V4cCh2YWx1ZSkpID8gJyAnICsgdmFsdWUgOiAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICBiYXNlID0gJyc7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIGJhc2UgPSAnICcgKyB2YWx1ZS50b1VUQ1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gICAgfVxuXG4gICAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJycgKyB2YWx1ZSwgJ3JlZ2V4cCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWVuLnB1c2godmFsdWUpO1xuXG4gICAgdmFyIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIG5hbWUsIHN0cjtcbiAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKSB7XG4gICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cEdldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICBpZiAodmFsdWUuX19sb29rdXBTZXR0ZXJfXyhrZXkpKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBzdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh2YWx1ZS5fX2xvb2t1cFNldHRlcl9fKGtleSkpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh2aXNpYmxlX2tleXMuaW5kZXhPZihrZXkpIDwgMCkge1xuICAgICAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWx1ZVtrZXldKSA8IDApIHtcbiAgICAgICAgICBpZiAocmVjdXJzZVRpbWVzID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdHIgPSBmb3JtYXQodmFsdWVba2V5XSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0ciA9IGZvcm1hdCh2YWx1ZVtrZXldLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9IHN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAnQXJyYXknICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgICAgIG5hbWUgPSBzdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgICAgICBuYW1lID0gc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xuICAgIH0pO1xuXG4gICAgc2Vlbi5wb3AoKTtcblxuICAgIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgICBudW1MaW5lc0VzdCsrO1xuICAgICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgICAgcmV0dXJuIHByZXYgKyBjdXIubGVuZ3RoICsgMTtcbiAgICB9LCAwKTtcblxuICAgIGlmIChsZW5ndGggPiA1MCkge1xuICAgICAgb3V0cHV0ID0gYnJhY2VzWzBdICtcbiAgICAgICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgICAgYnJhY2VzWzFdO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dCA9IGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHJldHVybiBmb3JtYXQob2JqLCAodHlwZW9mIGRlcHRoID09PSAndW5kZWZpbmVkJyA/IDIgOiBkZXB0aCkpO1xufTtcblxuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBhciBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICBBcnJheS5pc0FycmF5KGFyKSB8fFxuICAgICAgICAgKGFyICYmIGFyICE9PSBPYmplY3QucHJvdG90eXBlICYmIGlzQXJyYXkoYXIuX19wcm90b19fKSk7XG59XG5cblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIHJlIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgKHR5cGVvZiByZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScpO1xufVxuXG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIGlmIChkIGluc3RhbmNlb2YgRGF0ZSkgcmV0dXJuIHRydWU7XG4gIGlmICh0eXBlb2YgZCAhPT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcbiAgdmFyIHByb3BlcnRpZXMgPSBEYXRlLnByb3RvdHlwZSAmJiBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyhEYXRlLnByb3RvdHlwZSk7XG4gIHZhciBwcm90byA9IGQuX19wcm90b19fICYmIE9iamVjdF9nZXRPd25Qcm9wZXJ0eU5hbWVzKGQuX19wcm90b19fKTtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByb3RvKSA9PT0gSlNPTi5zdHJpbmdpZnkocHJvcGVydGllcyk7XG59XG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uIChtc2cpIHt9O1xuXG5leHBvcnRzLnB1bXAgPSBudWxsO1xuXG52YXIgT2JqZWN0X2tleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBPYmplY3RfZ2V0T3duUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIE9iamVjdF9jcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAvLyBmcm9tIGVzNS1zaGltXG4gICAgdmFyIG9iamVjdDtcbiAgICBpZiAocHJvdG90eXBlID09PSBudWxsKSB7XG4gICAgICAgIG9iamVjdCA9IHsgJ19fcHJvdG9fXycgOiBudWxsIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3R5cGVvZiBwcm90b3R5cGVbJyArICh0eXBlb2YgcHJvdG90eXBlKSArICddICE9IFxcJ29iamVjdFxcJydcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFR5cGUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgVHlwZS5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgICAgIG9iamVjdCA9IG5ldyBUeXBlKCk7XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0X2NyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG59O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAodHlwZW9mIGYgIT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGV4cG9ydHMuaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6IHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSl7XG4gICAgaWYgKHggPT09IG51bGwgfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGV4cG9ydHMuaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbn0se1wiZXZlbnRzXCI6Nn1dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5leHBvcnRzLnJlYWRJRUVFNzU0ID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzQkUgPyAwIDogKG5CeXRlcyAtIDEpLFxuICAgICAgZCA9IGlzQkUgPyAxIDogLTEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZUlFRUU3NTQgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQkUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNCRSA/IChuQnl0ZXMgLSAxKSA6IDAsXG4gICAgICBkID0gaXNCRSA/IC0xIDogMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYuc291cmNlID09PSB3aW5kb3cgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59LHt9XSw2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbihwcm9jZXNzKXtpZiAoIXByb2Nlc3MuRXZlbnRFbWl0dGVyKSBwcm9jZXNzLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBwcm9jZXNzLkV2ZW50RW1pdHRlcjtcbnZhciBpc0FycmF5ID0gdHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICdmdW5jdGlvbidcbiAgICA/IEFycmF5LmlzQXJyYXlcbiAgICA6IGZ1bmN0aW9uICh4cykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICAgIH1cbjtcbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHggPT09IHhzW2ldKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4vLyAxMCBsaXN0ZW5lcnMgYXJlIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2hcbi8vIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuLy9cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcbiAgdGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyA9IG47XG59O1xuXG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzQXJyYXkodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpXG4gICAge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGFyZ3VtZW50c1sxXTsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuY2F1Z2h0LCB1bnNwZWNpZmllZCAnZXJyb3InIGV2ZW50LlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIGZhbHNlO1xuICB2YXIgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgaWYgKCFoYW5kbGVyKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGlzQXJyYXkoaGFuZGxlcikpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuLy8gRXZlbnRFbWl0dGVyIGlzIGRlZmluZWQgaW4gc3JjL25vZGVfZXZlbnRzLmNjXG4vLyBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQoKSBpcyBhbHNvIGRlZmluZWQgdGhlcmUuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCdmdW5jdGlvbicgIT09IHR5cGVvZiBsaXN0ZW5lcikge1xuICAgIHRocm93IG5ldyBFcnJvcignYWRkTGlzdGVuZXIgb25seSB0YWtlcyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIGlmICghdGhpcy5fZXZlbnRzKSB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyc1wiLlxuICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIH0gZWxzZSBpZiAoaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgICAgdmFyIG07XG4gICAgICBpZiAodGhpcy5fZXZlbnRzLm1heExpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG0gPSB0aGlzLl9ldmVudHMubWF4TGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbSA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgICB9XG5cbiAgICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLm9uKHR5cGUsIGZ1bmN0aW9uIGcoKSB7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcbiAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVMaXN0ZW5lciBvbmx5IHRha2VzIGluc3RhbmNlcyBvZiBGdW5jdGlvbicpO1xuICB9XG5cbiAgLy8gZG9lcyBub3QgdXNlIGxpc3RlbmVycygpLCBzbyBubyBzaWRlIGVmZmVjdCBvZiBjcmVhdGluZyBfZXZlbnRzW3R5cGVdXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pIHJldHVybiB0aGlzO1xuXG4gIHZhciBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0FycmF5KGxpc3QpKSB7XG4gICAgdmFyIGkgPSBpbmRleE9mKGxpc3QsIGxpc3RlbmVyKTtcbiAgICBpZiAoaSA8IDApIHJldHVybiB0aGlzO1xuICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfSBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0gPT09IGxpc3RlbmVyKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgaWYgKHR5cGUgJiYgdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gbnVsbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSkgdGhpcy5fZXZlbnRzW3R5cGVdID0gW107XG4gIGlmICghaXNBcnJheSh0aGlzLl9ldmVudHNbdHlwZV0pKSB7XG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2V2ZW50c1t0eXBlXTtcbn07XG5cbn0pKHJlcXVpcmUoXCJfX2Jyb3dzZXJpZnlfcHJvY2Vzc1wiKSlcbn0se1wiX19icm93c2VyaWZ5X3Byb2Nlc3NcIjo4fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKXtmdW5jdGlvbiBTbG93QnVmZmVyIChzaXplKSB7XG4gICAgdGhpcy5sZW5ndGggPSBzaXplO1xufTtcblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTA7XG5cblxuZnVuY3Rpb24gdG9IZXgobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNik7XG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspXG4gICAgaWYgKHN0ci5jaGFyQ29kZUF0KGkpIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuY2hhckF0KGkpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKylcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKTtcbiAgICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheTtcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKysgKVxuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKCBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYgKTtcblxuICByZXR1cm4gYnl0ZUFycmF5O1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzKHN0cikge1xuICByZXR1cm4gcmVxdWlyZShcImJhc2U2NC1qc1wiKS50b0J5dGVBcnJheShzdHIpO1xufVxuXG5TbG93QnVmZmVyLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8IFwidXRmOFwiKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoIC8gMjtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aDtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cikubGVuZ3RoO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBibGl0QnVmZmVyKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgcG9zLCBpID0gMDtcbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBpZiAoKGkrb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWs7XG5cbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV07XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBpO1xufVxuXG5TbG93QnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpV3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgYnl0ZXMsIHBvcztcbiAgcmV0dXJuIFNsb3dCdWZmZXIuX2NoYXJzV3JpdHRlbiA9ICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCB0aGlzLCBvZmZzZXQsIGxlbmd0aCk7XG59O1xuXG5TbG93QnVmZmVyLnByb3RvdHlwZS5iYXNlNjRXcml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBieXRlcywgcG9zO1xuICByZXR1cm4gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIHRoaXMsIG9mZnNldCwgbGVuZ3RoKTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmJhc2U2NFNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgcmV0dXJuIHJlcXVpcmUoXCJiYXNlNjQtanNcIikuZnJvbUJ5dGVBcnJheShieXRlcyk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKTsgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdmFyIHJlcyA9IFwiXCI7XG4gIHZhciB0bXAgPSBcIlwiO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVzW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgICB0bXAgPSBcIlwiO1xuICAgIH0gZWxzZVxuICAgICAgdG1wICs9IFwiJVwiICsgYnl0ZXNbaV0udG9TdHJpbmcoMTYpO1xuXG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHJlcyArIGRlY29kZVV0ZjhDaGFyKHRtcCk7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmFzY2lpU2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB2YXIgcmV0ID0gXCJcIjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gIHJldHVybiByZXQ7XG59XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSB0b0hleCh0aGlzW2ldKTtcbiAgICBpZiAoaSA9PSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTKSB7XG4gICAgICBvdXRbaSArIDFdID0gJy4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8U2xvd0J1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4U2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwO1xuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgodGhpc1tpXSk7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG4gIHN0YXJ0ID0gK3N0YXJ0IHx8IDA7XG4gIGlmICh0eXBlb2YgZW5kID09ICd1bmRlZmluZWQnKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICAvLyBGYXN0cGF0aCBlbXB0eSBzdHJpbmdzXG4gIGlmICgrZW5kID09IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXR1cm4gdGhpcy5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnV0ZjhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldHVybiB0aGlzLmFzY2lpU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgICByZXR1cm4gdGhpcy51Y3MyU2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJyk7XG4gIH1cbn07XG5cblxuU2xvd0J1ZmZlci5wcm90b3R5cGUuaGV4V3JpdGUgPSBmdW5jdGlvbihzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICB9XG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMjtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpO1xuICAgIGlmIChpc05hTihieXRlKSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgICB0aGlzW29mZnNldCArIGldID0gYnl0ZTtcbiAgfVxuICBTbG93QnVmZmVyLl9jaGFyc1dyaXR0ZW4gPSBpICogMjtcbiAgcmV0dXJuIGk7XG59O1xuXG5cblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0dXJuIHRoaXMuaGV4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXR1cm4gdGhpcy51dGY4V3JpdGUoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5hc2NpaVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldHVybiB0aGlzLmJpbmFyeVdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldHVybiB0aGlzLmJhc2U2NFdyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMudWNzMldyaXRlKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICB9XG59O1xuXG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5TbG93QnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSBlbmQgPSB0aGlzLmxlbmd0aDtcblxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuICB9XG4gIGlmIChzdGFydCA+IGVuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEJ1ZmZlcih0aGlzLCBlbmQgLSBzdGFydCwgK3N0YXJ0KTtcbn07XG5cblNsb3dCdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbih0YXJnZXQsIHRhcmdldHN0YXJ0LCBzb3VyY2VzdGFydCwgc291cmNlZW5kKSB7XG4gIHZhciB0ZW1wID0gW107XG4gIGZvciAodmFyIGk9c291cmNlc3RhcnQ7IGk8c291cmNlZW5kOyBpKyspIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIHRoaXNbaV0gIT09ICd1bmRlZmluZWQnLCBcImNvcHlpbmcgdW5kZWZpbmVkIGJ1ZmZlciBieXRlcyFcIik7XG4gICAgdGVtcC5wdXNoKHRoaXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaT10YXJnZXRzdGFydDsgaTx0YXJnZXRzdGFydCt0ZW1wLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0W2ldID0gdGVtcFtpLXRhcmdldHN0YXJ0XTtcbiAgfVxufTtcblxuZnVuY3Rpb24gY29lcmNlKGxlbmd0aCkge1xuICAvLyBDb2VyY2UgbGVuZ3RoIHRvIGEgbnVtYmVyIChwb3NzaWJseSBOYU4pLCByb3VuZCB1cFxuICAvLyBpbiBjYXNlIGl0J3MgZnJhY3Rpb25hbCAoZS5nLiAxMjMuNDU2KSB0aGVuIGRvIGFcbiAgLy8gZG91YmxlIG5lZ2F0ZSB0byBjb2VyY2UgYSBOYU4gdG8gMC4gRWFzeSwgcmlnaHQ/XG4gIGxlbmd0aCA9IH5+TWF0aC5jZWlsKCtsZW5ndGgpO1xuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGg7XG59XG5cblxuLy8gQnVmZmVyXG5cbmZ1bmN0aW9uIEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgb2Zmc2V0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG9mZnNldCk7XG4gIH1cblxuICB2YXIgdHlwZTtcblxuICAvLyBBcmUgd2Ugc2xpY2luZz9cbiAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5sZW5ndGggPSBjb2VyY2UoZW5jb2RpbmcpO1xuICAgIHRoaXMucGFyZW50ID0gc3ViamVjdDtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgfSBlbHNlIHtcbiAgICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgICBzd2l0Y2ggKHR5cGUgPSB0eXBlb2Ygc3ViamVjdCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB0aGlzLmxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN1YmplY3QsIGVuY29kaW5nKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIEFzc3VtZSBvYmplY3QgaXMgYW4gYXJyYXlcbiAgICAgICAgdGhpcy5sZW5ndGggPSBjb2VyY2Uoc3ViamVjdC5sZW5ndGgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYXJyYXkgb3Igc3RyaW5nLicpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IEJ1ZmZlci5wb29sU2l6ZSkge1xuICAgICAgLy8gQmlnIGJ1ZmZlciwganVzdCBhbGxvYyBvbmUuXG4gICAgICB0aGlzLnBhcmVudCA9IG5ldyBTbG93QnVmZmVyKHRoaXMubGVuZ3RoKTtcbiAgICAgIHRoaXMub2Zmc2V0ID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTbWFsbCBidWZmZXIuXG4gICAgICBpZiAoIXBvb2wgfHwgcG9vbC5sZW5ndGggLSBwb29sLnVzZWQgPCB0aGlzLmxlbmd0aCkgYWxsb2NQb29sKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHBvb2w7XG4gICAgICB0aGlzLm9mZnNldCA9IHBvb2wudXNlZDtcbiAgICAgIHBvb2wudXNlZCArPSB0aGlzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXkuXG4gICAgaWYgKGlzQXJyYXlJc2goc3ViamVjdCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnBhcmVudFtpICsgdGhpcy5vZmZzZXRdID0gc3ViamVjdFtpXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFdlIGFyZSBhIHN0cmluZ1xuICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpc0FycmF5SXNoKHN1YmplY3QpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cblxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcjtcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xuXG5CdWZmZXIucG9vbFNpemUgPSA4ICogMTAyNDtcbnZhciBwb29sO1xuXG5mdW5jdGlvbiBhbGxvY1Bvb2woKSB7XG4gIHBvb2wgPSBuZXcgU2xvd0J1ZmZlcihCdWZmZXIucG9vbFNpemUpO1xuICBwb29sLnVzZWQgPSAwO1xufVxuXG5cbi8vIFN0YXRpYyBtZXRob2RzXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlcihiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyIHx8IGIgaW5zdGFuY2VvZiBTbG93QnVmZmVyO1xufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVc2FnZTogQnVmZmVyLmNvbmNhdChsaXN0LCBbdG90YWxMZW5ndGhdKVxcbiBcXFxuICAgICAgbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuXCIpO1xuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMCk7XG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgICB0b3RhbExlbmd0aCArPSBidWYubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBidWYgPSBsaXN0W2ldO1xuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcblxuLy8gSW5zcGVjdFxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgICAgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXMucGFyZW50W2kgKyB0aGlzLm9mZnNldF0pO1xuICAgIGlmIChpID09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgb3V0LmpvaW4oJyAnKSArICc+Jztcbn07XG5cblxuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoaSkge1xuICBpZiAoaSA8IDAgfHwgaSA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgcmV0dXJuIHRoaXMucGFyZW50W3RoaXMub2Zmc2V0ICsgaV07XG59O1xuXG5cbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KGksIHYpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignb29iJyk7XG4gIHJldHVybiB0aGlzLnBhcmVudFt0aGlzLm9mZnNldCArIGldID0gdjtcbn07XG5cblxuLy8gd3JpdGUoc3RyaW5nLCBvZmZzZXQgPSAwLCBsZW5ndGggPSBidWZmZXIubGVuZ3RoLW9mZnNldCwgZW5jb2RpbmcgPSAndXRmOCcpXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGg7XG4gICAgICBsZW5ndGggPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBvZmZzZXQgPSBsZW5ndGg7XG4gICAgbGVuZ3RoID0gc3dhcDtcbiAgfVxuXG4gIG9mZnNldCA9ICtvZmZzZXQgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSArbGVuZ3RoO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpO1xuXG4gIHZhciByZXQ7XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuaGV4V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudXRmOFdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmFzY2lpV3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IHRoaXMucGFyZW50LmJpbmFyeVdyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQuYmFzZTY0V3JpdGUoc3RyaW5nLCB0aGlzLm9mZnNldCArIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0ID0gdGhpcy5wYXJlbnQudWNzMldyaXRlKHN0cmluZywgdGhpcy5vZmZzZXQgKyBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxuXG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gU2xvd0J1ZmZlci5fY2hhcnNXcml0dGVuO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5cbi8vIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHR5cGVvZiBzdGFydCA9PSAndW5kZWZpbmVkJyB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuZCA9PSAndW5kZWZpbmVkJyB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9IGVsc2UgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgPSAwO1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCArIHRoaXMub2Zmc2V0O1xuICBlbmQgPSBlbmQgKyB0aGlzLm9mZnNldDtcblxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC5oZXhTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldHVybiB0aGlzLnBhcmVudC51dGY4U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYXNjaWlTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuYmluYXJ5U2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmJhc2U2NFNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LnVjczJTbGljZShzdGFydCwgZW5kKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKTtcbiAgfVxufTtcblxuXG4vLyBieXRlTGVuZ3RoXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IFNsb3dCdWZmZXIuYnl0ZUxlbmd0aDtcblxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgdmFsdWUgfHwgKHZhbHVlID0gMCk7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgfVxuICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpO1xuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSB0aHJvdyBuZXcgRXJyb3IoJ2VuZCA8IHN0YXJ0Jyk7XG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMDtcbiAgaWYgKHRoaXMubGVuZ3RoID09IDApIHJldHVybiAwO1xuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMucGFyZW50LmZpbGwodmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24odGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG4gIHN0YXJ0IHx8IChzdGFydCA9IDApO1xuICBlbmQgfHwgKGVuZCA9IHRoaXMubGVuZ3RoKTtcbiAgdGFyZ2V0X3N0YXJ0IHx8ICh0YXJnZXRfc3RhcnQgPSAwKTtcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKTtcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PSAwIHx8IHNvdXJjZS5sZW5ndGggPT0gMCkgcmV0dXJuIDA7XG5cbiAgaWYgKHRhcmdldF9zdGFydCA8IDAgfHwgdGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpO1xuICB9XG5cbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKTtcbiAgfVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnBhcmVudC5jb3B5KHRhcmdldC5wYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldF9zdGFydCArIHRhcmdldC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ICsgdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCArIHRoaXMub2Zmc2V0KTtcbn07XG5cblxuLy8gc2xpY2Uoc3RhcnQsIGVuZClcbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkgZW5kID0gdGhpcy5sZW5ndGg7XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdvb2InKTtcbiAgaWYgKHN0YXJ0ID4gZW5kKSB0aHJvdyBuZXcgRXJyb3IoJ29vYicpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHRoaXMucGFyZW50LCBlbmQgLSBzdGFydCwgK3N0YXJ0ICsgdGhpcy5vZmZzZXQpO1xufTtcblxuXG4vLyBMZWdhY3kgbWV0aG9kcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5iaW5hcnlTbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIHRoaXMudG9TdHJpbmcoJ2JpbmFyeScsIHN0YXJ0LCBlbmQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5hc2NpaVNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy50b1N0cmluZygnYXNjaWknLCBzdGFydCwgZW5kKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUudXRmOFdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICd1dGY4Jyk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmJpbmFyeVdyaXRlID0gZnVuY3Rpb24oc3RyaW5nLCBvZmZzZXQpIHtcbiAgcmV0dXJuIHRoaXMud3JpdGUoc3RyaW5nLCBvZmZzZXQsICdiaW5hcnknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUuYXNjaWlXcml0ZSA9IGZ1bmN0aW9uKHN0cmluZywgb2Zmc2V0KSB7XG4gIHJldHVybiB0aGlzLndyaXRlKHN0cmluZywgb2Zmc2V0LCAnYXNjaWknKTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YXIgYnVmZmVyID0gdGhpcztcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRVSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgdmFsID0gMDtcblxuXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIHZhbCA9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV07XG4gIH0gZWxzZSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFyIHZhbCA9IDA7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKGlzQmlnRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgMTY7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDJdIDw8IDg7XG4gICAgdmFsIHw9IGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDNdO1xuICAgIHZhbCA9IHZhbCArIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdIDw8IDI0ID4+PiAwKTtcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA8PCAxNjtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPDwgODtcbiAgICB2YWwgfD0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICB2YWwgPSB2YWwgKyAoYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFNpZ25lZCBpbnRlZ2VyIHR5cGVzLCB5YXkgdGVhbSEgQSByZW1pbmRlciBvbiBob3cgdHdvJ3MgY29tcGxlbWVudCBhY3R1YWxseVxuICogd29ya3MuIFRoZSBmaXJzdCBiaXQgaXMgdGhlIHNpZ25lZCBiaXQsIGkuZS4gdGVsbHMgdXMgd2hldGhlciBvciBub3QgdGhlXG4gKiBudW1iZXIgc2hvdWxkIGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLiBJZiB0aGUgdHdvJ3MgY29tcGxlbWVudCB2YWx1ZSBpc1xuICogcG9zaXRpdmUsIHRoZW4gd2UncmUgZG9uZSwgYXMgaXQncyBlcXVpdmFsZW50IHRvIHRoZSB1bnNpZ25lZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBOb3cgaWYgdGhlIG51bWJlciBpcyBwb3NpdGl2ZSwgeW91J3JlIHByZXR0eSBtdWNoIGRvbmUsIHlvdSBjYW4ganVzdCBsZXZlcmFnZVxuICogdGhlIHVuc2lnbmVkIHRyYW5zbGF0aW9ucyBhbmQgcmV0dXJuIHRob3NlLiBVbmZvcnR1bmF0ZWx5LCBuZWdhdGl2ZSBudW1iZXJzXG4gKiBhcmVuJ3QgcXVpdGUgdGhhdCBzdHJhaWdodGZvcndhcmQuXG4gKlxuICogQXQgZmlyc3QgZ2xhbmNlLCBvbmUgbWlnaHQgYmUgaW5jbGluZWQgdG8gdXNlIHRoZSB0cmFkaXRpb25hbCBmb3JtdWxhIHRvXG4gKiB0cmFuc2xhdGUgYmluYXJ5IG51bWJlcnMgYmV0d2VlbiB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcyBpbiB0d28nc1xuICogY29tcGxlbWVudC4gKFRob3VnaCBpdCBkb2Vzbid0IHF1aXRlIHdvcmsgZm9yIHRoZSBtb3N0IG5lZ2F0aXZlIHZhbHVlKVxuICogTWFpbmx5OlxuICogIC0gaW52ZXJ0IGFsbCB0aGUgYml0c1xuICogIC0gYWRkIG9uZSB0byB0aGUgcmVzdWx0XG4gKlxuICogT2YgY291cnNlLCB0aGlzIGRvZXNuJ3QgcXVpdGUgd29yayBpbiBKYXZhc2NyaXB0LiBUYWtlIGZvciBleGFtcGxlIHRoZSB2YWx1ZVxuICogb2YgLTEyOC4gVGhpcyBjb3VsZCBiZSByZXByZXNlbnRlZCBpbiAxNiBiaXRzIChiaWctZW5kaWFuKSBhcyAweGZmODAuIEJ1dCBvZlxuICogY291cnNlLCBKYXZhc2NyaXB0IHdpbGwgZG8gdGhlIGZvbGxvd2luZzpcbiAqXG4gKiA+IH4weGZmODBcbiAqIC02NTQwOVxuICpcbiAqIFdob2ggdGhlcmUsIEphdmFzY3JpcHQsIHRoYXQncyBub3QgcXVpdGUgcmlnaHQuIEJ1dCB3YWl0LCBhY2NvcmRpbmcgdG9cbiAqIEphdmFzY3JpcHQgdGhhdCdzIHBlcmZlY3RseSBjb3JyZWN0LiBXaGVuIEphdmFzY3JpcHQgZW5kcyB1cCBzZWVpbmcgdGhlXG4gKiBjb25zdGFudCAweGZmODAsIGl0IGhhcyBubyBub3Rpb24gdGhhdCBpdCBpcyBhY3R1YWxseSBhIHNpZ25lZCBudW1iZXIuIEl0XG4gKiBhc3N1bWVzIHRoYXQgd2UndmUgaW5wdXQgdGhlIHVuc2lnbmVkIHZhbHVlIDB4ZmY4MC4gVGh1cywgd2hlbiBpdCBkb2VzIHRoZVxuICogYmluYXJ5IG5lZ2F0aW9uLCBpdCBjYXN0cyBpdCBpbnRvIGEgc2lnbmVkIHZhbHVlLCAocG9zaXRpdmUgMHhmZjgwKS4gVGhlblxuICogd2hlbiB5b3UgcGVyZm9ybSBiaW5hcnkgbmVnYXRpb24gb24gdGhhdCwgaXQgdHVybnMgaXQgaW50byBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSdyZSBnb2luZyB0byBoYXZlIHRvIHVzZSB0aGUgZm9sbG93aW5nIGdlbmVyYWwgZm9ybXVsYSwgdGhhdCB3b3Jrc1xuICogaW4gYSByYXRoZXIgSmF2YXNjcmlwdCBmcmllbmRseSB3YXkuIEknbSBnbGFkIHdlIGRvbid0IHN1cHBvcnQgdGhpcyBraW5kIG9mXG4gKiB3ZWlyZCBudW1iZXJpbmcgc2NoZW1lIGluIHRoZSBrZXJuZWwuXG4gKlxuICogKEJJVC1NQVggLSAodW5zaWduZWQpdmFsICsgMSkgKiAtMVxuICpcbiAqIFRoZSBhc3R1dGUgb2JzZXJ2ZXIsIG1heSB0aGluayB0aGF0IHRoaXMgZG9lc24ndCBtYWtlIHNlbnNlIGZvciA4LWJpdCBudW1iZXJzXG4gKiAocmVhbGx5IGl0IGlzbid0IG5lY2Vzc2FyeSBmb3IgdGhlbSkuIEhvd2V2ZXIsIHdoZW4geW91IGdldCAxNi1iaXQgbnVtYmVycyxcbiAqIHlvdSBkby4gTGV0J3MgZ28gYmFjayB0byBvdXIgcHJpb3IgZXhhbXBsZSBhbmQgc2VlIGhvdyB0aGlzIHdpbGwgbG9vazpcbiAqXG4gKiAoMHhmZmZmIC0gMHhmZjgwICsgMSkgKiAtMVxuICogKDB4MDA3ZiArIDEpICogLTFcbiAqICgweDAwODApICogLTFcbiAqL1xuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG4gIHZhciBuZWc7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgbmVnID0gYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0XSAmIDB4ODA7XG4gIGlmICghbmVnKSB7XG4gICAgcmV0dXJuIChidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdKTtcbiAgfVxuXG4gIHJldHVybiAoKDB4ZmYgLSBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXRdICsgMSkgKiAtMSk7XG59O1xuXG5mdW5jdGlvbiByZWFkSW50MTYoYnVmZmVyLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YXIgbmVnLCB2YWw7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFsID0gcmVhZFVJbnQxNihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgbmVnID0gdmFsICYgMHg4MDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMihidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhciBuZWcsIHZhbDtcblxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICB2YWwgPSByZWFkVUludDMyKGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICBuZWcgPSB2YWwgJiAweDgwMDAwMDAwO1xuICBpZiAoIW5lZykge1xuICAgIHJldHVybiAodmFsKTtcbiAgfVxuXG4gIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTE7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdChidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDIzLCA0KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydCk7XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gcmVhZERvdWJsZShidWZmZXIsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyA3IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG4gIH1cblxuICByZXR1cm4gcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLnJlYWRJRUVFNzU0KGJ1ZmZlciwgb2Zmc2V0LCBpc0JpZ0VuZGlhbixcbiAgICAgIDUyLCA4KTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbihvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24ob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0IGlzXG4gKiBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdCBleGNlZWQgdGhlXG4gKiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKlxuICogICAgICB2YWx1ZSAgICAgICAgICAgVGhlIG51bWJlciB0byBjaGVjayBmb3IgdmFsaWRpdHlcbiAqXG4gKiAgICAgIG1heCAgICAgICAgICAgICBUaGUgbWF4aW11bSB2YWx1ZVxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQodmFsdWUsIG1heCkge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSAwLFxuICAgICAgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKTtcblxuICBhc3NlcnQub2soTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKTtcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKTtcbiAgfVxuXG4gIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMSA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldCArIDFdID0gdmFsdWUgJiAweDAwZmY7XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmMDApID4+PiA4O1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4MDBmZjtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVVSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKTtcbiAgfVxuXG4gIGlmIChpc0JpZ0VuZGlhbikge1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSAodmFsdWUgPj4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyLnBhcmVudFtidWZmZXIub2Zmc2V0ICsgb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9IHZhbHVlICYgMHhmZjtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXIucGFyZW50W2J1ZmZlci5vZmZzZXQgKyBvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlci5wYXJlbnRbYnVmZmVyLm9mZnNldCArIG9mZnNldF0gPSB2YWx1ZSAmIDB4ZmY7XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cblxuLypcbiAqIFdlIG5vdyBtb3ZlIG9udG8gb3VyIGZyaWVuZHMgaW4gdGhlIHNpZ25lZCBudW1iZXIgY2F0ZWdvcnkuIFVubGlrZSB1bnNpZ25lZFxuICogbnVtYmVycywgd2UncmUgZ29pbmcgdG8gaGF2ZSB0byB3b3JyeSBhIGJpdCBtb3JlIGFib3V0IGhvdyB3ZSBwdXQgdmFsdWVzIGludG9cbiAqIGFycmF5cy4gU2luY2Ugd2UgYXJlIG9ubHkgd29ycnlpbmcgYWJvdXQgc2lnbmVkIDMyLWJpdCB2YWx1ZXMsIHdlJ3JlIGluXG4gKiBzbGlnaHRseSBiZXR0ZXIgc2hhcGUuIFVuZm9ydHVuYXRlbHksIHdlIHJlYWxseSBjYW4ndCBkbyBvdXIgZmF2b3JpdGUgYmluYXJ5XG4gKiAmIGluIHRoaXMgc3lzdGVtLiBJdCByZWFsbHkgc2VlbXMgdG8gZG8gdGhlIHdyb25nIHRoaW5nLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiA+IC0zMiAmIDB4ZmZcbiAqIDIyNFxuICpcbiAqIFdoYXQncyBoYXBwZW5pbmcgYWJvdmUgaXMgcmVhbGx5OiAweGUwICYgMHhmZiA9IDB4ZTAuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIG9mXG4gKiB0aGlzIGFyZW4ndCB0cmVhdGVkIGFzIGEgc2lnbmVkIG51bWJlci4gVWx0aW1hdGVseSBhIGJhZCB0aGluZy5cbiAqXG4gKiBXaGF0IHdlJ3JlIGdvaW5nIHRvIHdhbnQgdG8gZG8gaXMgYmFzaWNhbGx5IGNyZWF0ZSB0aGUgdW5zaWduZWQgZXF1aXZhbGVudCBvZlxuICogb3VyIHJlcHJlc2VudGF0aW9uIGFuZCBwYXNzIHRoYXQgb2ZmIHRvIHRoZSB3dWludCogZnVuY3Rpb25zLiBUbyBkbyB0aGF0XG4gKiB3ZSdyZSBnb2luZyB0byBkbyB0aGUgZm9sbG93aW5nOlxuICpcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBwb3NpdGl2ZVxuICogICAgICB3ZSBjYW4gcGFzcyBpdCBkaXJlY3RseSBvZmYgdG8gdGhlIGVxdWl2YWxlbnQgd3VpbnRcbiAqICAtIGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICogICAgICB3ZSBkbyB0aGUgZm9sbG93aW5nIGNvbXB1dGF0aW9uOlxuICogICAgICAgICBtYiArIHZhbCArIDEsIHdoZXJlXG4gKiAgICAgICAgIG1iICAgaXMgdGhlIG1heGltdW0gdW5zaWduZWQgdmFsdWUgaW4gdGhhdCBieXRlIHNpemVcbiAqICAgICAgICAgdmFsICBpcyB0aGUgSmF2YXNjcmlwdCBuZWdhdGl2ZSBpbnRlZ2VyXG4gKlxuICpcbiAqIEFzIGEgY29uY3JldGUgdmFsdWUsIHRha2UgLTEyOC4gSW4gc2lnbmVkIDE2IGJpdHMgdGhpcyB3b3VsZCBiZSAweGZmODAuIElmXG4gKiB5b3UgZG8gb3V0IHRoZSBjb21wdXRhdGlvbnM6XG4gKlxuICogMHhmZmZmIC0gMTI4ICsgMVxuICogMHhmZmZmIC0gMTI3XG4gKiAweGZmODBcbiAqXG4gKiBZb3UgY2FuIHRoZW4gZW5jb2RlIHRoaXMgdmFsdWUgYXMgdGhlIHNpZ25lZCB2ZXJzaW9uLiBUaGlzIGlzIHJlYWxseSByYXRoZXJcbiAqIGhhY2t5LCBidXQgaXQgc2hvdWxkIHdvcmsgYW5kIGdldCB0aGUgam9iIGRvbmUgd2hpY2ggaXMgb3VyIGdvYWwgaGVyZS5cbiAqL1xuXG4vKlxuICogQSBzZXJpZXMgb2YgY2hlY2tzIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIGEgc2lnbmVkIDMyLWJpdCBudW1iZXJcbiAqL1xuZnVuY3Rpb24gdmVyaWZzaW50KHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQub2sodHlwZW9mICh2YWx1ZSkgPT0gJ251bWJlcicsXG4gICAgICAnY2Fubm90IHdyaXRlIGEgbm9uLW51bWJlciBhcyBhIG51bWJlcicpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBsYXJnZXIgdGhhbiBtYXhpbXVtIGFsbG93ZWQgdmFsdWUnKTtcblxuICBhc3NlcnQub2sodmFsdWUgPj0gbWluLCAndmFsdWUgc21hbGxlciB0aGFuIG1pbmltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayhNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUsICd2YWx1ZSBoYXMgYSBmcmFjdGlvbmFsIGNvbXBvbmVudCcpO1xufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQodmFsdWUsIG1heCwgbWluKSB7XG4gIGFzc2VydC5vayh0eXBlb2YgKHZhbHVlKSA9PSAnbnVtYmVyJyxcbiAgICAgICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJyk7XG5cbiAgYXNzZXJ0Lm9rKHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpO1xuXG4gIGFzc2VydC5vayh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJyk7XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFyIGJ1ZmZlciA9IHRoaXM7XG5cbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIud3JpdGVVSW50OCgweGZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIG5vQXNzZXJ0KTtcbiAgfVxufTtcblxuZnVuY3Rpb24gd3JpdGVJbnQxNihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDEgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDE2KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQxNihidWZmZXIsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlSW50MzIoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0JpZ0VuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydC5vayh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyB2YWx1ZScpO1xuXG4gICAgYXNzZXJ0Lm9rKHR5cGVvZiAoaXNCaWdFbmRpYW4pID09PSAnYm9vbGVhbicsXG4gICAgICAgICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgKyAzIDwgYnVmZmVyLmxlbmd0aCxcbiAgICAgICAgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpO1xuXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMCk7XG4gIH1cblxuICBpZiAodmFsdWUgPj0gMCkge1xuICAgIHdyaXRlVUludDMyKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfSBlbHNlIHtcbiAgICB3cml0ZVVJbnQzMihidWZmZXIsIDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KTtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZsb2F0KGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNCaWdFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQub2sodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3NpbmcgdmFsdWUnKTtcblxuICAgIGFzc2VydC5vayh0eXBlb2YgKGlzQmlnRW5kaWFuKSA9PT0gJ2Jvb2xlYW4nLFxuICAgICAgICAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0Jyk7XG5cbiAgICBhc3NlcnQub2sob2Zmc2V0ICsgMyA8IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKTtcblxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgMjMsIDQpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KTtcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZURvdWJsZShidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0Lm9rKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIHZhbHVlJyk7XG5cbiAgICBhc3NlcnQub2sodHlwZW9mIChpc0JpZ0VuZGlhbikgPT09ICdib29sZWFuJyxcbiAgICAgICAgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKTtcblxuICAgIGFzc2VydC5vayhvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsXG4gICAgICAgICdtaXNzaW5nIG9mZnNldCcpO1xuXG4gICAgYXNzZXJ0Lm9rKG9mZnNldCArIDcgPCBidWZmZXIubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJyk7XG5cbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpO1xuICB9XG5cbiAgcmVxdWlyZSgnLi9idWZmZXJfaWVlZTc1NCcpLndyaXRlSUVFRTc1NChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzQmlnRW5kaWFuLFxuICAgICAgNTIsIDgpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbih2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpO1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24odmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpO1xufTtcblxuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50ODtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4O1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU7XG5TbG93QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFO1xuU2xvd0J1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IEJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRTtcblNsb3dCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkU7XG5cbn0pKClcbn0se1wiYXNzZXJ0XCI6MixcIi4vYnVmZmVyX2llZWU3NTRcIjo3LFwiYmFzZTY0LWpzXCI6OX1dLDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5KGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyO1xuXHRcblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyAnSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCc7XG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHBsYWNlSG9sZGVycyA9IGI2NC5pbmRleE9mKCc9Jyk7XG5cdFx0cGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSBwbGFjZUhvbGRlcnMgOiAwO1xuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gW107Ly9uZXcgVWludDhBcnJheShiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpO1xuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGxvb2t1cC5pbmRleE9mKGI2NFtpXSkgPDwgMTgpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pIDw8IDEyKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA8PCA2KSB8IGxvb2t1cC5pbmRleE9mKGI2NFtpICsgM10pO1xuXHRcdFx0YXJyLnB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNik7XG5cdFx0XHRhcnIucHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDIpIHwgKGxvb2t1cC5pbmRleE9mKGI2NFtpICsgMV0pID4+IDQpO1xuXHRcdFx0YXJyLnB1c2godG1wICYgMHhGRik7XG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChsb29rdXAuaW5kZXhPZihiNjRbaV0pIDw8IDEwKSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDFdKSA8PCA0KSB8IChsb29rdXAuaW5kZXhPZihiNjRbaSArIDJdKSA+PiAyKTtcblx0XHRcdGFyci5wdXNoKCh0bXAgPj4gOCkgJiAweEZGKTtcblx0XHRcdGFyci5wdXNoKHRtcCAmIDB4RkYpO1xuXHRcdH1cblxuXHRcdHJldHVybiBhcnI7XG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0KHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGg7XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdO1xuXHRcdH07XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKTtcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcCk7XG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbdGVtcCA+PiAyXTtcblx0XHRcdFx0b3V0cHV0ICs9IGxvb2t1cFsodGVtcCA8PCA0KSAmIDB4M0ZdO1xuXHRcdFx0XHRvdXRwdXQgKz0gJz09Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwW3RlbXAgPj4gMTBdO1xuXHRcdFx0XHRvdXRwdXQgKz0gbG9va3VwWyh0ZW1wID4+IDQpICYgMHgzRl07XG5cdFx0XHRcdG91dHB1dCArPSBsb29rdXBbKHRlbXAgPDwgMikgJiAweDNGXTtcblx0XHRcdFx0b3V0cHV0ICs9ICc9Jztcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdG1vZHVsZS5leHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXk7XG5cdG1vZHVsZS5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0O1xufSgpKTtcblxufSx7fV19LHt9LFtdKVxuOzttb2R1bGUuZXhwb3J0cz1yZXF1aXJlKFwiYnVmZmVyLWJyb3dzZXJpZnlcIilcbiIsIihmdW5jdGlvbihCdWZmZXIpey8vICAgICB1dWlkLmpzXG4vL1xuLy8gICAgIChjKSAyMDEwLTIwMTIgUm9iZXJ0IEtpZWZmZXJcbi8vICAgICBNSVQgTGljZW5zZVxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkXG4oZnVuY3Rpb24oKSB7XG4gIHZhciBfZ2xvYmFsID0gdGhpcztcblxuICAvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgV2UgZmVhdHVyZVxuICAvLyBkZXRlY3QgdG8gZGV0ZXJtaW5lIHRoZSBiZXN0IFJORyBzb3VyY2UsIG5vcm1hbGl6aW5nIHRvIGEgZnVuY3Rpb24gdGhhdFxuICAvLyByZXR1cm5zIDEyOC1iaXRzIG9mIHJhbmRvbW5lc3MsIHNpbmNlIHRoYXQncyB3aGF0J3MgdXN1YWxseSByZXF1aXJlZFxuICB2YXIgX3JuZztcblxuICAvLyBOb2RlLmpzIGNyeXB0by1iYXNlZCBSTkcgLSBodHRwOi8vbm9kZWpzLm9yZy9kb2NzL3YwLjYuMi9hcGkvY3J5cHRvLmh0bWxcbiAgLy9cbiAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgaWYgKHR5cGVvZihyZXF1aXJlKSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfcmIgPSByZXF1aXJlKCdjcnlwdG8nKS5yYW5kb21CeXRlcztcbiAgICAgIF9ybmcgPSBfcmIgJiYgZnVuY3Rpb24oKSB7cmV0dXJuIF9yYigxNik7fTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoIV9ybmcgJiYgX2dsb2JhbC5jcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIFdIQVRXRyBjcnlwdG8tYmFzZWQgUk5HIC0gaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0NyeXB0b1xuICAgIC8vXG4gICAgLy8gTW9kZXJhdGVseSBmYXN0LCBoaWdoIHF1YWxpdHlcbiAgICB2YXIgX3JuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIF9ybmcgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKF9ybmRzOCk7XG4gICAgICByZXR1cm4gX3JuZHM4O1xuICAgIH07XG4gIH1cblxuICBpZiAoIV9ybmcpIHtcbiAgICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gICAgLy9cbiAgICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAgIC8vIHF1YWxpdHkuXG4gICAgdmFyICBfcm5kcyA9IG5ldyBBcnJheSgxNik7XG4gICAgX3JuZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgIGlmICgoaSAmIDB4MDMpID09PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgICBfcm5kc1tpXSA9IHIgPj4+ICgoaSAmIDB4MDMpIDw8IDMpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9ybmRzO1xuICAgIH07XG4gIH1cblxuICAvLyBCdWZmZXIgY2xhc3MgdG8gdXNlXG4gIHZhciBCdWZmZXJDbGFzcyA9IHR5cGVvZihCdWZmZXIpID09ICdmdW5jdGlvbicgPyBCdWZmZXIgOiBBcnJheTtcblxuICAvLyBNYXBzIGZvciBudW1iZXIgPC0+IGhleCBzdHJpbmcgY29udmVyc2lvblxuICB2YXIgX2J5dGVUb0hleCA9IFtdO1xuICB2YXIgX2hleFRvQnl0ZSA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgX2J5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG4gICAgX2hleFRvQnl0ZVtfYnl0ZVRvSGV4W2ldXSA9IGk7XG4gIH1cblxuICAvLyAqKmBwYXJzZSgpYCAtIFBhcnNlIGEgVVVJRCBpbnRvIGl0J3MgY29tcG9uZW50IGJ5dGVzKipcbiAgZnVuY3Rpb24gcGFyc2UocywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IChidWYgJiYgb2Zmc2V0KSB8fCAwLCBpaSA9IDA7XG5cbiAgICBidWYgPSBidWYgfHwgW107XG4gICAgcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1swLTlhLWZdezJ9L2csIGZ1bmN0aW9uKG9jdCkge1xuICAgICAgaWYgKGlpIDwgMTYpIHsgLy8gRG9uJ3Qgb3ZlcmZsb3chXG4gICAgICAgIGJ1ZltpICsgaWkrK10gPSBfaGV4VG9CeXRlW29jdF07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBaZXJvIG91dCByZW1haW5pbmcgYnl0ZXMgaWYgc3RyaW5nIHdhcyBzaG9ydFxuICAgIHdoaWxlIChpaSA8IDE2KSB7XG4gICAgICBidWZbaSArIGlpKytdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgLy8gKipgdW5wYXJzZSgpYCAtIENvbnZlcnQgVVVJRCBieXRlIGFycmF5IChhbGEgcGFyc2UoKSkgaW50byBhIHN0cmluZyoqXG4gIGZ1bmN0aW9uIHVucGFyc2UoYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IG9mZnNldCB8fCAwLCBidGggPSBfYnl0ZVRvSGV4O1xuICAgIHJldHVybiAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gKyAnLScgK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV0gK1xuICAgICAgICAgICAgYnRoW2J1ZltpKytdXSArIGJ0aFtidWZbaSsrXV07XG4gIH1cblxuICAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4gIC8vXG4gIC8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4gIC8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbiAgLy8gcmFuZG9tICMncyB3ZSBuZWVkIHRvIGluaXQgbm9kZSBhbmQgY2xvY2tzZXFcbiAgdmFyIF9zZWVkQnl0ZXMgPSBfcm5nKCk7XG5cbiAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gIHZhciBfbm9kZUlkID0gW1xuICAgIF9zZWVkQnl0ZXNbMF0gfCAweDAxLFxuICAgIF9zZWVkQnl0ZXNbMV0sIF9zZWVkQnl0ZXNbMl0sIF9zZWVkQnl0ZXNbM10sIF9zZWVkQnl0ZXNbNF0sIF9zZWVkQnl0ZXNbNV1cbiAgXTtcblxuICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICB2YXIgX2Nsb2Nrc2VxID0gKF9zZWVkQnl0ZXNbNl0gPDwgOCB8IF9zZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuXG4gIC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuICB2YXIgX2xhc3RNU2VjcyA9IDAsIF9sYXN0TlNlY3MgPSAwO1xuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbiAgZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPSBudWxsID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAgIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gICAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICAgIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT0gbnVsbCA/IG9wdGlvbnMubXNlY3MgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuICAgIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICAgIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT0gbnVsbCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTtcblxuICAgIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gICAgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuICAgIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAgIC8vIHRpbWUgaW50ZXJ2YWxcbiAgICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT0gbnVsbCkge1xuICAgICAgbnNlY3MgPSAwO1xuICAgIH1cblxuICAgIC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcbiAgICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICAgIH1cblxuICAgIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gICAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7XG5cbiAgICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAgIC8vIGB0aW1lX2xvd2BcbiAgICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gICAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICAgIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgICAvLyBgdGltZV9taWRgXG4gICAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICAgIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gICAgYltpKytdID0gdG1oICYgMHhmZjtcblxuICAgIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gICAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICAgIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gICAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gICAgLy8gYGNsb2NrX3NlcV9sb3dgXG4gICAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gICAgLy8gYG5vZGVgXG4gICAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IDY7IG4rKykge1xuICAgICAgYltpICsgbl0gPSBub2RlW25dO1xuICAgIH1cblxuICAgIHJldHVybiBidWYgPyBidWYgOiB1bnBhcnNlKGIpO1xuICB9XG5cbiAgLy8gKipgdjQoKWAgLSBHZW5lcmF0ZSByYW5kb20gVVVJRCoqXG5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9icm9vZmEvbm9kZS11dWlkIGZvciBBUEkgZGV0YWlsc1xuICBmdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICAgIC8vIERlcHJlY2F0ZWQgLSAnZm9ybWF0JyBhcmd1bWVudCwgYXMgc3VwcG9ydGVkIGluIHYxLjJcbiAgICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcblxuICAgIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1ZiA9IG9wdGlvbnMgPT0gJ2JpbmFyeScgPyBuZXcgQnVmZmVyQ2xhc3MoMTYpIDogbnVsbDtcbiAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IF9ybmcpKCk7XG5cbiAgICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gICAgcm5kc1s2XSA9IChybmRzWzZdICYgMHgwZikgfCAweDQwO1xuICAgIHJuZHNbOF0gPSAocm5kc1s4XSAmIDB4M2YpIHwgMHg4MDtcblxuICAgIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICAgIGlmIChidWYpIHtcbiAgICAgIGZvciAodmFyIGlpID0gMDsgaWkgPCAxNjsgaWkrKykge1xuICAgICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWYgfHwgdW5wYXJzZShybmRzKTtcbiAgfVxuXG4gIC8vIEV4cG9ydCBwdWJsaWMgQVBJXG4gIHZhciB1dWlkID0gdjQ7XG4gIHV1aWQudjEgPSB2MTtcbiAgdXVpZC52NCA9IHY0O1xuICB1dWlkLnBhcnNlID0gcGFyc2U7XG4gIHV1aWQudW5wYXJzZSA9IHVucGFyc2U7XG4gIHV1aWQuQnVmZmVyQ2xhc3MgPSBCdWZmZXJDbGFzcztcblxuICBpZiAoX2dsb2JhbC5kZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIFB1Ymxpc2ggYXMgQU1EIG1vZHVsZVxuICAgIGRlZmluZShmdW5jdGlvbigpIHtyZXR1cm4gdXVpZDt9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YobW9kdWxlKSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIC8vIFB1Ymxpc2ggYXMgbm9kZS5qcyBtb2R1bGVcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHV1aWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHVibGlzaCBhcyBnbG9iYWwgKGluIGJyb3dzZXJzKVxuICAgIHZhciBfcHJldmlvdXNSb290ID0gX2dsb2JhbC51dWlkO1xuXG4gICAgLy8gKipgbm9Db25mbGljdCgpYCAtIChicm93c2VyIG9ubHkpIHRvIHJlc2V0IGdsb2JhbCAndXVpZCcgdmFyKipcbiAgICB1dWlkLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIF9nbG9iYWwudXVpZCA9IF9wcmV2aW91c1Jvb3Q7XG4gICAgICByZXR1cm4gdXVpZDtcbiAgICB9O1xuXG4gICAgX2dsb2JhbC51dWlkID0gdXVpZDtcbiAgfVxufSgpKTtcblxufSkocmVxdWlyZShcIl9fYnJvd3NlcmlmeV9idWZmZXJcIikuQnVmZmVyKSIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5uZWw7XG5cbmZ1bmN0aW9uIENoYW5uZWwoc29ja2V0KSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuICB0aGlzLm1lc3NhZ2VzID0gbmV3IE1lc3NhZ2VzO1xuXG4gIHZhciBjaGFubmVsID0gdGhpcztcbiAgdmFyIG9ubWVzc2FnZSA9IHNvY2tldC5vbm1lc3NhZ2U7XG4gIHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5yYWNlcikgcmV0dXJuIGNoYW5uZWwuX29uTWVzc2FnZShkYXRhKTtcbiAgICBvbm1lc3NhZ2UgJiYgb25tZXNzYWdlLmNhbGwoc29ja2V0LCBkYXRhKTtcbiAgfTtcbn1cblxudXRpbC5tZXJnZUludG8oQ2hhbm5lbC5wcm90b3R5cGUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuXG5DaGFubmVsLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgY2IpIHtcbiAgdmFyIG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzLmFkZChuYW1lLCBkYXRhLCBjYik7XG4gIC8vIFByb2FjdGl2ZWx5IGNhbGwgdGhlIHRvSlNPTiBmdW5jdGlvbiwgc2luY2UgdGhlIEdvb2dsZSBDbG9zdXJlIEpTT05cbiAgLy8gc2VyaWFsaXplciBkb2Vzbid0IGNoZWNrIGZvciBpdFxuICB0aGlzLnNvY2tldC5zZW5kKG1lc3NhZ2UudG9KU09OKCkpO1xufTtcblxuQ2hhbm5lbC5wcm90b3R5cGUuX3JlcGx5ID0gZnVuY3Rpb24oaWQsIG5hbWUsIGRhdGEpIHtcbiAgdmFyIG1lc3NhZ2UgPSBuZXcgTWVzc2FnZShpZCwgdHJ1ZSwgbmFtZSwgZGF0YSk7XG4gIHRoaXMuc29ja2V0LnNlbmQobWVzc2FnZS50b0pTT04oKSk7XG59O1xuXG5DaGFubmVsLnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24oZGF0YSkge1xuICBpZiAoZGF0YS5hY2spIHtcbiAgICB2YXIgbWVzc2FnZSA9IHRoaXMubWVzc2FnZXMucmVtb3ZlKGRhdGEuaWQpO1xuICAgIGlmIChtZXNzYWdlICYmIG1lc3NhZ2UuY2IpIG1lc3NhZ2UuY2IuYXBwbHkoZGF0YS5kYXRhKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBkYXRhLnJhY2VyO1xuICBpZiAoZGF0YS5jYikge1xuICAgIHZhciBjaGFubmVsID0gdGhpcztcbiAgICB2YXIgaGFzTGlzdGVuZXJzID0gdGhpcy5lbWl0KG5hbWUsIGRhdGEuZGF0YSwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBjaGFubmVsLl9yZXBseShkYXRhLmlkLCBuYW1lLCBhcmdzKTtcbiAgICB9KTtcbiAgICBpZiAoIWhhc0xpc3RlbmVycykgdGhpcy5fcmVwbHkoZGF0YS5pZCwgbmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5lbWl0KG5hbWUsIGRhdGEuZGF0YSk7XG4gICAgdGhpcy5fcmVwbHkoZGF0YS5pZCwgbmFtZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIE1lc3NhZ2VzTWFwKCkge31cblxuZnVuY3Rpb24gTWVzc2FnZXMoKSB7XG4gIHRoaXMubWFwID0gbmV3IE1lc3NhZ2VzTWFwKCk7XG4gIHRoaXMuaWRDb3VudCA9IDA7XG59XG5NZXNzYWdlcy5wcm90b3R5cGUuaWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICgrK3RoaXMuaWRDb3VudCkudG9TdHJpbmcoMzYpO1xufTtcbk1lc3NhZ2VzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBjYikge1xuICB2YXIgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKHRoaXMuaWQoKSwgZmFsc2UsIG5hbWUsIGRhdGEsIGNiKTtcbiAgdGhpcy5tYXBbbWVzc2FnZS5pZF0gPSBtZXNzYWdlO1xuICByZXR1cm4gbWVzc2FnZTtcbn07XG5NZXNzYWdlcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIG1lc3NhZ2UgPSB0aGlzLm1hcFtpZF07XG4gIGRlbGV0ZSB0aGlzLm1hcFtpZF07XG4gIHJldHVybiBtZXNzYWdlO1xufTtcblxuZnVuY3Rpb24gTWVzc2FnZShpZCwgYWNrLCBuYW1lLCBkYXRhLCBjYikge1xuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuYWNrID0gYWNrO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNiID0gY2I7XG59XG5NZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByYWNlcjogdGhpcy5uYW1lXG4gICwgaWQ6IHRoaXMuaWRcbiAgLCBkYXRhOiB0aGlzLmRhdGFcbiAgLCBhY2s6ICt0aGlzLmFja1xuICAsIGNiOiAodGhpcy5jYikgPyAxIDogMFxuICB9O1xufTtcbiIsInZhciBEb2MgPSByZXF1aXJlKCcuL0RvYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvY2FsRG9jO1xuXG5mdW5jdGlvbiBMb2NhbERvYyhjb2xsZWN0aW9uTmFtZSwgaWQsIHNuYXBzaG90KSB7XG4gIERvYy5jYWxsKHRoaXMsIGNvbGxlY3Rpb25OYW1lLCBpZCk7XG4gIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcbn1cblxuTG9jYWxEb2MucHJvdG90eXBlID0gbmV3IERvYztcblxuTG9jYWxEb2MucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCB2YWx1ZSwgY2IpIHtcbiAgZnVuY3Rpb24gc2V0KG5vZGUsIGtleSkge1xuICAgIHZhciBwcmV2aW91cyA9IG5vZGVba2V5XTtcbiAgICBub2RlW2tleV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FwcGx5KHNlZ21lbnRzLCBzZXQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgdW5kZWZpbmVkLCBzaW5jZVxuICAvLyBhcHBseSBjcmVhdGVzIG9iamVjdHMgYXMgaXQgdHJhdmVyc2VzLCBhbmQgdGhlIGRlbCBtZXRob2RcbiAgLy8gc2hvdWxkIG5vdCBjcmVhdGUgYW55dGhpbmdcbiAgdmFyIHByZXZpb3VzID0gdGhpcy5nZXQoc2VnbWVudHMpO1xuICBpZiAocHJldmlvdXMgPT09IHZvaWQgMCkge1xuICAgIGNiKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZ1bmN0aW9uIGRlbChub2RlLCBrZXkpIHtcbiAgICBkZWxldGUgbm9kZVtrZXldO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fYXBwbHkoc2VnbWVudHMsIGRlbCwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBieU51bWJlciwgY2IpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBmdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlID09IG51bGwpIHJldHVybjtcbiAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihzZWxmLl9lcnJvck1lc3NhZ2UoXG4gICAgICAnaW5jcmVtZW50IG9uIG5vbi1udW1iZXInLCBzZWdtZW50cywgdmFsdWVcbiAgICApKTtcbiAgfVxuICBmdW5jdGlvbiBpbmNyZW1lbnQobm9kZSwga2V5KSB7XG4gICAgdmFyIHZhbHVlID0gKG5vZGVba2V5XSB8fCAwKSArIGJ5TnVtYmVyO1xuICAgIG5vZGVba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkQXBwbHkoc2VnbWVudHMsIHZhbGlkYXRlLCBpbmNyZW1lbnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBmdW5jdGlvbiBwdXNoKGFycikge1xuICAgIHJldHVybiBhcnIucHVzaCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHB1c2gsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBmdW5jdGlvbiB1bnNoaWZ0KGFycikge1xuICAgIHJldHVybiBhcnIudW5zaGlmdCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHVuc2hpZnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIHZhbHVlcywgY2IpIHtcbiAgZnVuY3Rpb24gaW5zZXJ0KGFycikge1xuICAgIGFyci5zcGxpY2UuYXBwbHkoYXJyLCBbaW5kZXgsIDBdLmNvbmNhdCh2YWx1ZXMpKTtcbiAgICByZXR1cm4gYXJyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgaW5zZXJ0LCBjYik7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oc2VnbWVudHMsIGNiKSB7XG4gIGZ1bmN0aW9uIHBvcChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnBvcCgpO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCBwb3AsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBjYikge1xuICBmdW5jdGlvbiBzaGlmdChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnNoaWZ0KCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHNoaWZ0LCBjYik7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYikge1xuICBmdW5jdGlvbiByZW1vdmUoYXJyKSB7XG4gICAgcmV0dXJuIGFyci5zcGxpY2UoaW5kZXgsIGhvd01hbnkpO1xuICB9XG4gIHJldHVybiB0aGlzLl9hcnJheUFwcGx5KHNlZ21lbnRzLCByZW1vdmUsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGZyb20sIHRvLCBob3dNYW55LCBjYikge1xuICBmdW5jdGlvbiBtb3ZlKGFycikge1xuICAgIC8vIFJlbW92ZSBmcm9tIG9sZCBsb2NhdGlvblxuICAgIHZhciB2YWx1ZXMgPSBhcnIuc3BsaWNlKGZyb20sIGhvd01hbnkpO1xuICAgIC8vIEluc2VydCBpbiBuZXcgbG9jYXRpb25cbiAgICBhcnIuc3BsaWNlLmFwcGx5KGFyciwgW3RvLCAwXS5jb25jYXQodmFsdWVzKSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgbW92ZSwgY2IpO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLnN0cmluZ0luc2VydCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PSBudWxsKSByZXR1cm47XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3Ioc2VsZi5fZXJyb3JNZXNzYWdlKFxuICAgICAgJ3N0cmluZ0luc2VydCBvbiBub24tc3RyaW5nJywgc2VnbWVudHMsIHZhbHVlXG4gICAgKSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5nSW5zZXJ0KG5vZGUsIGtleSkge1xuICAgIHZhciBwcmV2aW91cyA9IG5vZGVba2V5XTtcbiAgICBpZiAocHJldmlvdXMgPT0gbnVsbCkge1xuICAgICAgbm9kZVtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgfVxuICAgIG5vZGVba2V5XSA9IHByZXZpb3VzLnNsaWNlKDAsIGluZGV4KSArIHZhbHVlICsgcHJldmlvdXMuc2xpY2UoaW5kZXgpO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkQXBwbHkoc2VnbWVudHMsIHZhbGlkYXRlLCBzdHJpbmdJbnNlcnQsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PSBudWxsKSByZXR1cm47XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3Ioc2VsZi5fZXJyb3JNZXNzYWdlKFxuICAgICAgJ3N0cmluZ1JlbW92ZSBvbiBub24tc3RyaW5nJywgc2VnbWVudHMsIHZhbHVlXG4gICAgKSk7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5nUmVtb3ZlKG5vZGUsIGtleSkge1xuICAgIHZhciBwcmV2aW91cyA9IG5vZGVba2V5XTtcbiAgICBpZiAocHJldmlvdXMgPT0gbnVsbCkgcmV0dXJuIHByZXZpb3VzO1xuICAgIGlmIChpbmRleCA8IDApIGluZGV4ICs9IHByZXZpb3VzLmxlbmd0aDtcbiAgICBub2RlW2tleV0gPSBwcmV2aW91cy5zbGljZSgwLCBpbmRleCkgKyBwcmV2aW91cy5zbGljZShpbmRleCArIGhvd01hbnkpO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICByZXR1cm4gdGhpcy5fdmFsaWRhdGVkQXBwbHkoc2VnbWVudHMsIHZhbGlkYXRlLCBzdHJpbmdSZW1vdmUsIGNiKTtcbn07XG5cbkxvY2FsRG9jLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihzZWdtZW50cykge1xuICByZXR1cm4gdGhpcy5fZ2V0KHRoaXMuc25hcHNob3QsIHNlZ21lbnRzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gc2VnbWVudHMgaXMgdGhlIGFycmF5IHJlcHJlc2VudGluZyBhIHBhdGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuKG5vZGUsIGtleSkgYXBwbGllcyBhIG11dGF0aW9uIG9uIG5vZGVba2V5XVxuICogQHJldHVybiB7T2JqZWN0fSByZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgb2YgZm4obm9kZSwga2V5KVxuICovXG5Mb2NhbERvYy5wcm90b3R5cGUuX2NyZWF0ZUltcGxpZWQgPSBmdW5jdGlvbihzZWdtZW50cywgZm4pIHtcbiAgdmFyIG5vZGUgPSB0aGlzO1xuICB2YXIga2V5ID0gJ3NuYXBzaG90JztcbiAgdmFyIGkgPSAwO1xuICB2YXIgbmV4dEtleSA9IHNlZ21lbnRzW2krK107XG4gIHdoaWxlIChuZXh0S2V5ICE9IG51bGwpIHtcbiAgICAvLyBHZXQgb3IgY3JlYXRlIGltcGxpZWQgb2JqZWN0IG9yIGFycmF5XG4gICAgbm9kZSA9IG5vZGVba2V5XSB8fCAobm9kZVtrZXldID0gL15cXGQrJC8udGVzdChuZXh0S2V5KSA/IFtdIDoge30pO1xuICAgIGtleSA9IG5leHRLZXk7XG4gICAgbmV4dEtleSA9IHNlZ21lbnRzW2krK107XG4gIH1cbiAgcmV0dXJuIGZuKG5vZGUsIGtleSk7XG59O1xuXG5Mb2NhbERvYy5wcm90b3R5cGUuX2FwcGx5ID0gZnVuY3Rpb24oc2VnbWVudHMsIGZuLCBjYikge1xuICB2YXIgb3V0ID0gdGhpcy5fY3JlYXRlSW1wbGllZChzZWdtZW50cywgZm4pO1xuICBjYigpO1xuICByZXR1cm4gb3V0O1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLl92YWxpZGF0ZWRBcHBseSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCB2YWxpZGF0ZSwgZm4sIGNiKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzLCBmdW5jdGlvbihub2RlLCBrZXkpIHtcbiAgICB2YXIgZXJyID0gdmFsaWRhdGUobm9kZVtrZXldKTtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICB2YXIgb3V0ID0gZm4obm9kZSwga2V5KTtcbiAgICBjYigpO1xuICAgIHJldHVybiBvdXQ7XG4gIH0pO1xufTtcblxuTG9jYWxEb2MucHJvdG90eXBlLl9hcnJheUFwcGx5ID0gZnVuY3Rpb24oc2VnbWVudHMsIGZuLCBjYikge1xuICAvLyBMb29rdXAgYSBwb2ludGVyIHRvIHRoZSBwcm9wZXJ0eSBvciBuZXN0ZWQgcHJvcGVydHkgJlxuICAvLyByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUgb3IgY3JlYXRlIGEgbmV3IGFycmF5XG4gIHZhciBhcnIgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzLCBub2RlQ3JlYXRlQXJyYXkpO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9lcnJvck1lc3NhZ2UoZm4ubmFtZSArICcgb24gbm9uLWFycmF5Jywgc2VnbWVudHMsIGFycik7XG4gICAgdmFyIGVyciA9IG5ldyBUeXBlRXJyb3IobWVzc2FnZSk7XG4gICAgcmV0dXJuIGNiKGVycik7XG4gIH1cbiAgdmFyIG91dCA9IGZuKGFycik7XG4gIGNiKCk7XG4gIHJldHVybiBvdXQ7XG59O1xuXG5mdW5jdGlvbiBub2RlQ3JlYXRlQXJyYXkobm9kZSwga2V5KSB7XG4gIHJldHVybiBub2RlW2tleV0gfHwgKG5vZGVba2V5XSA9IFtdKTtcbn1cbiIsIi8qKlxuICogUmVtb3RlRG9jIGFkYXB0cyB0aGUgU2hhcmVKUyBvcGVyYXRpb24gcHJvdG9jb2wgdG8gUmFjZXIncyBtdXRhdG9yXG4gKiBpbnRlcmZhY2UuXG4gKlxuICogMS4gSXQgbWFwcyBSYWNlcidzIG11dGF0b3IgbWV0aG9kcyB0byBvdXRnb2luZyBTaGFyZUpTIG9wZXJhdGlvbnMuXG4gKiAyLiBJdCBtYXBzIGluY29taW5nIFNoYXJlSlMgb3BlcmF0aW9ucyB0byBSYWNlciBldmVudHMuXG4gKi9cblxudmFyIERvYyA9IHJlcXVpcmUoJy4vRG9jJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVtb3RlRG9jO1xuXG5mdW5jdGlvbiBSZW1vdGVEb2MoY29sbGVjdGlvbk5hbWUsIGlkLCBkYXRhLCBtb2RlbCkge1xuICBEb2MuY2FsbCh0aGlzLCBjb2xsZWN0aW9uTmFtZSwgaWQpO1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnNoYXJlRG9jID0gbW9kZWwuX2dldE9yQ3JlYXRlU2hhcmVEb2MoY29sbGVjdGlvbk5hbWUsIGlkLCBkYXRhKTtcbiAgdGhpcy5jcmVhdGVkTG9jYWxseSA9IGZhbHNlO1xuICB0aGlzLm1vZGVsID0gbW9kZWwgPSBtb2RlbC5wYXNzKHskcmVtb3RlOiB0cnVlfSk7XG4gIHRoaXMuX3Bhc3NTdHJpbmdJbnNlcnQgPSBtb2RlbC5wYXNzKHskb3JpZ2luYWw6ICdzdHJpbmdJbnNlcnQnfSkuX3Bhc3M7XG4gIHRoaXMuX3Bhc3NTdHJpbmdSZW1vdmUgPSBtb2RlbC5wYXNzKHskb3JpZ2luYWw6ICdzdHJpbmdSZW1vdmUnfSkuX3Bhc3M7XG5cbiAgdmFyIGRvYyA9IHRoaXM7XG4gIHNoYXJlRG9jLm9uKCdvcCcsIGZ1bmN0aW9uKG9wLCBpc0xvY2FsKSB7XG4gICAgLy8gRG9uJ3QgZW1pdCBvbiBsb2NhbCBvcGVyYXRpb25zLCBzaW5jZSB0aGV5IGFyZSBlbWl0dGVkIGluIHRoZSBtdXRhdG9yXG4gICAgaWYgKGlzTG9jYWwpIHJldHVybjtcbiAgICBkb2MuX29uT3Aob3ApO1xuICB9KTtcbiAgc2hhcmVEb2Mub24oJ2RlbCcsIGZ1bmN0aW9uKGlzTG9jYWwsIHByZXZpb3VzKSB7XG4gICAgLy8gQ2FsbGluZyB0aGUgc2hhcmVEb2MuZGVsIG1ldGhvZCBkb2VzIG5vdCBlbWl0IGFuIG9wZXJhdGlvbiBldmVudCxcbiAgICAvLyBzbyB3ZSBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIGV2ZW50IGhlcmUuXG4gICAgaWYgKGlzTG9jYWwpIHJldHVybjtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBbY29sbGVjdGlvbk5hbWUsIGlkXSwgW3ZvaWQgMCwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gIH0pO1xuICBzaGFyZURvYy5vbignY3JlYXRlJywgZnVuY3Rpb24oaXNMb2NhbCkge1xuICAgIC8vIExvY2FsIGNyZWF0ZXMgc2hvdWxkIG5vdCBlbWl0IGFuIGV2ZW50LCBzaW5jZSB0aGV5IG9ubHkgaGFwcGVuXG4gICAgLy8gaW1wbGljaXRseSBhcyBhIHJlc3VsdCBvZiBhbm90aGVyIG11dGF0aW9uLCBhbmQgdGhhdCBvcGVyYXRpb24gd2lsbFxuICAgIC8vIGVtaXQgdGhlIGFwcHJvcHJpYXRlIGV2ZW50LiBSZW1vdGUgY3JlYXRlcyBjYW4gc2V0IHRoZSBzbmFwc2hvdCBkYXRhXG4gICAgLy8gd2l0aG91dCBlbWl0dGluZyBhbiBvcGVyYXRpb24gZXZlbnQsIHNvIGFuIGV2ZW50IG5lZWRzIHRvIGJlIGVtaXR0ZWRcbiAgICAvLyBmb3IgdGhlbS5cbiAgICBpZiAoaXNMb2NhbCkge1xuICAgICAgLy8gVHJhY2sgd2hlbiBhIGRvY3VtZW50IHdhcyBjcmVhdGVkIGJ5IHRoaXMgY2xpZW50LCBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAvLyBlbWl0IGEgbG9hZCBldmVudCB3aGVuIHN1YnNlcXVlbnRseSBzdWJzY3JpYmVkXG4gICAgICBkb2MuY3JlYXRlZExvY2FsbHkgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgdmFyIHZhbHVlID0gc2hhcmVEb2Muc25hcHNob3Q7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgW2NvbGxlY3Rpb25OYW1lLCBpZF0sIFt2YWx1ZSwgdm9pZCAwLCBtb2RlbC5fcGFzc10pO1xuICB9KTtcbn1cblxuUmVtb3RlRG9jLnByb3RvdHlwZSA9IG5ldyBEb2M7XG5cblJlbW90ZURvYy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oc2VnbWVudHMsIHZhbHVlLCBjYikge1xuICBpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwICYmICF0aGlzLnNoYXJlRG9jLnR5cGUpIHtcbiAgICB0aGlzLnNoYXJlRG9jLmNyZWF0ZSgnanNvbjAnLCB2YWx1ZSwgY2IpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcHJldmlvdXMgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzKTtcbiAgdmFyIGxhc3RTZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gIHZhciBvcCA9IChpc0FycmF5SW5kZXgobGFzdFNlZ21lbnQpKSA/XG4gICAgKHByZXZpb3VzID09IG51bGwpID9cbiAgICAgIFtuZXcgTGlzdEluc2VydE9wKHNlZ21lbnRzLnNsaWNlKDAsIC0xKSwgbGFzdFNlZ21lbnQsIHZhbHVlKV0gOlxuICAgICAgW25ldyBMaXN0UmVwbGFjZU9wKHNlZ21lbnRzLnNsaWNlKDAsIC0xKSwgbGFzdFNlZ21lbnQsIHByZXZpb3VzLCB2YWx1ZSldIDpcbiAgICAocHJldmlvdXMgPT0gbnVsbCkgP1xuICAgICAgW25ldyBPYmplY3RJbnNlcnRPcChzZWdtZW50cywgdmFsdWUpXSA6XG4gICAgICBbbmV3IE9iamVjdFJlcGxhY2VPcChzZWdtZW50cywgcHJldmlvdXMsIHZhbHVlKV07XG4gIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3AsIGNiKTtcbiAgcmV0dXJuIHByZXZpb3VzO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBwcmV2aW91cyA9IHRoaXMuZ2V0KCk7XG4gICAgdGhpcy5zaGFyZURvYy5kZWwoY2IpO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfVxuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiB0aGUgdmFsdWUgaXMgYWxyZWFkeSB1bmRlZmluZWQsIHNpbmNlXG4gIC8vIHRoZSBkZWwgbWV0aG9kIHNob3VsZCBub3QgY3JlYXRlIGFueXRoaW5nXG4gIHZhciBwcmV2aW91cyA9IHRoaXMuZ2V0KHNlZ21lbnRzKTtcbiAgaWYgKHByZXZpb3VzID09PSB2b2lkIDApIHtcbiAgICBjYigpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgb3AgPSBbbmV3IE9iamVjdERlbGV0ZU9wKHNlZ21lbnRzLCBwcmV2aW91cyldO1xuICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBjYik7XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24oc2VnbWVudHMsIGJ5TnVtYmVyLCBjYikge1xuICB2YXIgcHJldmlvdXMgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzKTtcbiAgaWYgKHByZXZpb3VzID09IG51bGwpIHtcbiAgICB2YXIgbGFzdFNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgb3AgPSAoaXNBcnJheUluZGV4KGxhc3RTZWdtZW50KSkgP1xuICAgICAgW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBsYXN0U2VnbWVudCwgYnlOdW1iZXIpXSA6XG4gICAgICBbbmV3IE9iamVjdEluc2VydE9wKHNlZ21lbnRzLCBieU51bWJlcildO1xuICAgIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3AsIGNiKTtcbiAgICByZXR1cm4gYnlOdW1iZXI7XG4gIH1cbiAgdmFyIG9wID0gW25ldyBJbmNyZW1lbnRPcChzZWdtZW50cywgYnlOdW1iZXIpXTtcbiAgdGhpcy5zaGFyZURvYy5zdWJtaXRPcChvcCwgY2IpO1xuICByZXR1cm4gcHJldmlvdXMgKyBieU51bWJlcjtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCB2YWx1ZSwgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gcHVzaChhcnIsIGZuQ2IpIHtcbiAgICB2YXIgb3AgPSBbbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cywgYXJyLmxlbmd0aCwgdmFsdWUpXTtcbiAgICBzaGFyZURvYy5zdWJtaXRPcChvcCwgZm5DYik7XG4gICAgcmV0dXJuIGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHB1c2gsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCB2YWx1ZSwgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gdW5zaGlmdChhcnIsIGZuQ2IpIHtcbiAgICB2YXIgb3AgPSBbbmV3IExpc3RJbnNlcnRPcChzZWdtZW50cywgMCwgdmFsdWUpXTtcbiAgICBzaGFyZURvYy5zdWJtaXRPcChvcCwgZm5DYik7XG4gICAgcmV0dXJuIGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHVuc2hpZnQsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCB2YWx1ZXMsIGNiKSB7XG4gIHZhciBzaGFyZURvYyA9IHRoaXMuc2hhcmVEb2M7XG4gIGZ1bmN0aW9uIGluc2VydChhcnIsIGZuQ2IpIHtcbiAgICB2YXIgb3AgPSAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSA/XG4gICAgICBlYWNoT3AoTGlzdEluc2VydE9wLCBzZWdtZW50cywgaW5kZXgsIHZhbHVlcykgOlxuICAgICAgW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZXMpXTtcbiAgICBzaGFyZURvYy5zdWJtaXRPcChvcCwgZm5DYik7XG4gICAgcmV0dXJuIGFyci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIGluc2VydCwgY2IpO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbihzZWdtZW50cywgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gcG9wKGFyciwgZm5DYikge1xuICAgIHZhciBpbmRleCA9IGFyci5sZW5ndGggLSAxO1xuICAgIHZhciB2YWx1ZSA9IGFycltpbmRleF07XG4gICAgdmFyIG9wID0gW25ldyBMaXN0UmVtb3ZlT3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZSldO1xuICAgIHNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBmbkNiKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHBvcCwgY2IpO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBjYikge1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnNoYXJlRG9jO1xuICBmdW5jdGlvbiBzaGlmdChhcnIsIGZuQ2IpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJbMF07XG4gICAgdmFyIG9wID0gW25ldyBMaXN0UmVtb3ZlT3Aoc2VnbWVudHMsIDAsIHZhbHVlKV07XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgc2hpZnQsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oc2VnbWVudHMsIGluZGV4LCBob3dNYW55LCBjYikge1xuICB2YXIgc2hhcmVEb2MgPSB0aGlzLnNoYXJlRG9jO1xuICBmdW5jdGlvbiByZW1vdmUoYXJyLCBmbkNiKSB7XG4gICAgdmFyIHZhbHVlcyA9IGFyci5zbGljZShpbmRleCwgaW5kZXggKyBob3dNYW55KTtcbiAgICB2YXIgb3AgPSBlYWNoT3AoTGlzdFJlbW92ZU9wLCBzZWdtZW50cywgaW5kZXgsIHZhbHVlcyk7XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FycmF5QXBwbHkoc2VnbWVudHMsIHJlbW92ZSwgY2IpO1xufTtcblxuZnVuY3Rpb24gZWFjaE9wKENvbnN0cnVjdG9yLCBzZWdtZW50cywgaW5kZXgsIHZhbHVlcykge1xuICB2YXIgb3AgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbHVlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIG9wLnB1c2gobmV3IENvbnN0cnVjdG9yKHNlZ21lbnRzLCBpbmRleCsrLCB2YWx1ZXNbaV0pKTtcbiAgfVxuICByZXR1cm4gb3A7XG59XG5cblJlbW90ZURvYy5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHNlZ21lbnRzLCBmcm9tLCB0bywgaG93TWFueSwgY2IpIHtcbiAgdmFyIHNoYXJlRG9jID0gdGhpcy5zaGFyZURvYztcbiAgZnVuY3Rpb24gbW92ZShhcnIsIGZuQ2IpIHtcbiAgICAvLyBHZXQgdGhlIHJldHVybiB2YWx1ZVxuICAgIHZhciB2YWx1ZXMgPSBhcnIuc2xpY2UoZnJvbSwgZnJvbSArIGhvd01hbnkpO1xuXG4gICAgLy8gQnVpbGQgYW4gb3AgdGhhdCBtb3ZlcyBlYWNoIGl0ZW0gaW5kaXZpZHVhbGx5XG4gICAgdmFyIG9wID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3dNYW55OyBpKyspIHtcbiAgICAgIG9wLnB1c2gobmV3IExpc3RNb3ZlT3Aoc2VnbWVudHMsIGZyb20sIChmcm9tIDwgdG8pID8gdG8gOiB0byArIGkpKTtcbiAgICB9XG4gICAgc2hhcmVEb2Muc3VibWl0T3Aob3AsIGZuQ2IpO1xuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXlBcHBseShzZWdtZW50cywgbW92ZSwgY2IpO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5zdHJpbmdJbnNlcnQgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIHZhbHVlLCBjYikge1xuICB2YXIgcHJldmlvdXMgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzKTtcbiAgaWYgKHByZXZpb3VzID09IG51bGwpIHtcbiAgICB2YXIgbGFzdFNlZ21lbnQgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgb3AgPSAoaXNBcnJheUluZGV4KGxhc3RTZWdtZW50KSkgP1xuICAgICAgW25ldyBMaXN0SW5zZXJ0T3Aoc2VnbWVudHMuc2xpY2UoMCwgLTEpLCBsYXN0U2VnbWVudCwgdmFsdWUpXSA6XG4gICAgICBbbmV3IE9iamVjdEluc2VydE9wKHNlZ21lbnRzLCB2YWx1ZSldO1xuICAgIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3AsIGNiKTtcbiAgICByZXR1cm4gcHJldmlvdXM7XG4gIH1cbiAgdmFyIG9wID0gW25ldyBTdHJpbmdJbnNlcnRPcChzZWdtZW50cywgaW5kZXgsIHZhbHVlKV07XG4gIHRoaXMuc2hhcmVEb2Muc3VibWl0T3Aob3AsIGNiKTtcbiAgcmV0dXJuIHByZXZpb3VzO1xufTtcblxuUmVtb3RlRG9jLnByb3RvdHlwZS5zdHJpbmdSZW1vdmUgPSBmdW5jdGlvbihzZWdtZW50cywgaW5kZXgsIGhvd01hbnksIGNiKSB7XG4gIHZhciBwcmV2aW91cyA9IHRoaXMuX2NyZWF0ZUltcGxpZWQoc2VnbWVudHMpO1xuICBpZiAocHJldmlvdXMgPT0gbnVsbCkgcmV0dXJuIHByZXZpb3VzO1xuICB2YXIgcmVtb3ZlZCA9IHByZXZpb3VzLnNsaWNlKGluZGV4LCBpbmRleCArIGhvd01hbnkpO1xuICB2YXIgb3AgPSBbbmV3IFN0cmluZ1JlbW92ZU9wKHNlZ21lbnRzLCBpbmRleCwgcmVtb3ZlZCldO1xuICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKG9wLCBjYik7XG4gIHJldHVybiBwcmV2aW91cztcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgcmV0dXJuIHRoaXMuX2dldCh0aGlzLnNoYXJlRG9jLnNuYXBzaG90LCBzZWdtZW50cyk7XG59O1xuXG5SZW1vdGVEb2MucHJvdG90eXBlLl9jcmVhdGVJbXBsaWVkID0gZnVuY3Rpb24oc2VnbWVudHMpIHtcbiAgaWYgKCF0aGlzLnNoYXJlRG9jLnR5cGUpIHtcbiAgICB0aGlzLnNoYXJlRG9jLmNyZWF0ZSgnanNvbjAnKTtcbiAgfVxuICB2YXIgcGFyZW50ID0gdGhpcy5zaGFyZURvYztcbiAgdmFyIGtleSA9ICdzbmFwc2hvdCc7XG4gIHZhciBub2RlID0gcGFyZW50W2tleV07XG4gIHZhciBpID0gMDtcbiAgdmFyIG5leHRLZXkgPSBzZWdtZW50c1tpKytdO1xuICB3aGlsZSAobmV4dEtleSAhPSBudWxsKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpc0FycmF5SW5kZXgobmV4dEtleSkgPyBbXSA6IHt9O1xuICAgICAgdmFyIG9wID0gKEFycmF5LmlzQXJyYXkocGFyZW50KSkgP1xuICAgICAgICBuZXcgTGlzdEluc2VydE9wKHNlZ21lbnRzLnNsaWNlKDAsIGkgLSAyKSwga2V5LCB2YWx1ZSkgOlxuICAgICAgICBuZXcgT2JqZWN0SW5zZXJ0T3Aoc2VnbWVudHMuc2xpY2UoMCwgaSAtIDEpLCB2YWx1ZSk7XG4gICAgICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKG9wKTtcbiAgICAgIG5vZGUgPSBwYXJlbnRba2V5XTtcbiAgICB9XG4gICAgcGFyZW50ID0gbm9kZTtcbiAgICBrZXkgPSBuZXh0S2V5O1xuICAgIG5vZGUgPSBwYXJlbnRba2V5XTtcbiAgICBuZXh0S2V5ID0gc2VnbWVudHNbaSsrXTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuX2FycmF5QXBwbHkgPSBmdW5jdGlvbihzZWdtZW50cywgZm4sIGNiKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9jcmVhdGVJbXBsaWVkKHNlZ21lbnRzKTtcbiAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgdmFyIGxhc3RTZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIG9wID0gKGlzQXJyYXlJbmRleChsYXN0U2VnbWVudCkpID9cbiAgICAgIFtuZXcgTGlzdEluc2VydE9wKHNlZ21lbnRzLnNsaWNlKDAsIC0xKSwgbGFzdFNlZ21lbnQsIFtdKV0gOlxuICAgICAgW25ldyBPYmplY3RJbnNlcnRPcChzZWdtZW50cywgW10pXTtcbiAgICB0aGlzLnNoYXJlRG9jLnN1Ym1pdE9wKG9wKTtcbiAgICBhcnIgPSB0aGlzLmdldChzZWdtZW50cyk7XG4gIH1cblxuICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIHZhciBtZXNzYWdlID0gdGhpcy5fZXJyb3JNZXNzYWdlKGZuLm5hbWUgKyAnIG9uIG5vbi1hcnJheScsIHNlZ21lbnRzLCBhcnIpO1xuICAgIHZhciBlcnIgPSBuZXcgVHlwZUVycm9yKG1lc3NhZ2UpO1xuICAgIHJldHVybiBjYihlcnIpO1xuICB9XG4gIHJldHVybiBmbihhcnIsIGNiKTtcbn07XG5cblJlbW90ZURvYy5wcm90b3R5cGUuX29uT3AgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgaXRlbSA9IG9wWzBdO1xuICB2YXIgc2VnbWVudHMgPSBbdGhpcy5jb2xsZWN0aW9uTmFtZSwgdGhpcy5pZF0uY29uY2F0KGl0ZW0ucCk7XG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG5cbiAgLy8gT2JqZWN0UmVwbGFjZU9wLCBPYmplY3RJbnNlcnRPcCwgb3IgT2JqZWN0RGVsZXRlT3BcbiAgaWYgKGRlZmluZWQoaXRlbS5vaSkgfHwgZGVmaW5lZChpdGVtLm9kKSkge1xuICAgIHZhciB2YWx1ZSA9IGl0ZW0ub2k7XG4gICAgdmFyIHByZXZpb3VzID0gaXRlbS5vZDtcbiAgICBtb2RlbC5lbWl0KCdjaGFuZ2UnLCBzZWdtZW50cywgW3ZhbHVlLCBwcmV2aW91cywgbW9kZWwuX3Bhc3NdKTtcblxuICAvLyBMaXN0UmVwbGFjZU9wXG4gIH0gZWxzZSBpZiAoZGVmaW5lZChpdGVtLmxpKSAmJiBkZWZpbmVkKGl0ZW0ubGQpKSB7XG4gICAgdmFyIHZhbHVlID0gaXRlbS5saTtcbiAgICB2YXIgcHJldmlvdXMgPSBpdGVtLmxkO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCBtb2RlbC5fcGFzc10pO1xuXG4gIC8vIExpc3RJbnNlcnRPcFxuICB9IGVsc2UgaWYgKGRlZmluZWQoaXRlbS5saSkpIHtcbiAgICB2YXIgaW5kZXggPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgdmFsdWVzID0gW2l0ZW0ubGldO1xuICAgIG1vZGVsLmVtaXQoJ2luc2VydCcsIHNlZ21lbnRzLnNsaWNlKDAsIC0xKSwgW2luZGV4LCB2YWx1ZXMsIG1vZGVsLl9wYXNzXSk7XG5cbiAgLy8gTGlzdFJlbW92ZU9wXG4gIH0gZWxzZSBpZiAoZGVmaW5lZChpdGVtLmxkKSkge1xuICAgIHZhciBpbmRleCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciByZW1vdmVkID0gW2l0ZW0ubGRdO1xuICAgIG1vZGVsLmVtaXQoJ3JlbW92ZScsIHNlZ21lbnRzLnNsaWNlKDAsIC0xKSwgW2luZGV4LCByZW1vdmVkLCBtb2RlbC5fcGFzc10pO1xuXG4gIC8vIExpc3RNb3ZlT3BcbiAgfSBlbHNlIGlmIChkZWZpbmVkKGl0ZW0ubG0pKSB7XG4gICAgdmFyIGZyb20gPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgdG8gPSBpdGVtLmxtIC0gMTtcbiAgICB2YXIgaG93TWFueSA9IDE7XG4gICAgbW9kZWwuZW1pdCgnbW92ZScsIHNlZ21lbnRzLnNsaWNlKDAsIC0xKSwgW2Zyb20sIHRvLCBob3dNYW55LCBtb2RlbC5fcGFzc10pO1xuXG4gIC8vIFN0cmluZ0luc2VydE9wXG4gIH0gZWxzZSBpZiAoZGVmaW5lZChpdGVtLnNpKSkge1xuICAgIHZhciBpbmRleCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIHZhciB0ZXh0ID0gaXRlbS5zaTtcbiAgICBzZWdtZW50cyA9IHNlZ21lbnRzLnNsaWNlKDAsIC0xKTtcbiAgICBtb2RlbC5lbWl0KCdzdHJpbmdJbnNlcnQnLCBzZWdtZW50cywgW2luZGV4LCB0ZXh0LCBtb2RlbC5fcGFzc10pO1xuICAgIHZhciB2YWx1ZSA9IG1vZGVsLl9nZXQoc2VnbWVudHMpO1xuICAgIHZhciBwcmV2aW91cyA9IHZhbHVlLnNsaWNlKDAsIGluZGV4KSArIHZhbHVlLnNsaWNlKGluZGV4ICsgdGV4dC5sZW5ndGgpO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCB0aGlzLl9wYXNzU3RyaW5nSW5zZXJ0XSk7XG5cbiAgLy8gU3RyaW5nUmVtb3ZlT3BcbiAgfSBlbHNlIGlmIChkZWZpbmVkKGl0ZW0uc2QpKSB7XG4gICAgdmFyIGluZGV4ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHRleHQgPSBpdGVtLnNkO1xuICAgIHZhciBob3dNYW55ID0gdGV4dC5sZW5ndGg7XG4gICAgc2VnbWVudHMgPSBzZWdtZW50cy5zbGljZSgwLCAtMSk7XG4gICAgbW9kZWwuZW1pdCgnc3RyaW5nUmVtb3ZlJywgc2VnbWVudHMsIFtpbmRleCwgaG93TWFueSwgbW9kZWwuX3Bhc3NdKTtcbiAgICB2YXIgdmFsdWUgPSBtb2RlbC5fZ2V0KHNlZ21lbnRzKTtcbiAgICB2YXIgcHJldmlvdXMgPSB2YWx1ZS5zbGljZSgwLCBpbmRleCkgKyB0ZXh0ICsgdmFsdWUuc2xpY2UoaW5kZXgpO1xuICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIHNlZ21lbnRzLCBbdmFsdWUsIHByZXZpb3VzLCB0aGlzLl9wYXNzU3RyaW5nUmVtb3ZlXSk7XG5cbiAgLy8gSW5jcmVtZW50T3BcbiAgfSBlbHNlIGlmIChkZWZpbmVkKGl0ZW0ubmEpKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoaXRlbS5wKTtcbiAgICB2YXIgcHJldmlvdXMgPSB2YWx1ZSAtIGl0ZW0ubmE7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFt2YWx1ZSwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIE9iamVjdFJlcGxhY2VPcChzZWdtZW50cywgYmVmb3JlLCBhZnRlcikge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMpO1xuICB0aGlzLm9kID0gYmVmb3JlO1xuICB0aGlzLm9pID0gYWZ0ZXI7XG59XG5mdW5jdGlvbiBPYmplY3RJbnNlcnRPcChzZWdtZW50cywgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzKTtcbiAgdGhpcy5vaSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gT2JqZWN0RGVsZXRlT3Aoc2VnbWVudHMsIHZhbHVlKSB7XG4gIHRoaXMucCA9IGNhc3RTZWdtZW50cyhzZWdtZW50cyk7XG4gIHRoaXMub2QgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIExpc3RSZXBsYWNlT3Aoc2VnbWVudHMsIGluZGV4LCBiZWZvcmUsIGFmdGVyKSB7XG4gIHRoaXMucCA9IGNhc3RTZWdtZW50cyhzZWdtZW50cy5jb25jYXQoaW5kZXgpKTtcbiAgdGhpcy5sZCA9IGJlZm9yZTtcbiAgdGhpcy5saSA9IGFmdGVyO1xufVxuZnVuY3Rpb24gTGlzdEluc2VydE9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLmxpID0gdmFsdWU7XG59XG5mdW5jdGlvbiBMaXN0UmVtb3ZlT3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZSkge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMuY29uY2F0KGluZGV4KSk7XG4gIHRoaXMubGQgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIExpc3RNb3ZlT3Aoc2VnbWVudHMsIGZyb20sIHRvKSB7XG4gIHRoaXMucCA9IGNhc3RTZWdtZW50cyhzZWdtZW50cy5jb25jYXQoZnJvbSkpO1xuICB0aGlzLmxtID0gdG8gKyAxO1xufVxuZnVuY3Rpb24gU3RyaW5nSW5zZXJ0T3Aoc2VnbWVudHMsIGluZGV4LCB2YWx1ZSkge1xuICB0aGlzLnAgPSBjYXN0U2VnbWVudHMoc2VnbWVudHMuY29uY2F0KGluZGV4KSk7XG4gIHRoaXMuc2kgPSB2YWx1ZTtcbn1cbmZ1bmN0aW9uIFN0cmluZ1JlbW92ZU9wKHNlZ21lbnRzLCBpbmRleCwgdmFsdWUpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzLmNvbmNhdChpbmRleCkpO1xuICB0aGlzLnNkID0gdmFsdWU7XG59XG5mdW5jdGlvbiBJbmNyZW1lbnRPcChzZWdtZW50cywgYnlOdW1iZXIpIHtcbiAgdGhpcy5wID0gY2FzdFNlZ21lbnRzKHNlZ21lbnRzKTtcbiAgdGhpcy5uYSA9IGJ5TnVtYmVyO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBjYXN0U2VnbWVudHMoc2VnbWVudHMpIHtcbiAgLy8gQ2FzdCBudW1iZXIgcGF0aCBzZWdtZW50cyBmcm9tIHN0cmluZ3MgdG8gbnVtYmVyc1xuICBmb3IgKHZhciBpID0gc2VnbWVudHMubGVuZ3RoOyBpLS07KSB7XG4gICAgdmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAodHlwZW9mIHNlZ21lbnQgPT09ICdzdHJpbmcnICYmIGlzQXJyYXlJbmRleChzZWdtZW50KSkge1xuICAgICAgc2VnbWVudHNbaV0gPSArc2VnbWVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnRzO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5SW5kZXgoc2VnbWVudCkge1xuICByZXR1cm4gKC9eWzAtOV0rJC8pLnRlc3Qoc2VnbWVudCk7XG59XG4iLCJ2YXIgc2hhcmUgPSByZXF1aXJlKCdzaGFyZS9saWIvY2xpZW50Jyk7XG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL0NoYW5uZWwnKTtcbnZhciBNb2RlbCA9IHJlcXVpcmUoJy4vaW5kZXgnKTtcblxuTW9kZWwucHJvdG90eXBlLl9jcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24oYnVuZGxlKSB7XG4gIC8vIE1vZGVsI19jcmVhdGVTb2NrZXQgc2hvdWxkIGJlIGRlZmluZWQgYnkgdGhlIHNvY2tldCBwbHVnaW5cbiAgdGhpcy5zb2NrZXQgPSB0aGlzLl9jcmVhdGVTb2NrZXQoYnVuZGxlKTtcblxuICAvLyBUaGUgU2hhcmUgY29ubmVjdGlvbiB3aWxsIGJpbmQgdG8gdGhlIHNvY2tldCBieSBkZWZpbmluZyB0aGUgb25vcGVuLFxuICAvLyBvbm1lc3NhZ2UsIGV0Yy4gbWV0aG9kc1xuICB2YXIgc2hhcmVDb25uZWN0aW9uID0gdGhpcy5zaGFyZUNvbm5lY3Rpb24gPSBuZXcgc2hhcmUuQ29ubmVjdGlvbih0aGlzLnNvY2tldCk7XG4gIHZhciBzZWdtZW50cyA9IFsnJGNvbm5lY3Rpb24nLCAnc3RhdGUnXTtcbiAgdmFyIHN0YXRlcyA9IFsnY29ubmVjdGluZycsICdjb25uZWN0ZWQnLCAnZGlzY29ubmVjdGVkJywgJ3N0b3BwZWQnXTtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgc3RhdGVzLmZvckVhY2goZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBzaGFyZUNvbm5lY3Rpb24ub24oc3RhdGUsIGZ1bmN0aW9uKCkge1xuICAgICAgbW9kZWwuX3NldChzZWdtZW50cywgc3RhdGUpO1xuICAgIH0pO1xuICB9KTtcbiAgdGhpcy5fc2V0KHNlZ21lbnRzLCAnY29ubmVjdGVkJyk7XG5cbiAgLy8gV3JhcCB0aGUgc29ja2V0IG1ldGhvZHMgb24gdG9wIG9mIFNoYXJlJ3MgbWV0aG9kc1xuICB0aGlzLl9jcmVhdGVDaGFubmVsKCk7XG59O1xuXG5Nb2RlbC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNvY2tldC5vcGVuKCk7XG59O1xuTW9kZWwucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZGlzY29ubmVjdCgpO1xuICB0aGlzLmNvbm5lY3QoKTtcbn07XG5cbk1vZGVsLnByb3RvdHlwZS5fY3JlYXRlQ2hhbm5lbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmNoYW5uZWwgPSBuZXcgQ2hhbm5lbCh0aGlzLnNvY2tldCk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBEb2M7XG5cbmZ1bmN0aW9uIERvYyhjb2xsZWN0aW9uTmFtZSwgaWQpIHtcbiAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IGNvbGxlY3Rpb25OYW1lO1xuICB0aGlzLmlkID0gaWQ7XG59XG5cbkRvYy5wcm90b3R5cGUucGF0aCA9IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG4gIHJldHVybiB0aGlzLmNvbGxlY3Rpb25OYW1lICsgJy4nICsgdGhpcy5pZCArICcuJyArIHNlZ21lbnRzLmpvaW4oJy4nKTtcbn07XG5cbkRvYy5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uKHNuYXBzaG90LCBzZWdtZW50cykge1xuICBpZiAoIXNlZ21lbnRzKSByZXR1cm4gc25hcHNob3Q7XG4gIHZhciBub2RlID0gc25hcHNob3Q7XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleSA9IHNlZ21lbnRzW2krK107XG4gIHdoaWxlIChrZXkgIT0gbnVsbCkge1xuICAgIGlmIChub2RlID09IG51bGwpIHJldHVybjtcbiAgICBub2RlID0gbm9kZVtrZXldO1xuICAgIGtleSA9IHNlZ21lbnRzW2krK107XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59O1xuXG5Eb2MucHJvdG90eXBlLl9lcnJvck1lc3NhZ2UgPSBmdW5jdGlvbihkZXNjcmlwdGlvbiwgc2VnbWVudHMsIHZhbHVlKSB7XG4gIHJldHVybiBkZXNjcmlwdGlvbiArICcgYXQgJyArIHRoaXMucGF0aChzZWdtZW50cykgKyAnOiAnICtcbiAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgMik7XG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG52YXIgYXJyYXlEaWZmID0gcmVxdWlyZSgnYXJyYXlkaWZmJyk7XG5cbk1vZGVsLnByb3RvdHlwZS5zZXREaWZmID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdWJwYXRoLCB2YWx1ZSwgb3B0aW9ucywgY2I7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHN1YnBhdGggPSBhcmd1bWVudHNbMF07XG4gICAgdmFsdWUgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gYXJndW1lbnRzWzJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzWzJdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdWJwYXRoID0gYXJndW1lbnRzWzBdO1xuICAgIHZhbHVlID0gYXJndW1lbnRzWzFdO1xuICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG4gICAgY2IgPSBhcmd1bWVudHNbM107XG4gIH1cbiAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc3BsaXRQYXRoKHN1YnBhdGgpO1xuICByZXR1cm4gdGhpcy5fc2V0RGlmZihzZWdtZW50cywgdmFsdWUsIG9wdGlvbnMsIGNiKTtcbn07XG5Nb2RlbC5wcm90b3R5cGUuX3NldERpZmYgPSBmdW5jdGlvbihzZWdtZW50cywgdmFsdWUsIG9wdGlvbnMsIGNiKSB7XG4gIHNlZ21lbnRzID0gdGhpcy5fZGVyZWZlcmVuY2Uoc2VnbWVudHMpO1xuICB2YXIgZXF1YWxGbiA9IChvcHRpb25zICYmIG9wdGlvbnMuZXF1YWwpIHx8IHV0aWwuZXF1YWw7XG4gIHZhciBpc0VhY2ggPSBvcHRpb25zICYmIG9wdGlvbnMuZWFjaDtcbiAgdmFyIG1vZGVsID0gdGhpcztcbiAgZnVuY3Rpb24gc2V0RGlmZihkb2MsIGRvY1NlZ21lbnRzLCBmbkNiKSB7XG4gICAgdmFyIGJlZm9yZSA9IGRvYy5nZXQoZG9jU2VnbWVudHMpO1xuICAgIGlmIChlcXVhbEZuKGJlZm9yZSwgdmFsdWUpKSByZXR1cm4gZm5DYigpO1xuICAgIHZhciBncm91cCA9IHV0aWwuYXN5bmNHcm91cChmbkNiKTtcbiAgICBkb0RpZmYobW9kZWwsIGRvYywgc2VnbWVudHMsIGJlZm9yZSwgdmFsdWUsIGVxdWFsRm4sIGdyb3VwLCBpc0VhY2gpO1xuICB9XG4gIHJldHVybiB0aGlzLl9tdXRhdGUoc2VnbWVudHMsIHNldERpZmYsIGNiKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGRvY1xuICogQHBhcmFtIHtTdHJpbmd9IGRvYy5jb2xsZWN0aW9uTmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IGRvYy5pZFxuICogQHBhcmFtIHtPYmplY3R9IGRvYy5zbmFwc2hvdFxuICogQHBhcmFtIHtBcnJheX0gc2VnbWVudHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBiZWZvcmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBhZnRlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ3JvdXBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNFYWNoXG4gKi9cbmZ1bmN0aW9uIGRvRGlmZihtb2RlbCwgZG9jLCBzZWdtZW50cywgYmVmb3JlLCBhZnRlciwgZXF1YWxGbiwgZ3JvdXAsIGlzRWFjaCkge1xuICBpZiAodHlwZW9mIGJlZm9yZSAhPT0gJ29iamVjdCcgfHwgIWJlZm9yZSB8fFxuICAgICAgdHlwZW9mIGFmdGVyICE9PSAnb2JqZWN0JyB8fCAhYWZ0ZXIpIHtcbiAgICAvLyBTZXQgdGhlIGVudGlyZSB2YWx1ZSBpZiBub3QgZGlmZmFibGVcbiAgICB2YXIgZG9jU2VnbWVudHMgPSBzZWdtZW50cy5zbGljZSgyKTtcbiAgICB2YXIgcHJldmlvdXMgPSBkb2Muc2V0KGRvY1NlZ21lbnRzLCBhZnRlciwgZ3JvdXAoKSk7XG4gICAgbW9kZWwuZW1pdCgnY2hhbmdlJywgc2VnbWVudHMsIFthZnRlciwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGJlZm9yZSkgJiYgQXJyYXkuaXNBcnJheShhZnRlcikpIHtcbiAgICB2YXIgZGlmZiA9IGFycmF5RGlmZihiZWZvcmUsIGFmdGVyLCBlcXVhbEZuKTtcbiAgICBpZiAoIWRpZmYubGVuZ3RoKSByZXR1cm47XG4gICAgLy8gSWYgdGhlIG9ubHkgY2hhbmdlIGlzIGEgc2luZ2xlIGl0ZW0gcmVwbGFjZW1lbnQsIGRpZmYgdGhlIGl0ZW0gaW5zdGVhZFxuICAgIGlmIChcbiAgICAgIGRpZmYubGVuZ3RoID09PSAyICYmXG4gICAgICBkaWZmWzBdLmluZGV4ID09PSBkaWZmWzFdLmluZGV4ICYmXG4gICAgICBkaWZmWzBdIGluc3RhbmNlb2YgYXJyYXlEaWZmLlJlbW92ZURpZmYgJiZcbiAgICAgIGRpZmZbMF0uaG93TWFueSA9PT0gMSAmJlxuICAgICAgZGlmZlsxXSBpbnN0YW5jZW9mIGFycmF5RGlmZi5JbnNlcnREaWZmICYmXG4gICAgICBkaWZmWzFdLnZhbHVlcy5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgIHZhciBpbmRleCA9IGRpZmZbMF0uaW5kZXg7XG4gICAgICB2YXIgaXRlbVNlZ21lbnRzID0gc2VnbWVudHMuY29uY2F0KGluZGV4KTtcbiAgICAgIGRvRGlmZihtb2RlbCwgZG9jLCBpdGVtU2VnbWVudHMsIGJlZm9yZVtpbmRleF0sIGFmdGVyW2luZGV4XSwgZXF1YWxGbiwgZ3JvdXApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZG9jU2VnbWVudHMgPSBzZWdtZW50cy5zbGljZSgyKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGlmZi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkaWZmW2ldO1xuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBhcnJheURpZmYuSW5zZXJ0RGlmZikge1xuICAgICAgICAvLyBJbnNlcnRcbiAgICAgICAgZG9jLmluc2VydChkb2NTZWdtZW50cywgaXRlbS5pbmRleCwgaXRlbS52YWx1ZXMsIGdyb3VwKCkpO1xuICAgICAgICBtb2RlbC5lbWl0KCdpbnNlcnQnLCBzZWdtZW50cywgW2l0ZW0uaW5kZXgsIGl0ZW0udmFsdWVzLCBtb2RlbC5fcGFzc10pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgYXJyYXlEaWZmLlJlbW92ZURpZmYpIHtcbiAgICAgICAgLy8gUmVtb3ZlXG4gICAgICAgIHZhciByZW1vdmVkID0gZG9jLnJlbW92ZShkb2NTZWdtZW50cywgaXRlbS5pbmRleCwgaXRlbS5ob3dNYW55LCBncm91cCgpKTtcbiAgICAgICAgbW9kZWwuZW1pdCgncmVtb3ZlJywgc2VnbWVudHMsIFtpdGVtLmluZGV4LCByZW1vdmVkLCBtb2RlbC5fcGFzc10pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgYXJyYXlEaWZmLk1vdmVEaWZmKSB7XG4gICAgICAgIC8vIE1vdmVcbiAgICAgICAgdmFyIG1vdmVkID0gZG9jLm1vdmUoZG9jU2VnbWVudHMsIGl0ZW0uZnJvbSwgaXRlbS50bywgaXRlbS5ob3dNYW55LCBncm91cCgpKTtcbiAgICAgICAgbW9kZWwuZW1pdCgnbW92ZScsIHNlZ21lbnRzLCBbaXRlbS5mcm9tLCBpdGVtLnRvLCBtb3ZlZC5sZW5ndGgsIG1vZGVsLl9wYXNzXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIWlzRWFjaCkge1xuICAgIC8vIERlbGV0ZSBrZXlzIHRoYXQgd2VyZSBpbiBiZWZvcmUgYnV0IG5vdCBhZnRlclxuICAgIGZvciAodmFyIGtleSBpbiBiZWZvcmUpIHtcbiAgICAgIGlmIChrZXkgaW4gYWZ0ZXIpIGNvbnRpbnVlO1xuICAgICAgdmFyIGl0ZW1TZWdtZW50cyA9IHNlZ21lbnRzLmNvbmNhdChrZXkpO1xuICAgICAgdmFyIGRvY1NlZ21lbnRzID0gc2VnbWVudHMuc2xpY2UoMik7XG4gICAgICB2YXIgcHJldmlvdXMgPSBkb2MuZGVsKGRvY1NlZ21lbnRzLCBncm91cCgpKTtcbiAgICAgIG1vZGVsLmVtaXQoJ2NoYW5nZScsIGl0ZW1TZWdtZW50cywgW3ZvaWQgMCwgcHJldmlvdXMsIG1vZGVsLl9wYXNzXSk7XG4gICAgfVxuICB9XG4gIC8vIERpZmYgZWFjaCBwcm9wZXJ0eSBpbiBhZnRlclxuICBmb3IgKHZhciBrZXkgaW4gYWZ0ZXIpIHtcbiAgICBpZiAoZXF1YWxGbihiZWZvcmVba2V5XSwgYWZ0ZXJba2V5XSkpIGNvbnRpbnVlO1xuICAgIHZhciBpdGVtU2VnbWVudHMgPSBzZWdtZW50cy5jb25jYXQoa2V5KTtcbiAgICBkb0RpZmYobW9kZWwsIGRvYywgaXRlbVNlZ21lbnRzLCBiZWZvcmVba2V5XSwgYWZ0ZXJba2V5XSwgZXF1YWxGbiwgZ3JvdXApO1xuICB9XG59XG4iLCIoZnVuY3Rpb24ocHJvY2Vzcyl7dmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgTW9kZWwgPSByZXF1aXJlKCcuL2luZGV4Jyk7XG52YXIgYXJyYXlEaWZmID0gcmVxdWlyZSgnYXJyYXlkaWZmJyk7XG52YXIgZGVlcEVxdWFscyA9IHJlcXVpcmUoJ2RlZXAtaXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWVyeTtcblxuTW9kZWwuSU5JVFMucHVzaChmdW5jdGlvbihtb2RlbCkge1xuICBtb2RlbC5fcXVlcmllcyA9IG5ldyBRdWVyaWVzO1xuICBpZiAobW9kZWwuZmV0Y2hPbmx5KSByZXR1cm47XG4gIG1vZGVsLm9uKCdhbGwnLCBmdW5jdGlvbihzZWdtZW50cykge1xuICAgIC8vIFVwZGF0ZWQgYXN5bmMsIHNpbmNlIHRoaXMgaXMgbGlrZWx5IHRoZSByZXN1bHQgb2YgYW4gb3BlcmF0aW9uIHRoYXRcbiAgICAvLyBpbmNsdWRlcyBjcmVhdGluZyB0aGUgZG9jLCBhbmQgd2Ugd291bGQgbGlrZSB0aGF0IHRvIGhhcHBlbiBiZWZvcmVcbiAgICAvLyBzZW5kaW5nIHRoZSBzdWJzY3JpYmUgbWVzc2FnZVxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFwID0gbW9kZWwuX3F1ZXJpZXMubWFwO1xuICAgICAgZm9yICh2YXIgaGFzaCBpbiBtYXApIHtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gbWFwW2hhc2hdO1xuICAgICAgICBpZiAocXVlcnkuaXNQYXRoUXVlcnkgJiYgcXVlcnkuc2hhcmVRdWVyeSAmJiB1dGlsLm1heUltcGFjdChxdWVyeS5leHByZXNzaW9uLCBzZWdtZW50cykpIHtcbiAgICAgICAgICB2YXIgaWRzID0gcGF0aElkcyhtb2RlbCwgcXVlcnkuZXhwcmVzc2lvbik7XG4gICAgICAgICAgdmFyIHByZXZpb3VzSWRzID0gbW9kZWwuX2dldChxdWVyeS5pZFNlZ21lbnRzKTtcbiAgICAgICAgICBxdWVyeS5fb25DaGFuZ2UoaWRzLCBwcmV2aW91c0lkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHByZXNzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gc291cmNlXG4gKiBAcmV0dXJuIHtRdWVyeX1cbiAqL1xuTW9kZWwucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24oY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSkge1xuICBpZiAodHlwZW9mIGV4cHJlc3Npb24ucGF0aCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZXhwcmVzc2lvbiAhPT0gJ29iamVjdCcpIHtcbiAgICBleHByZXNzaW9uID0gdGhpcy5fc3BsaXRQYXRoKGV4cHJlc3Npb24pO1xuICB9XG4gIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJpZXMuZ2V0KGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpO1xuICBpZiAocXVlcnkpIHJldHVybiBxdWVyeTtcbiAgcXVlcnkgPSBuZXcgUXVlcnkodGhpcywgY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSk7XG4gIHRoaXMuX3F1ZXJpZXMuYWRkKHF1ZXJ5KTtcbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uIG9mIHRoZSBidW5kbGUgb24gcGFnZSBsb2FkLlxuICogQHBhcmFtIHtBcnJheX0gaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXl9IGl0ZW1zWypdXG4gKiBAcGFyYW0ge1N0cmluZ30gaXRlbXNbKl1bMF0gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpdGVtc1sqXVsxXSBleHByZXNzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gaXRlbXNbKl1bMl0gc291cmNlXG4gKiBAcGFyYW0ge051bWJlcn0gaXRlbXNbKl1bM10gc3Vic2NyaWJlQ291bnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBpdGVtc1sqXVs0XSBmZXRjaENvdW50XG4gKiBAcGFyYW0ge0FycmF5fSAgaXRlbXNbKl1bNV0gZmV0Y2hJZHNcbiAqL1xuTW9kZWwucHJvdG90eXBlLl9pbml0UXVlcmllcyA9IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIHZhciBxdWVyeSA9IG5ldyBRdWVyeSh0aGlzLCBpdGVtWzBdLCBpdGVtWzFdLCBpdGVtWzJdLCBpdGVtWzNdLCBpdGVtWzRdLCBpdGVtWzVdKTtcbiAgICB2YXIgY291bnQgPSBxdWVyeS5mZXRjaENvdW50O1xuICAgIHdoaWxlIChjb3VudC0tKSB0aGlzLmVtaXQoJ2ZldGNoUXVlcnknLCBxdWVyeSwgdGhpcy5fY29udGV4dCk7XG4gICAgdmFyIGNvdW50ID0gcXVlcnkuc3Vic2NyaWJlQ291bnQ7XG4gICAgcXVlcnkuc3Vic2NyaWJlQ291bnQgPSAwO1xuICAgIHdoaWxlIChjb3VudC0tKSBxdWVyeS5zdWJzY3JpYmUoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gUXVlcmllc01hcCgpIHt9XG5cbmZ1bmN0aW9uIFF1ZXJpZXMoKSB7XG4gIHRoaXMubWFwID0gbmV3IFF1ZXJpZXNNYXA7XG59XG5RdWVyaWVzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihxdWVyeSkge1xuICB0aGlzLm1hcFtxdWVyeS5oYXNoXSA9IHF1ZXJ5O1xufTtcblF1ZXJpZXMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gIGRlbGV0ZSB0aGlzLm1hcFtxdWVyeS5oYXNoXTtcbn07XG5RdWVyaWVzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihjb2xsZWN0aW9uTmFtZSwgZXhwcmVzc2lvbiwgc291cmNlKSB7XG4gIHZhciBoYXNoID0gcXVlcnlIYXNoKGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpO1xuICByZXR1cm4gdGhpcy5tYXBbaGFzaF07XG59O1xuUXVlcmllcy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHZhciBvdXQgPSBbXTtcbiAgZm9yICh2YXIgaGFzaCBpbiB0aGlzLm1hcCkge1xuICAgIHZhciBxdWVyeSA9IHRoaXMubWFwW2hhc2hdO1xuICAgIGlmIChxdWVyeS5zdWJzY3JpYmVDb3VudCB8fCBxdWVyeS5mZXRjaENvdW50KSB7XG4gICAgICBvdXQucHVzaChxdWVyeS5zZXJpYWxpemUoKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TW9kZWx9IG1vZGVsXG4gKiBAcGFyYW0ge09iamVjdH0gY29sbGVjdGlvbk5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHByZXNzaW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gc291cmNlIChlLmcuLCAnc29scicpXG4gKiBAcGFyYW0ge051bWJlcn0gc3Vic2NyaWJlQ291bnRcbiAqIEBwYXJhbSB7TnVtYmVyfSBmZXRjaENvdW50XG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PFN0cmluZz4+fSBmZXRjaElkc1xuICovXG5mdW5jdGlvbiBRdWVyeShtb2RlbCwgY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZSwgc3Vic2NyaWJlQ291bnQsIGZldGNoQ291bnQsIGZldGNoSWRzKSB7XG4gIHRoaXMubW9kZWwgPSBtb2RlbC5wYXNzKHskcXVlcnk6IHRoaXN9KTtcbiAgdGhpcy5jb2xsZWN0aW9uTmFtZSA9IGNvbGxlY3Rpb25OYW1lO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy5oYXNoID0gcXVlcnlIYXNoKGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpO1xuICB0aGlzLnNlZ21lbnRzID0gWyckcXVlcmllcycsIHRoaXMuaGFzaF07XG4gIHRoaXMuaWRTZWdtZW50cyA9IFsnJHF1ZXJpZXMnLCB0aGlzLmhhc2gsICdpZHMnXTtcbiAgdGhpcy5leHRyYVNlZ21lbnRzID0gWyckcXVlcmllcycsIHRoaXMuaGFzaCwgJ2V4dHJhJ107XG4gIHRoaXMuaXNQYXRoUXVlcnkgPSBBcnJheS5pc0FycmF5KGV4cHJlc3Npb24pO1xuXG4gIHRoaXMuX3BlbmRpbmdTdWJzY3JpYmVDYWxsYmFja3MgPSBbXTtcblxuICAvLyBUaGVzZSBhcmUgdXNlZCB0byBoZWxwIGNsZWFudXAgYXBwcm9wcmlhdGVseSB3aGVuIGNhbGxpbmcgdW5zdWJzY3JpYmUgYW5kXG4gIC8vIHVuZmV0Y2guIEEgcXVlcnkgd29uJ3QgYmUgZnVsbHkgY2xlYW5lZCB1cCB1bnRpbCB1bmZldGNoIGFuZCB1bnN1YnNjcmliZVxuICAvLyBhcmUgY2FsbGVkIHRoZSBzYW1lIG51bWJlciBvZiB0aW1lcyB0aGF0IGZldGNoIGFuZCBzdWJzY3JpYmUgd2VyZSBjYWxsZWQuXG4gIHRoaXMuc3Vic2NyaWJlQ291bnQgPSBzdWJzY3JpYmVDb3VudCB8fCAwO1xuICB0aGlzLmZldGNoQ291bnQgPSBmZXRjaENvdW50IHx8IDA7XG4gIC8vIFRoZSBsaXN0IG9mIGlkcyBhdCB0aGUgdGltZSBvZiBlYWNoIGZldGNoIGlzIHB1c2hlZCBvbnRvIGZldGNoSWRzLCBzb1xuICAvLyB0aGF0IHVuZmV0Y2hEb2MgY2FuIGJlIGNhbGxlZCB0aGUgc2FtZSBudW1iZXIgb2YgdGltZXMgYXMgZmV0Y2hEb2NcbiAgdGhpcy5mZXRjaElkcyA9IGZldGNoSWRzIHx8IFtdO1xuXG4gIHRoaXMuY3JlYXRlZCA9IGZhbHNlO1xuICB0aGlzLnNoYXJlUXVlcnkgPSBudWxsO1xufVxuXG5RdWVyeS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY3JlYXRlZCA9IHRydWU7XG4gIHRoaXMubW9kZWwuX3F1ZXJpZXMuYWRkKHRoaXMpO1xufTtcblxuUXVlcnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jcmVhdGVkID0gZmFsc2U7XG4gIGlmICh0aGlzLnNoYXJlUXVlcnkpIHtcbiAgICB0aGlzLnNoYXJlUXVlcnkuZGVzdHJveSgpO1xuICAgIHRoaXMuc2hhcmVRdWVyeSA9IG51bGw7XG4gIH1cbiAgdGhpcy5tb2RlbC5fcXVlcmllcy5yZW1vdmUodGhpcyk7XG4gIHRoaXMubW9kZWwuX2RlbCh0aGlzLnNlZ21lbnRzKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5zb3VyY2VRdWVyeSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pc1BhdGhRdWVyeSkge1xuICAgIHZhciBpZHMgPSBwYXRoSWRzKHRoaXMubW9kZWwsIHRoaXMuZXhwcmVzc2lvbik7XG4gICAgcmV0dXJuIHtfaWQ6IHskaW46IGlkc319O1xuICB9XG4gIHJldHVybiB0aGlzLmV4cHJlc3Npb247XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gY2IoZXJyKVxuICovXG5RdWVyeS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbihjYikge1xuICBpZiAoIWNiKSBjYiA9IHRoaXMubW9kZWwuX2RlZmF1bHRDYWxsYmFjaztcbiAgdGhpcy5tb2RlbC5lbWl0KCdmZXRjaFF1ZXJ5JywgdGhpcywgdGhpcy5tb2RlbC5fY29udGV4dCk7XG5cbiAgdGhpcy5mZXRjaENvdW50Kys7XG5cbiAgaWYgKCF0aGlzLmNyZWF0ZWQpIHRoaXMuY3JlYXRlKCk7XG4gIHZhciBxdWVyeSA9IHRoaXM7XG5cbiAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcbiAgdmFyIHNoYXJlRG9jcyA9IGNvbGxlY3Rpb25TaGFyZURvY3ModGhpcy5tb2RlbCwgdGhpcy5jb2xsZWN0aW9uTmFtZSk7XG4gIHZhciBvcHRpb25zID0ge2RvY01vZGU6ICdmZXRjaCcsIGtub3duRG9jczogc2hhcmVEb2NzfTtcbiAgaWYgKHRoaXMuc291cmNlKSBvcHRpb25zLnNvdXJjZSA9IHRoaXMuc291cmNlO1xuXG4gIG1vZGVsLnNoYXJlQ29ubmVjdGlvbi5jcmVhdGVGZXRjaFF1ZXJ5KFxuICAgIHRoaXMuY29sbGVjdGlvbk5hbWUsIHRoaXMuc291cmNlUXVlcnkoKSwgb3B0aW9ucywgZmV0Y2hRdWVyeUNhbGxiYWNrXG4gICk7XG4gIGZ1bmN0aW9uIGZldGNoUXVlcnlDYWxsYmFjayhlcnIsIHJlc3VsdHMsIGV4dHJhKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgdmFyIGlkcyA9IHJlc3VsdHNJZHMocmVzdWx0cyk7XG5cbiAgICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBpZHMgYXQgZmV0Y2ggdGltZSBmb3IgdXNlIGluIHVuZmV0Y2hcbiAgICBxdWVyeS5mZXRjaElkcy5wdXNoKGlkcy5zbGljZSgpKTtcbiAgICAvLyBVcGRhdGUgdGhlIHJlc3VsdHMgaWRzIGFuZCBleHRyYVxuICAgIG1vZGVsLl9zZXREaWZmKHF1ZXJ5LmlkU2VnbWVudHMsIGlkcyk7XG4gICAgaWYgKGV4dHJhICE9PSB2b2lkIDApIHtcbiAgICAgIG1vZGVsLl9zZXREaWZmKHF1ZXJ5LmV4dHJhU2VnbWVudHMsIGV4dHJhLCB7ZXF1YWw6IGRlZXBFcXVhbHN9KTtcbiAgICB9XG5cbiAgICBpZiAoIWlkcy5sZW5ndGgpIHJldHVybiBjYigpO1xuXG4gICAgLy8gQ2FsbCBmZXRjaERvYyBmb3IgZWFjaCBkb2N1bWVudCByZXR1cm5lZCBzbyB0aGF0IHRoZSBwcm9wZXIgbG9hZCBldmVudHNcbiAgICAvLyBhbmQgaW50ZXJuYWwgY291bnRzIGFyZSBtYWludGFpbmVkLiBIb3dldmVyLCBzcGVjaWZ5IHRoYXQgd2UgYWxyZWFkeVxuICAgIC8vIGxvYWRlZCB0aGUgZG9jdW1lbnRzIGFzIHBhcnQgb2YgdGhlIHF1ZXJ5LCBzaW5jZSB3ZSBkb24ndCB3YW50IHRvXG4gICAgLy8gYWN0dWFsbHkgZmV0Y2ggdGhlIGRvY3VtZW50cyBhZ2FpblxuICAgIHZhciBhbHJlYWR5TG9hZGVkID0gdHJ1ZTtcbiAgICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoY2IpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtb2RlbC5mZXRjaERvYyhxdWVyeS5jb2xsZWN0aW9uTmFtZSwgaWRzW2ldLCBncm91cCgpLCBhbHJlYWR5TG9hZGVkKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdXAgYSBzdWJzY3JpcHRpb24gdG8gYHRoaXNgIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IoZXJyKVxuICovXG5RdWVyeS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2IpIHtcbiAgaWYgKCFjYikgY2IgPSB0aGlzLm1vZGVsLl9kZWZhdWx0Q2FsbGJhY2s7XG4gIHRoaXMubW9kZWwuZW1pdCgnc3Vic2NyaWJlUXVlcnknLCB0aGlzLCB0aGlzLm1vZGVsLl9jb250ZXh0KTtcblxuICB2YXIgcXVlcnkgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnN1YnNjcmliZUNvdW50KyspIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBkYXRhID0gcXVlcnkubW9kZWwuX2dldChxdWVyeS5zZWdtZW50cyk7XG4gICAgICBpZiAoZGF0YSkgY2IoKTtcbiAgICAgIGVsc2UgcXVlcnkuX3BlbmRpbmdTdWJzY3JpYmVDYWxsYmFja3MucHVzaChjYik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoIXRoaXMuY3JlYXRlZCkgdGhpcy5jcmVhdGUoKTtcblxuICAvLyBXaGVuIGRvaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZywgd2UgYWN0dWFsbHkgZG8gYSBmZXRjaCB0aGUgZmlyc3QgdGltZVxuICAvLyB0aGF0IHN1YnNjcmliZSBpcyBjYWxsZWQsIGJ1dCBrZWVwIHRyYWNrIG9mIHRoZSBzdGF0ZSBhcyBpZiBzdWJzY3JpYmVcbiAgLy8gd2VyZSBjYWxsZWQgZm9yIHByb3BlciBpbml0aWFsaXphdGlvbiBpbiB0aGUgY2xpZW50XG4gIHZhciBzaGFyZURvY3MgPSBjb2xsZWN0aW9uU2hhcmVEb2NzKHRoaXMubW9kZWwsIHRoaXMuY29sbGVjdGlvbk5hbWUpO1xuICB2YXIgb3B0aW9ucyA9IHtkb2NNb2RlOiAnc3ViJywga25vd25Eb2NzOiBzaGFyZURvY3N9O1xuICBpZiAodGhpcy5zb3VyY2UpIG9wdGlvbnMuc291cmNlID0gdGhpcy5zb3VyY2U7XG5cbiAgaWYgKCF0aGlzLm1vZGVsLmZldGNoT25seSkge1xuICAgIHRoaXMuX3NoYXJlU3Vic2NyaWJlKG9wdGlvbnMsIGNiKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIG9wdGlvbnMuZG9jTW9kZSA9ICdmZXRjaCc7XG4gIG1vZGVsLnNoYXJlQ29ubmVjdGlvbi5jcmVhdGVGZXRjaFF1ZXJ5KFxuICAgIHRoaXMuY29sbGVjdGlvbk5hbWUsIHRoaXMuc291cmNlUXVlcnkoKSwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCByZXN1bHRzLCBleHRyYSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG4gICAgICB2YXIgaWRzID0gcmVzdWx0c0lkcyhyZXN1bHRzKTtcbiAgICAgIGlmIChleHRyYSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG1vZGVsLl9zZXREaWZmKHF1ZXJ5LmV4dHJhU2VnbWVudHMsIGV4dHJhLCB7ZXF1YWw6IGRlZXBFcXVhbHN9KTtcbiAgICAgIH1cbiAgICAgIHF1ZXJ5Ll9vbkNoYW5nZShpZHMsIG51bGwsIGNiKTtcbiAgICAgIHdoaWxlIChjYiA9IHF1ZXJ5Ll9wZW5kaW5nU3Vic2NyaWJlQ2FsbGJhY2tzLnNoaWZ0KCkpIHtcbiAgICAgICAgcXVlcnkuX29uQ2hhbmdlKGlkcywgbnVsbCwgY2IpO1xuICAgICAgfVxuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnNvdXJjZV1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucG9sbF1cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZG9jTW9kZSA9IGZldGNoIG9yIHN1YnNjcmliZV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiKGVyciwgcmVzdWx0cylcbiAqL1xuUXVlcnkucHJvdG90eXBlLl9zaGFyZVN1YnNjcmliZSA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNiKSB7XG4gIHZhciBxdWVyeSA9IHRoaXM7XG4gIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XG4gIHRoaXMuc2hhcmVRdWVyeSA9IHRoaXMubW9kZWwuc2hhcmVDb25uZWN0aW9uLmNyZWF0ZVN1YnNjcmliZVF1ZXJ5KFxuICAgIHRoaXMuY29sbGVjdGlvbk5hbWUsIHRoaXMuc291cmNlUXVlcnkoKSwgb3B0aW9ucywgZnVuY3Rpb24gKGVyciwgcmVzdWx0cywgZXh0cmEpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuICAgICAgdmFyIGlkcyA9IHJlc3VsdHNJZHMocmVzdWx0cyk7XG4gICAgICBpZiAoZXh0cmEgIT09IHZvaWQgMCkge1xuICAgICAgICBtb2RlbC5fc2V0RGlmZihxdWVyeS5leHRyYVNlZ21lbnRzLCBleHRyYSwge2VxdWFsOiBkZWVwRXF1YWxzfSk7XG4gICAgICB9XG4gICAgICBxdWVyeS5fb25DaGFuZ2UoaWRzLCBudWxsLCBjYik7XG4gICAgfVxuICApO1xuICB2YXIgcXVlcnkgPSB0aGlzO1xuICB0aGlzLnNoYXJlUXVlcnkub24oJ2luc2VydCcsIGZ1bmN0aW9uKHNoYXJlRG9jcywgaW5kZXgpIHtcbiAgICBxdWVyeS5fb25JbnNlcnQoc2hhcmVEb2NzLCBpbmRleCk7XG4gIH0pO1xuICB0aGlzLnNoYXJlUXVlcnkub24oJ3JlbW92ZScsIGZ1bmN0aW9uKHNoYXJlRG9jcywgaW5kZXgpIHtcbiAgICBxdWVyeS5fb25SZW1vdmUoc2hhcmVEb2NzLCBpbmRleCk7XG4gIH0pO1xuICB0aGlzLnNoYXJlUXVlcnkub24oJ21vdmUnLCBmdW5jdGlvbihzaGFyZURvY3MsIGZyb20sIHRvKSB7XG4gICAgcXVlcnkuX29uTW92ZShzaGFyZURvY3MsIGZyb20sIHRvKTtcbiAgfSk7XG4gIHRoaXMuc2hhcmVRdWVyeS5vbignY2hhbmdlJywgZnVuY3Rpb24ocmVzdWx0cywgcHJldmlvdXMpIHtcbiAgICAvLyBHZXQgdGhlIG5ldyBhbmQgcHJldmlvdXMgbGlzdCBvZiBpZHMgd2hlbiB0aGUgZW50aXJlIHJlc3VsdHMgc2V0IGNoYW5nZXNcbiAgICB2YXIgaWRzID0gcmVzdWx0c0lkcyhyZXN1bHRzKTtcbiAgICB2YXIgcHJldmlvdXNJZHMgPSBwcmV2aW91cyAmJiByZXN1bHRzSWRzKHByZXZpb3VzKTtcbiAgICBxdWVyeS5fb25DaGFuZ2UoaWRzLCBwcmV2aW91c0lkcyk7XG4gIH0pO1xuICB0aGlzLnNoYXJlUXVlcnkub24oJ2V4dHJhJywgZnVuY3Rpb24gKGV4dHJhKSB7XG4gICAgbW9kZWwuX3NldERpZmYocXVlcnkuZXh0cmFTZWdtZW50cywgZXh0cmEsIHtlcXVhbDogZGVlcEVxdWFsc30pO1xuICB9KTtcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtGdW5jdGlvbn0gY2IoZXJyLCBuZXdGZXRjaENvdW50KVxuICovXG5RdWVyeS5wcm90b3R5cGUudW5mZXRjaCA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICghY2IpIGNiID0gdGhpcy5tb2RlbC5fZGVmYXVsdENhbGxiYWNrO1xuICB0aGlzLm1vZGVsLmVtaXQoJ3VuZmV0Y2hRdWVyeScsIHRoaXMsIHRoaXMubW9kZWwuX2NvbnRleHQpO1xuXG4gIC8vIE5vIGVmZmVjdCBpZiB0aGUgcXVlcnkgaXMgbm90IGN1cnJlbnRseSBmZXRjaGVkXG4gIGlmICghdGhpcy5mZXRjaENvdW50KSB7XG4gICAgY2IoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBpZHMgPSB0aGlzLmZldGNoSWRzLnNoaWZ0KCkgfHwgW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5tb2RlbC51bmZldGNoRG9jKHRoaXMuY29sbGVjdGlvbk5hbWUsIGlkc1tpXSk7XG4gIH1cblxuICB2YXIgcXVlcnkgPSB0aGlzO1xuICBpZiAodGhpcy5tb2RlbC51bmxvYWREZWxheSkge1xuICAgIHNldFRpbWVvdXQoZmluaXNoVW5mZXRjaFF1ZXJ5LCB0aGlzLm1vZGVsLnVubG9hZERlbGF5KTtcbiAgfSBlbHNlIHtcbiAgICBmaW5pc2hVbmZldGNoUXVlcnkoKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hVbmZldGNoUXVlcnkoKSB7XG4gICAgdmFyIGNvdW50ID0gLS1xdWVyeS5mZXRjaENvdW50O1xuICAgIGlmIChjb3VudCkgcmV0dXJuIGNiKG51bGwsIGNvdW50KTtcbiAgICAvLyBDbGVhbnVwIHdoZW4gbm8gZmV0Y2hlcyBvciBzdWJzY3JpYmVzIHJlbWFpblxuICAgIGlmICghcXVlcnkuc3Vic2NyaWJlQ291bnQpIHF1ZXJ5LmRlc3Ryb3koKTtcbiAgICBjYihudWxsLCAwKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICghY2IpIGNiID0gdGhpcy5tb2RlbC5fZGVmYXVsdENhbGxiYWNrO1xuICB0aGlzLm1vZGVsLmVtaXQoJ3Vuc3Vic2NyaWJlUXVlcnknLCB0aGlzLCB0aGlzLm1vZGVsLl9jb250ZXh0KTtcblxuICAvLyBObyBlZmZlY3QgaWYgdGhlIHF1ZXJ5IGlzIG5vdCBjdXJyZW50bHkgc3Vic2NyaWJlZFxuICBpZiAoIXRoaXMuc3Vic2NyaWJlQ291bnQpIHtcbiAgICBjYigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIHF1ZXJ5ID0gdGhpcztcbiAgaWYgKHRoaXMubW9kZWwudW5sb2FkRGVsYXkpIHtcbiAgICBzZXRUaW1lb3V0KGZpbmlzaFVuc3Vic2NyaWJlUXVlcnksIHRoaXMubW9kZWwudW5sb2FkRGVsYXkpO1xuICB9IGVsc2Uge1xuICAgIGZpbmlzaFVuc3Vic2NyaWJlUXVlcnkoKTtcbiAgfVxuICBmdW5jdGlvbiBmaW5pc2hVbnN1YnNjcmliZVF1ZXJ5KCkge1xuICAgIHZhciBjb3VudCA9IC0tcXVlcnkuc3Vic2NyaWJlQ291bnQ7XG4gICAgaWYgKGNvdW50KSByZXR1cm4gY2IobnVsbCwgY291bnQpO1xuXG4gICAgaWYgKHF1ZXJ5LnNoYXJlUXVlcnkpIHtcbiAgICAgIHZhciBpZHMgPSByZXN1bHRzSWRzKHF1ZXJ5LnNoYXJlUXVlcnkucmVzdWx0cyk7XG4gICAgICBxdWVyeS5zaGFyZVF1ZXJ5LmRlc3Ryb3koKTtcbiAgICAgIHF1ZXJ5LnNoYXJlUXVlcnkgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghcXVlcnkubW9kZWwuZmV0Y2hPbmx5ICYmIGlkcyAmJiBpZHMubGVuZ3RoKSB7XG4gICAgICAvLyBVbnN1YnNjcmliZSBhbGwgZG9jdW1lbnRzIHRoYXQgdGhpcyBxdWVyeSBjdXJyZW50bHkgaGFzIGluIHJlc3VsdHNcbiAgICAgIHZhciBncm91cCA9IHV0aWwuYXN5bmNHcm91cCh1bnN1YnNjcmliZVF1ZXJ5Q2FsbGJhY2spO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcXVlcnkubW9kZWwudW5zdWJzY3JpYmVEb2MocXVlcnkuY29sbGVjdGlvbk5hbWUsIGlkc1tpXSwgZ3JvdXAoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHVuc3Vic2NyaWJlUXVlcnlDYWxsYmFjaygpO1xuICB9XG4gIGZ1bmN0aW9uIHVuc3Vic2NyaWJlUXVlcnlDYWxsYmFjayhlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKTtcbiAgICAvLyBDbGVhbnVwIHdoZW4gbm8gZmV0Y2hlcyBvciBzdWJzY3JpYmVzIHJlbWFpblxuICAgIGlmICghcXVlcnkuZmV0Y2hDb3VudCkgcXVlcnkuZGVzdHJveSgpO1xuICAgIGNiKG51bGwsIDApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUXVlcnkucHJvdG90eXBlLl9vbkluc2VydCA9IGZ1bmN0aW9uKHNoYXJlRG9jcywgaW5kZXgpIHtcbiAgdmFyIGlkcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXJlRG9jcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpZCA9IHNoYXJlRG9jc1tpXS5uYW1lO1xuICAgIGlkcy5wdXNoKGlkKTtcbiAgICB0aGlzLm1vZGVsLnN1YnNjcmliZURvYyh0aGlzLmNvbGxlY3Rpb25OYW1lLCBpZCk7XG4gIH1cbiAgdGhpcy5tb2RlbC5faW5zZXJ0KHRoaXMuaWRTZWdtZW50cywgaW5kZXgsIGlkcyk7XG59O1xuUXVlcnkucHJvdG90eXBlLl9vblJlbW92ZSA9IGZ1bmN0aW9uKHNoYXJlRG9jcywgaW5kZXgpIHtcbiAgdGhpcy5tb2RlbC5fcmVtb3ZlKHRoaXMuaWRTZWdtZW50cywgaW5kZXgsIHNoYXJlRG9jcy5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXJlRG9jcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMubW9kZWwudW5zdWJzY3JpYmVEb2ModGhpcy5jb2xsZWN0aW9uTmFtZSwgc2hhcmVEb2NzW2ldLm5hbWUpO1xuICB9XG59O1xuUXVlcnkucHJvdG90eXBlLl9vbk1vdmUgPSBmdW5jdGlvbihzaGFyZURvY3MsIGZyb20sIHRvKSB7XG4gIHRoaXMubW9kZWwuX21vdmUodGhpcy5pZFNlZ21lbnRzLCBmcm9tLCB0bywgc2hhcmVEb2NzLmxlbmd0aCk7XG59O1xuXG5RdWVyeS5wcm90b3R5cGUuX29uQ2hhbmdlID0gZnVuY3Rpb24oaWRzLCBwcmV2aW91c0lkcywgY2IpIHtcbiAgLy8gRGlmZiB0aGUgbmV3IGFuZCBwcmV2aW91cyBsaXN0IG9mIGlkcywgc3Vic2NyaWJpbmcgdG8gZG9jdW1lbnRzIGZvclxuICAvLyBpbnNlcnRlZCBpZHMgYW5kIHVuc3Vic2NyaWJpbmcgZnJvbSBkb2N1bWVudHMgZm9yIHJlbW92ZWQgaWRzXG4gIHZhciBkaWZmID0gKHByZXZpb3VzSWRzKSA/XG4gICAgYXJyYXlEaWZmKHByZXZpb3VzSWRzLCBpZHMpIDpcbiAgICBbbmV3IGFycmF5RGlmZi5JbnNlcnREaWZmKDAsIGlkcyldO1xuICB2YXIgcHJldmlvdXNDb3B5ID0gcHJldmlvdXNJZHMgJiYgcHJldmlvdXNJZHMuc2xpY2UoKTtcblxuICAvLyBUaGUgcmVzdWx0cyBhcmUgdXBkYXRlZCB2aWEgYSBkaWZmZXJlbnQgZGlmZiwgc2luY2UgdGhleSBtaWdodCBhbHJlYWR5XG4gIC8vIGhhdmUgYSB2YWx1ZSBmcm9tIGEgZmV0Y2ggb3IgcHJldmlvdXMgc2hhcmVRdWVyeSBpbnN0YW5jZVxuICB0aGlzLm1vZGVsLl9zZXREaWZmKHRoaXMuaWRTZWdtZW50cywgaWRzKTtcblxuICBpZiAoY2IpIHtcbiAgICB2YXIgZ3JvdXAgPSB1dGlsLmFzeW5jR3JvdXAoY2IpO1xuICAgIHZhciBmaW5pc2hlZCA9IGdyb3VwKCk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBkaWZmW2ldO1xuICAgIGlmIChpdGVtIGluc3RhbmNlb2YgYXJyYXlEaWZmLkluc2VydERpZmYpIHtcbiAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgZG9jdW1lbnQgZm9yIGVhY2ggaW5zZXJ0ZWQgaWRcbiAgICAgIHZhciB2YWx1ZXMgPSBpdGVtLnZhbHVlcztcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRoaXMubW9kZWwuc3Vic2NyaWJlRG9jKHRoaXMuY29sbGVjdGlvbk5hbWUsIHZhbHVlc1tqXSwgY2IgJiYgZ3JvdXAoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgYXJyYXlEaWZmLlJlbW92ZURpZmYpIHtcbiAgICAgIHZhciB2YWx1ZXMgPSBwcmV2aW91c0NvcHkuc3BsaWNlKGl0ZW0uaW5kZXgsIGl0ZW0uaG93TWFueSk7XG4gICAgICAvLyBVbnN1YnNjcmliZSBmcm9tIHRoZSBkb2N1bWVudCBmb3IgZWFjaCByZW1vdmVkIGlkXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICB0aGlzLm1vZGVsLnVuc3Vic2NyaWJlRG9jKHRoaXMuY29sbGVjdGlvbk5hbWUsIHZhbHVlc1tqXSwgY2IgJiYgZ3JvdXAoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIE1vdmluZyBkb2Vzbid0IGNoYW5nZSBkb2N1bWVudCBzdWJzY3JpcHRpb25zLCBzbyB0aGF0IGlzIGlnbm9yZWQuXG4gIH1cbiAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIGNhbGxiYWNrIGdldHMgY2FsbGVkIGlmIHRoZSBkaWZmIGlzIGVtcHR5IG9yIGl0XG4gIC8vIGNvbnRhaW5zIG5vIGluc2VydHMgb3IgcmVtb3Zlc1xuICBmaW5pc2hlZCAmJiBmaW5pc2hlZCgpO1xufTtcblxuUXVlcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgZGF0YSA9IHRoaXMubW9kZWwuX2dldCh0aGlzLnNlZ21lbnRzKTtcbiAgaWYgKCFkYXRhKSB7XG4gICAgY29uc29sZS53YXJuKCdZb3UgbXVzdCBmZXRjaCBvciBzdWJzY3JpYmUgdG8gYSBxdWVyeSBiZWZvcmUgZ2V0dGluZyBpdHMgcmVzdWx0cy4nKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICB2YXIgaWRzID0gZGF0YS5pZHM7XG4gIGlmICghaWRzKSByZXR1cm4gcmVzdWx0cztcblxuICB2YXIgY29sbGVjdGlvbiA9IHRoaXMubW9kZWwuZ2V0Q29sbGVjdGlvbih0aGlzLmNvbGxlY3Rpb25OYW1lKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpZHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGlkID0gaWRzW2ldO1xuICAgIHZhciBkb2MgPSBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24uZG9jc1tpZF07XG4gICAgcmVzdWx0cy5wdXNoKGRvYyAmJiBkb2MuZ2V0KCkpO1xuICB9XG4gIHJldHVybiAoZGF0YS5leHRyYSA9PT0gdm9pZCAwKSA/XG4gICAgcmVzdWx0cyA6XG4gICAge3Jlc3VsdHM6IHJlc3VsdHMsIGV4dHJhOiBkYXRhLmV4dHJhfTtcbn07XG5cbi8qKlxuICogTGF6aWx5IGNyZWF0ZXMgb3IgZ2V0cyBhIHJlZiB0byBvdXIgcmVzdWx0c2V0J3MgcmVzdWx0cy5cbiAqL1xuUXVlcnkucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uKGZyb20pIHtcbiAgdmFyIGlkc1BhdGggPSB0aGlzLmlkU2VnbWVudHMuam9pbignLicpO1xuICByZXR1cm4gdGhpcy5tb2RlbC5yZWZMaXN0KGZyb20sIHRoaXMuY29sbGVjdGlvbk5hbWUsIGlkc1BhdGgpO1xufTtcblxuLyoqXG4gKiBMYXppbHkgY3JlYXRlcyBvciBnZXRzIGEgcmVmIHRvIG91ciByZXN1bHRzZXQncyBleHRyYSBkYXRhLlxuICovXG5RdWVyeS5wcm90b3R5cGUuZXh0cmFSZWYgPSBmdW5jdGlvbihmcm9tLCByZWxQYXRoKSB7XG4gIHZhciBleHRyYVBhdGggPSB0aGlzLmV4dHJhU2VnbWVudHMuam9pbignLicpICsgKHJlbFBhdGggPyAnLicgKyByZWxQYXRoIDogJycpO1xuICByZXR1cm4gdGhpcy5tb2RlbC5yZWYoZnJvbSwgZXh0cmFQYXRoKTtcbn07XG5cblF1ZXJ5LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFtcbiAgICB0aGlzLmNvbGxlY3Rpb25OYW1lXG4gICwgdGhpcy5leHByZXNzaW9uXG4gICwgdGhpcy5zb3VyY2VcbiAgLCB0aGlzLnN1YnNjcmliZUNvdW50XG4gICwgdGhpcy5mZXRjaENvdW50XG4gICwgdGhpcy5mZXRjaElkc1xuICBdO1xufTtcblxuZnVuY3Rpb24gcXVlcnlIYXNoKGNvbGxlY3Rpb25OYW1lLCBleHByZXNzaW9uLCBzb3VyY2UpIHtcbiAgdmFyIGFyZ3MgPSBbY29sbGVjdGlvbk5hbWUsIGV4cHJlc3Npb24sIHNvdXJjZV07XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzKS5yZXBsYWNlKC9cXC4vZywgJ3wnKTtcbn1cblxuZnVuY3Rpb24gcmVzdWx0c0lkcyhyZXN1bHRzKSB7XG4gIHZhciBpZHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNoYXJlRG9jID0gcmVzdWx0c1tpXTtcbiAgICBpZHMucHVzaChzaGFyZURvYy5uYW1lKTtcbiAgfVxuICByZXR1cm4gaWRzO1xufVxuXG5mdW5jdGlvbiBwYXRoSWRzKG1vZGVsLCBzZWdtZW50cykge1xuICB2YXIgdmFsdWUgPSBtb2RlbC5fZ2V0KHNlZ21lbnRzKTtcbiAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSA/IFt2YWx1ZV0gOlxuICAgIChBcnJheS5pc0FycmF5KHZhbHVlKSkgPyB2YWx1ZS5zbGljZSgpIDogW107XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb25TaGFyZURvY3MobW9kZWwsIGNvbGxlY3Rpb25OYW1lKSB7XG4gIHZhciBjb2xsZWN0aW9uID0gbW9kZWwuZ2V0Q29sbGVjdGlvbihjb2xsZWN0aW9uTmFtZSk7XG4gIGlmICghY29sbGVjdGlvbikgcmV0dXJuO1xuXG4gIHZhciByZXN1bHRzID0gW107XG4gIGZvciAodmFyIG5hbWUgaW4gY29sbGVjdGlvbi5kb2NzKSB7XG4gICAgcmVzdWx0cy5wdXNoKGNvbGxlY3Rpb24uZG9jc1tuYW1lXS5zaGFyZURvYyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuXG59KShyZXF1aXJlKFwiX19icm93c2VyaWZ5X3Byb2Nlc3NcIikpIiwidmFyIHNoYSA9IHJlcXVpcmUoJy4vc2hhJylcbnZhciBybmcgPSByZXF1aXJlKCcuL3JuZycpXG52YXIgbWQ1ID0gcmVxdWlyZSgnLi9tZDUnKVxuXG52YXIgYWxnb3JpdGhtcyA9IHtcbiAgc2hhMToge1xuICAgIGhleDogc2hhLmhleF9zaGExLFxuICAgIGJpbmFyeTogc2hhLmI2NF9zaGExLFxuICAgIGFzY2lpOiBzaGEuc3RyX3NoYTFcbiAgfSxcbiAgbWQ1OiB7XG4gICAgaGV4OiBtZDUuaGV4X21kNSxcbiAgICBiaW5hcnk6IG1kNS5iNjRfbWQ1LFxuICAgIGFzY2lpOiBtZDUuYW55X21kNVxuICB9XG59XG5cbmZ1bmN0aW9uIGVycm9yICgpIHtcbiAgdmFyIG0gPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpXG4gIHRocm93IG5ldyBFcnJvcihbXG4gICAgbSxcbiAgICAnd2UgYWNjZXB0IHB1bGwgcmVxdWVzdHMnLFxuICAgICdodHRwOi8vZ2l0aHViLmNvbS9kb21pbmljdGFyci9jcnlwdG8tYnJvd3NlcmlmeSdcbiAgICBdLmpvaW4oJ1xcbicpKVxufVxuXG5leHBvcnRzLmNyZWF0ZUhhc2ggPSBmdW5jdGlvbiAoYWxnKSB7XG4gIGFsZyA9IGFsZyB8fCAnc2hhMSdcbiAgaWYoIWFsZ29yaXRobXNbYWxnXSlcbiAgICBlcnJvcignYWxnb3JpdGhtOicsIGFsZywgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkJylcbiAgdmFyIHMgPSAnJ1xuICB2YXIgX2FsZyA9IGFsZ29yaXRobXNbYWxnXVxuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIHMgKz0gZGF0YVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGRpZ2VzdDogZnVuY3Rpb24gKGVuYykge1xuICAgICAgZW5jID0gZW5jIHx8ICdiaW5hcnknXG4gICAgICB2YXIgZm5cbiAgICAgIGlmKCEoZm4gPSBfYWxnW2VuY10pKVxuICAgICAgICBlcnJvcignZW5jb2Rpbmc6JywgZW5jICwgJ2lzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBhbGdvcml0aG0nLCBhbGcpXG4gICAgICB2YXIgciA9IGZuKHMpXG4gICAgICBzID0gbnVsbCAvL25vdCBtZWFudCB0byB1c2UgdGhlIGhhc2ggYWZ0ZXIgeW91J3ZlIGNhbGxlZCBkaWdlc3QuXG4gICAgICByZXR1cm4gclxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24oc2l6ZSwgY2FsbGJhY2spIHtcbiAgaWYgKGNhbGxiYWNrICYmIGNhbGxiYWNrLmNhbGwpIHtcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB1bmRlZmluZWQsIHJuZyhzaXplKSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7IGNhbGxiYWNrKGVycik7IH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm5nKHNpemUpO1xuICB9XG59XG5cbi8vIHRoZSBsZWFzdCBJIGNhbiBkbyBpcyBtYWtlIGVycm9yIG1lc3NhZ2VzIGZvciB0aGUgcmVzdCBvZiB0aGUgbm9kZS5qcy9jcnlwdG8gYXBpLlxuO1snY3JlYXRlQ3JlZGVudGlhbHMnXG4sICdjcmVhdGVIbWFjJ1xuLCAnY3JlYXRlQ3lwaGVyJ1xuLCAnY3JlYXRlQ3lwaGVyaXYnXG4sICdjcmVhdGVEZWNpcGhlcidcbiwgJ2NyZWF0ZURlY2lwaGVyaXYnXG4sICdjcmVhdGVTaWduJ1xuLCAnY3JlYXRlVmVyaWZ5J1xuLCAnY3JlYXRlRGVmZmllSGVsbG1hbidcbiwgJ3Bia2RmMiddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgZXhwb3J0c1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignc29ycnksJywgbmFtZSwgJ2lzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKVxuICB9XG59KVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhcnJheURpZmY7XG5cbi8vIEJhc2VkIG9uIHNvbWUgcm91Z2ggYmVuY2htYXJraW5nLCB0aGlzIGFsZ29yaXRobSBpcyBhYm91dCBPKDJuKSB3b3JzdCBjYXNlLFxuLy8gYW5kIGl0IGNhbiBjb21wdXRlIGRpZmZzIG9uIHJhbmRvbSBhcnJheXMgb2YgbGVuZ3RoIDEwMjQgaW4gYWJvdXQgMzRtcyxcbi8vIHRob3VnaCBqdXN0IGEgZmV3IGNoYW5nZXMgb24gYW4gYXJyYXkgb2YgbGVuZ3RoIDEwMjQgdGFrZXMgYWJvdXQgMC41bXNcblxuYXJyYXlEaWZmLkluc2VydERpZmYgPSBJbnNlcnREaWZmO1xuYXJyYXlEaWZmLlJlbW92ZURpZmYgPSBSZW1vdmVEaWZmO1xuYXJyYXlEaWZmLk1vdmVEaWZmID0gTW92ZURpZmY7XG5cbmZ1bmN0aW9uIEluc2VydERpZmYoaW5kZXgsIHZhbHVlcykge1xuICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gIHRoaXMudmFsdWVzID0gdmFsdWVzO1xufVxuSW5zZXJ0RGlmZi5wcm90b3R5cGUudHlwZSA9ICdpbnNlcnQnO1xuSW5zZXJ0RGlmZi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdGhpcy50eXBlXG4gICwgaW5kZXg6IHRoaXMuaW5kZXhcbiAgLCB2YWx1ZXM6IHRoaXMudmFsdWVzXG4gIH07XG59O1xuXG5mdW5jdGlvbiBSZW1vdmVEaWZmKGluZGV4LCBob3dNYW55KSB7XG4gIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgdGhpcy5ob3dNYW55ID0gaG93TWFueTtcbn1cblJlbW92ZURpZmYucHJvdG90eXBlLnR5cGUgPSAncmVtb3ZlJztcblJlbW92ZURpZmYucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHRoaXMudHlwZVxuICAsIGluZGV4OiB0aGlzLmluZGV4XG4gICwgaG93TWFueTogdGhpcy5ob3dNYW55XG4gIH07XG59O1xuXG5mdW5jdGlvbiBNb3ZlRGlmZihmcm9tLCB0bywgaG93TWFueSkge1xuICB0aGlzLmZyb20gPSBmcm9tO1xuICB0aGlzLnRvID0gdG87XG4gIHRoaXMuaG93TWFueSA9IGhvd01hbnk7XG59XG5Nb3ZlRGlmZi5wcm90b3R5cGUudHlwZSA9ICdtb3ZlJztcbk1vdmVEaWZmLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0aGlzLnR5cGVcbiAgLCBmcm9tOiB0aGlzLmZyb21cbiAgLCB0bzogdGhpcy50b1xuICAsIGhvd01hbnk6IHRoaXMuaG93TWFueVxuICB9O1xufTtcblxuZnVuY3Rpb24gc3RyaWN0RXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYjtcbn1cblxuZnVuY3Rpb24gYXJyYXlEaWZmKGJlZm9yZSwgYWZ0ZXIsIGVxdWFsRm4pIHtcbiAgaWYgKCFlcXVhbEZuKSBlcXVhbEZuID0gc3RyaWN0RXF1YWw7XG5cbiAgLy8gRmluZCBhbGwgaXRlbXMgaW4gYm90aCB0aGUgYmVmb3JlIGFuZCBhZnRlciBhcnJheSwgYW5kIHJlcHJlc2VudCB0aGVtXG4gIC8vIGFzIG1vdmVzLiBNYW55IG9mIHRoZXNlIFwibW92ZXNcIiBtYXkgZW5kIHVwIGJlaW5nIGRpc2NhcmRlZCBpbiB0aGUgbGFzdFxuICAvLyBwYXNzIGlmIHRoZXkgYXJlIGZyb20gYW4gaW5kZXggdG8gdGhlIHNhbWUgaW5kZXgsIGJ1dCB3ZSBkb24ndCBrbm93IHRoaXNcbiAgLy8gdXAgZnJvbnQsIHNpbmNlIHdlIGhhdmVuJ3QgeWV0IG9mZnNldCB0aGUgaW5kaWNlcy5cbiAgLy8gXG4gIC8vIEFsc28ga2VlcCBhIG1hcCBvZiBhbGwgdGhlIGluZGljaWVzIGFjY291bnRlZCBmb3IgaW4gdGhlIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgLy8gYXJyYXlzLiBUaGVzZSBtYXBzIGFyZSB1c2VkIG5leHQgdG8gY3JlYXRlIGluc2VydCBhbmQgcmVtb3ZlIGRpZmZzLlxuICB2YXIgYmVmb3JlTGVuZ3RoID0gYmVmb3JlLmxlbmd0aDtcbiAgdmFyIGFmdGVyTGVuZ3RoID0gYWZ0ZXIubGVuZ3RoO1xuICB2YXIgbW92ZXMgPSBbXTtcbiAgdmFyIGJlZm9yZU1hcmtlZCA9IHt9O1xuICB2YXIgYWZ0ZXJNYXJrZWQgPSB7fTtcbiAgZm9yICh2YXIgYmVmb3JlSW5kZXggPSAwOyBiZWZvcmVJbmRleCA8IGJlZm9yZUxlbmd0aDsgYmVmb3JlSW5kZXgrKykge1xuICAgIHZhciBiZWZvcmVJdGVtID0gYmVmb3JlW2JlZm9yZUluZGV4XTtcbiAgICBmb3IgKHZhciBhZnRlckluZGV4ID0gMDsgYWZ0ZXJJbmRleCA8IGFmdGVyTGVuZ3RoOyBhZnRlckluZGV4KyspIHtcbiAgICAgIGlmIChhZnRlck1hcmtlZFthZnRlckluZGV4XSkgY29udGludWU7XG4gICAgICBpZiAoIWVxdWFsRm4oYmVmb3JlSXRlbSwgYWZ0ZXJbYWZ0ZXJJbmRleF0pKSBjb250aW51ZTtcbiAgICAgIHZhciBmcm9tID0gYmVmb3JlSW5kZXg7XG4gICAgICB2YXIgdG8gPSBhZnRlckluZGV4O1xuICAgICAgdmFyIGhvd01hbnkgPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBiZWZvcmVNYXJrZWRbYmVmb3JlSW5kZXgrK10gPSBhZnRlck1hcmtlZFthZnRlckluZGV4KytdID0gdHJ1ZTtcbiAgICAgICAgaG93TWFueSsrO1xuICAgICAgfSB3aGlsZSAoXG4gICAgICAgIGJlZm9yZUluZGV4IDwgYmVmb3JlTGVuZ3RoICYmXG4gICAgICAgIGFmdGVySW5kZXggPCBhZnRlckxlbmd0aCAmJlxuICAgICAgICBlcXVhbEZuKGJlZm9yZVtiZWZvcmVJbmRleF0sIGFmdGVyW2FmdGVySW5kZXhdKSAmJlxuICAgICAgICAhYWZ0ZXJNYXJrZWRbYWZ0ZXJJbmRleF1cbiAgICAgICk7XG4gICAgICBtb3Zlcy5wdXNoKG5ldyBNb3ZlRGlmZihmcm9tLCB0bywgaG93TWFueSkpO1xuICAgICAgYmVmb3JlSW5kZXgtLTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIHJlbW92ZSBmb3IgYWxsIG9mIHRoZSBpdGVtcyBpbiB0aGUgYmVmb3JlIGFycmF5IHRoYXQgd2VyZVxuICAvLyBub3QgbWFya2VkIGFzIGJlaW5nIG1hdGNoZWQgaW4gdGhlIGFmdGVyIGFycmF5IGFzIHdlbGxcbiAgdmFyIHJlbW92ZXMgPSBbXTtcbiAgZm9yIChiZWZvcmVJbmRleCA9IDA7IGJlZm9yZUluZGV4IDwgYmVmb3JlTGVuZ3RoOykge1xuICAgIGlmIChiZWZvcmVNYXJrZWRbYmVmb3JlSW5kZXhdKSB7XG4gICAgICBiZWZvcmVJbmRleCsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGJlZm9yZUluZGV4O1xuICAgIHZhciBob3dNYW55ID0gMDtcbiAgICB3aGlsZSAoYmVmb3JlSW5kZXggPCBiZWZvcmVMZW5ndGggJiYgIWJlZm9yZU1hcmtlZFtiZWZvcmVJbmRleCsrXSkge1xuICAgICAgaG93TWFueSsrO1xuICAgIH1cbiAgICByZW1vdmVzLnB1c2gobmV3IFJlbW92ZURpZmYoaW5kZXgsIGhvd01hbnkpKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhbiBpbnNlcnQgZm9yIGFsbCBvZiB0aGUgaXRlbXMgaW4gdGhlIGFmdGVyIGFycmF5IHRoYXQgd2VyZVxuICAvLyBub3QgbWFya2VkIGFzIGJlaW5nIG1hdGNoZWQgaW4gdGhlIGJlZm9yZSBhcnJheSBhcyB3ZWxsXG4gIHZhciBpbnNlcnRzID0gW107XG4gIGZvciAoYWZ0ZXJJbmRleCA9IDA7IGFmdGVySW5kZXggPCBhZnRlckxlbmd0aDspIHtcbiAgICBpZiAoYWZ0ZXJNYXJrZWRbYWZ0ZXJJbmRleF0pIHtcbiAgICAgIGFmdGVySW5kZXgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBhZnRlckluZGV4O1xuICAgIHZhciBob3dNYW55ID0gMDtcbiAgICB3aGlsZSAoYWZ0ZXJJbmRleCA8IGFmdGVyTGVuZ3RoICYmICFhZnRlck1hcmtlZFthZnRlckluZGV4KytdKSB7XG4gICAgICBob3dNYW55Kys7XG4gICAgfVxuICAgIHZhciB2YWx1ZXMgPSBhZnRlci5zbGljZShpbmRleCwgaW5kZXggKyBob3dNYW55KTtcbiAgICBpbnNlcnRzLnB1c2gobmV3IEluc2VydERpZmYoaW5kZXgsIHZhbHVlcykpO1xuICB9XG5cbiAgdmFyIGluc2VydHNMZW5ndGggPSBpbnNlcnRzLmxlbmd0aDtcbiAgdmFyIHJlbW92ZXNMZW5ndGggPSByZW1vdmVzLmxlbmd0aDtcbiAgdmFyIG1vdmVzTGVuZ3RoID0gbW92ZXMubGVuZ3RoO1xuICB2YXIgaSwgajtcblxuICAvLyBPZmZzZXQgc3Vic2VxdWVudCByZW1vdmVzIGFuZCBtb3ZlcyBieSByZW1vdmVzXG4gIHZhciBjb3VudCA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCByZW1vdmVzTGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcmVtb3ZlID0gcmVtb3Zlc1tpXTtcbiAgICByZW1vdmUuaW5kZXggLT0gY291bnQ7XG4gICAgY291bnQgKz0gcmVtb3ZlLmhvd01hbnk7XG4gICAgZm9yIChqID0gMDsgaiA8IG1vdmVzTGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBtb3ZlID0gbW92ZXNbal07XG4gICAgICBpZiAobW92ZS5mcm9tID49IHJlbW92ZS5pbmRleCkgbW92ZS5mcm9tIC09IHJlbW92ZS5ob3dNYW55O1xuICAgIH1cbiAgfVxuXG4gIC8vIE9mZnNldCBtb3ZlcyBieSBpbnNlcnRzXG4gIGZvciAoaSA9IGluc2VydHNMZW5ndGg7IGktLTspIHtcbiAgICB2YXIgaW5zZXJ0ID0gaW5zZXJ0c1tpXTtcbiAgICB2YXIgaG93TWFueSA9IGluc2VydC52YWx1ZXMubGVuZ3RoO1xuICAgIGZvciAoaiA9IG1vdmVzTGVuZ3RoOyBqLS07KSB7XG4gICAgICB2YXIgbW92ZSA9IG1vdmVzW2pdO1xuICAgICAgaWYgKG1vdmUudG8gPj0gaW5zZXJ0LmluZGV4KSBtb3ZlLnRvIC09IGhvd01hbnk7XG4gICAgfVxuICB9XG5cbiAgLy8gT2Zmc2V0IHRoZSB0byBvZiBtb3ZlcyBieSBsYXRlciBtb3Zlc1xuICBmb3IgKGkgPSBtb3Zlc0xlbmd0aDsgaS0tID4gMTspIHtcbiAgICB2YXIgbW92ZSA9IG1vdmVzW2ldO1xuICAgIGlmIChtb3ZlLnRvID09PSBtb3ZlLmZyb20pIGNvbnRpbnVlO1xuICAgIGZvciAoaiA9IGk7IGotLTspIHtcbiAgICAgIHZhciBlYXJsaWVyID0gbW92ZXNbal07XG4gICAgICBpZiAoZWFybGllci50byA+PSBtb3ZlLnRvKSBlYXJsaWVyLnRvIC09IG1vdmUuaG93TWFueTtcbiAgICAgIGlmIChlYXJsaWVyLnRvID49IG1vdmUuZnJvbSkgZWFybGllci50byArPSBtb3ZlLmhvd01hbnk7XG4gICAgfVxuICB9XG5cbiAgLy8gT25seSBvdXRwdXQgbW92ZXMgdGhhdCBlbmQgdXAgaGF2aW5nIGFuIGVmZmVjdCBhZnRlciBvZmZzZXR0aW5nXG4gIHZhciBvdXRwdXRNb3ZlcyA9IFtdO1xuXG4gIC8vIE9mZnNldCB0aGUgZnJvbSBvZiBtb3ZlcyBieSBlYXJsaWVyIG1vdmVzXG4gIGZvciAoaSA9IDA7IGkgPCBtb3Zlc0xlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1vdmUgPSBtb3Zlc1tpXTtcbiAgICBpZiAobW92ZS50byA9PT0gbW92ZS5mcm9tKSBjb250aW51ZTtcbiAgICBvdXRwdXRNb3Zlcy5wdXNoKG1vdmUpO1xuICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbW92ZXNMZW5ndGg7IGorKykge1xuICAgICAgdmFyIGxhdGVyID0gbW92ZXNbal07XG4gICAgICBpZiAobGF0ZXIuZnJvbSA+PSBtb3ZlLmZyb20pIGxhdGVyLmZyb20gLT0gbW92ZS5ob3dNYW55O1xuICAgICAgaWYgKGxhdGVyLmZyb20gPj0gbW92ZS50bykgbGF0ZXIuZnJvbSArPSBtb3ZlLmhvd01hbnk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlbW92ZXMuY29uY2F0KG91dHB1dE1vdmVzLCBpbnNlcnRzKTtcbn1cbiIsIi8qXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFNlY3VyZSBIYXNoIEFsZ29yaXRobSwgU0hBLTEsIGFzIGRlZmluZWRcbiAqIGluIEZJUFMgUFVCIDE4MC0xXG4gKiBWZXJzaW9uIDIuMWEgQ29weXJpZ2h0IFBhdWwgSm9obnN0b24gMjAwMCAtIDIwMDIuXG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBkZXRhaWxzLlxuICovXG5cbmV4cG9ydHMuaGV4X3NoYTEgPSBoZXhfc2hhMTtcbmV4cG9ydHMuYjY0X3NoYTEgPSBiNjRfc2hhMTtcbmV4cG9ydHMuc3RyX3NoYTEgPSBzdHJfc2hhMTtcbmV4cG9ydHMuaGV4X2htYWNfc2hhMSA9IGhleF9obWFjX3NoYTE7XG5leHBvcnRzLmI2NF9obWFjX3NoYTEgPSBiNjRfaG1hY19zaGExO1xuZXhwb3J0cy5zdHJfaG1hY19zaGExID0gc3RyX2htYWNfc2hhMTtcblxuLypcbiAqIENvbmZpZ3VyYWJsZSB2YXJpYWJsZXMuIFlvdSBtYXkgbmVlZCB0byB0d2VhayB0aGVzZSB0byBiZSBjb21wYXRpYmxlIHdpdGhcbiAqIHRoZSBzZXJ2ZXItc2lkZSwgYnV0IHRoZSBkZWZhdWx0cyB3b3JrIGluIG1vc3QgY2FzZXMuXG4gKi9cbnZhciBoZXhjYXNlID0gMDsgIC8qIGhleCBvdXRwdXQgZm9ybWF0LiAwIC0gbG93ZXJjYXNlOyAxIC0gdXBwZXJjYXNlICAgICAgICAqL1xudmFyIGI2NHBhZCAgPSBcIlwiOyAvKiBiYXNlLTY0IHBhZCBjaGFyYWN0ZXIuIFwiPVwiIGZvciBzdHJpY3QgUkZDIGNvbXBsaWFuY2UgICAqL1xudmFyIGNocnN6ICAgPSA4OyAgLyogYml0cyBwZXIgaW5wdXQgY2hhcmFjdGVyLiA4IC0gQVNDSUk7IDE2IC0gVW5pY29kZSAgICAgICovXG5cbi8qXG4gKiBUaGVzZSBhcmUgdGhlIGZ1bmN0aW9ucyB5b3UnbGwgdXN1YWxseSB3YW50IHRvIGNhbGxcbiAqIFRoZXkgdGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIGhleCBvciBiYXNlLTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5mdW5jdGlvbiBoZXhfc2hhMShzKXtyZXR1cm4gYmluYjJoZXgoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBiNjRfc2hhMShzKXtyZXR1cm4gYmluYjJiNjQoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBzdHJfc2hhMShzKXtyZXR1cm4gYmluYjJzdHIoY29yZV9zaGExKHN0cjJiaW5iKHMpLHMubGVuZ3RoICogY2hyc3opKTt9XG5mdW5jdGlvbiBoZXhfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMmhleChjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5mdW5jdGlvbiBiNjRfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMmI2NChjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5mdW5jdGlvbiBzdHJfaG1hY19zaGExKGtleSwgZGF0YSl7IHJldHVybiBiaW5iMnN0cihjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpKTt9XG5cbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNlbGYtdGVzdCB0byBzZWUgaWYgdGhlIFZNIGlzIHdvcmtpbmdcbiAqL1xuZnVuY3Rpb24gc2hhMV92bV90ZXN0KClcbntcbiAgcmV0dXJuIGhleF9zaGExKFwiYWJjXCIpID09IFwiYTk5OTNlMzY0NzA2ODE2YWJhM2UyNTcxNzg1MGMyNmM5Y2QwZDg5ZFwiO1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBTSEEtMSBvZiBhbiBhcnJheSBvZiBiaWctZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvcmVfc2hhMSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbGVuICUgMzIpO1xuICB4WygobGVuICsgNjQgPj4gOSkgPDwgNCkgKyAxNV0gPSBsZW47XG5cbiAgdmFyIHcgPSBBcnJheSg4MCk7XG4gIHZhciBhID0gIDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAgMjcxNzMzODc4O1xuICB2YXIgZSA9IC0xMDA5NTg5Nzc2O1xuXG4gIGZvcih2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNilcbiAge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICB2YXIgb2xkZSA9IGU7XG5cbiAgICBmb3IodmFyIGogPSAwOyBqIDwgODA7IGorKylcbiAgICB7XG4gICAgICBpZihqIDwgMTYpIHdbal0gPSB4W2kgKyBqXTtcbiAgICAgIGVsc2Ugd1tqXSA9IHJvbCh3W2otM10gXiB3W2otOF0gXiB3W2otMTRdIF4gd1tqLTE2XSwgMSk7XG4gICAgICB2YXIgdCA9IHNhZmVfYWRkKHNhZmVfYWRkKHJvbChhLCA1KSwgc2hhMV9mdChqLCBiLCBjLCBkKSksXG4gICAgICAgICAgICAgICAgICAgICAgIHNhZmVfYWRkKHNhZmVfYWRkKGUsIHdbal0pLCBzaGExX2t0KGopKSk7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IHJvbChiLCAzMCk7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSB0O1xuICAgIH1cblxuICAgIGEgPSBzYWZlX2FkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZV9hZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlX2FkZChkLCBvbGRkKTtcbiAgICBlID0gc2FmZV9hZGQoZSwgb2xkZSk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQsIGUpO1xuXG59XG5cbi8qXG4gKiBQZXJmb3JtIHRoZSBhcHByb3ByaWF0ZSB0cmlwbGV0IGNvbWJpbmF0aW9uIGZ1bmN0aW9uIGZvciB0aGUgY3VycmVudFxuICogaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfZnQodCwgYiwgYywgZClcbntcbiAgaWYodCA8IDIwKSByZXR1cm4gKGIgJiBjKSB8ICgofmIpICYgZCk7XG4gIGlmKHQgPCA0MCkgcmV0dXJuIGIgXiBjIF4gZDtcbiAgaWYodCA8IDYwKSByZXR1cm4gKGIgJiBjKSB8IChiICYgZCkgfCAoYyAmIGQpO1xuICByZXR1cm4gYiBeIGMgXiBkO1xufVxuXG4vKlxuICogRGV0ZXJtaW5lIHRoZSBhcHByb3ByaWF0ZSBhZGRpdGl2ZSBjb25zdGFudCBmb3IgdGhlIGN1cnJlbnQgaXRlcmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHNoYTFfa3QodClcbntcbiAgcmV0dXJuICh0IDwgMjApID8gIDE1MTg1MDAyNDkgOiAodCA8IDQwKSA/ICAxODU5Nzc1MzkzIDpcbiAgICAgICAgICh0IDwgNjApID8gLTE4OTQwMDc1ODggOiAtODk5NDk3NTE0O1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBITUFDLVNIQTEgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YVxuICovXG5mdW5jdGlvbiBjb3JlX2htYWNfc2hhMShrZXksIGRhdGEpXG57XG4gIHZhciBia2V5ID0gc3RyMmJpbmIoa2V5KTtcbiAgaWYoYmtleS5sZW5ndGggPiAxNikgYmtleSA9IGNvcmVfc2hhMShia2V5LCBrZXkubGVuZ3RoICogY2hyc3opO1xuXG4gIHZhciBpcGFkID0gQXJyYXkoMTYpLCBvcGFkID0gQXJyYXkoMTYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAge1xuICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjtcbiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XG4gIH1cblxuICB2YXIgaGFzaCA9IGNvcmVfc2hhMShpcGFkLmNvbmNhdChzdHIyYmluYihkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogY2hyc3opO1xuICByZXR1cm4gY29yZV9zaGExKG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxNjApO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gcm9sKG51bSwgY250KVxue1xuICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSk7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIDgtYml0IG9yIDE2LWJpdCBzdHJpbmcgdG8gYW4gYXJyYXkgb2YgYmlnLWVuZGlhbiB3b3Jkc1xuICogSW4gOC1iaXQgZnVuY3Rpb24sIGNoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuZnVuY3Rpb24gc3RyMmJpbmIoc3RyKVxue1xuICB2YXIgYmluID0gQXJyYXkoKTtcbiAgdmFyIG1hc2sgPSAoMSA8PCBjaHJzeikgLSAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aCAqIGNocnN6OyBpICs9IGNocnN6KVxuICAgIGJpbltpPj41XSB8PSAoc3RyLmNoYXJDb2RlQXQoaSAvIGNocnN6KSAmIG1hc2spIDw8ICgzMiAtIGNocnN6IC0gaSUzMik7XG4gIHJldHVybiBiaW47XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYmluYjJzdHIoYmluKVxue1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdmFyIG1hc2sgPSAoMSA8PCBjaHJzeikgLSAxO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgYmluLmxlbmd0aCAqIDMyOyBpICs9IGNocnN6KVxuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChiaW5baT4+NV0gPj4+ICgzMiAtIGNocnN6IC0gaSUzMikpICYgbWFzayk7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBoZXggc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiaW5iMmhleChiaW5hcnJheSlcbntcbiAgdmFyIGhleF90YWIgPSBoZXhjYXNlID8gXCIwMTIzNDU2Nzg5QUJDREVGXCIgOiBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgdmFyIHN0ciA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBiaW5hcnJheS5sZW5ndGggKiA0OyBpKyspXG4gIHtcbiAgICBzdHIgKz0gaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoMyAtIGklNCkqOCs0KSkgJiAweEYpICtcbiAgICAgICAgICAgaGV4X3RhYi5jaGFyQXQoKGJpbmFycmF5W2k+PjJdID4+ICgoMyAtIGklNCkqOCAgKSkgJiAweEYpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGJpZy1lbmRpYW4gd29yZHMgdG8gYSBiYXNlLTY0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBiaW5iMmI2NChiaW5hcnJheSlcbntcbiAgdmFyIHRhYiA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiO1xuICB2YXIgc3RyID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGJpbmFycmF5Lmxlbmd0aCAqIDQ7IGkgKz0gMylcbiAge1xuICAgIHZhciB0cmlwbGV0ID0gKCgoYmluYXJyYXlbaSAgID4+IDJdID4+IDggKiAoMyAtICBpICAgJTQpKSAmIDB4RkYpIDw8IDE2KVxuICAgICAgICAgICAgICAgIHwgKCgoYmluYXJyYXlbaSsxID4+IDJdID4+IDggKiAoMyAtIChpKzEpJTQpKSAmIDB4RkYpIDw8IDggKVxuICAgICAgICAgICAgICAgIHwgICgoYmluYXJyYXlbaSsyID4+IDJdID4+IDggKiAoMyAtIChpKzIpJTQpKSAmIDB4RkYpO1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAge1xuICAgICAgaWYoaSAqIDggKyBqICogNiA+IGJpbmFycmF5Lmxlbmd0aCAqIDMyKSBzdHIgKz0gYjY0cGFkO1xuICAgICAgZWxzZSBzdHIgKz0gdGFiLmNoYXJBdCgodHJpcGxldCA+PiA2KigzLWopKSAmIDB4M0YpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4iLCIvLyBPcmlnaW5hbCBjb2RlIGFkYXB0ZWQgZnJvbSBSb2JlcnQgS2llZmZlci5cbi8vIGRldGFpbHMgYXQgaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLXV1aWRcbihmdW5jdGlvbigpIHtcbiAgdmFyIF9nbG9iYWwgPSB0aGlzO1xuXG4gIHZhciBtYXRoUk5HLCB3aGF0d2dSTkc7XG5cbiAgLy8gTk9URTogTWF0aC5yYW5kb20oKSBkb2VzIG5vdCBndWFyYW50ZWUgXCJjcnlwdG9ncmFwaGljIHF1YWxpdHlcIlxuICBtYXRoUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShzaXplKTtcbiAgICB2YXIgcjtcblxuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PSAwKSByID0gTWF0aC5yYW5kb20oKSAqIDB4MTAwMDAwMDAwO1xuICAgICAgYnl0ZXNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9XG5cbiAgLy8gY3VycmVudGx5IG9ubHkgYXZhaWxhYmxlIGluIHdlYmtpdC1iYXNlZCBicm93c2Vycy5cbiAgaWYgKF9nbG9iYWwuY3J5cHRvICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICB2YXIgX3JuZHMgPSBuZXcgVWludDMyQXJyYXkoNCk7XG4gICAgd2hhdHdnUk5HID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KHNpemUpO1xuICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhfcm5kcyk7XG5cbiAgICAgIGZvciAodmFyIGMgPSAwIDsgYyA8IHNpemU7IGMrKykge1xuICAgICAgICBieXRlc1tjXSA9IF9ybmRzW2MgPj4gMl0gPj4+ICgoYyAmIDB4MDMpICogOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfVxuXG4gIG1vZHVsZS5leHBvcnRzID0gd2hhdHdnUk5HIHx8IG1hdGhSTkc7XG5cbn0oKSkiLCIvKlxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5cbi8qXG4gKiBDb25maWd1cmFibGUgdmFyaWFibGVzLiBZb3UgbWF5IG5lZWQgdG8gdHdlYWsgdGhlc2UgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gKiB0aGUgc2VydmVyLXNpZGUsIGJ1dCB0aGUgZGVmYXVsdHMgd29yayBpbiBtb3N0IGNhc2VzLlxuICovXG52YXIgaGV4Y2FzZSA9IDA7ICAgLyogaGV4IG91dHB1dCBmb3JtYXQuIDAgLSBsb3dlcmNhc2U7IDEgLSB1cHBlcmNhc2UgICAgICAgICovXG52YXIgYjY0cGFkICA9IFwiXCI7ICAvKiBiYXNlLTY0IHBhZCBjaGFyYWN0ZXIuIFwiPVwiIGZvciBzdHJpY3QgUkZDIGNvbXBsaWFuY2UgICAqL1xuXG4vKlxuICogVGhlc2UgYXJlIHRoZSBmdW5jdGlvbnMgeW91J2xsIHVzdWFsbHkgd2FudCB0byBjYWxsXG4gKiBUaGV5IHRha2Ugc3RyaW5nIGFyZ3VtZW50cyBhbmQgcmV0dXJuIGVpdGhlciBoZXggb3IgYmFzZS02NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuZnVuY3Rpb24gaGV4X21kNShzKSAgICB7IHJldHVybiByc3RyMmhleChyc3RyX21kNShzdHIycnN0cl91dGY4KHMpKSk7IH1cbmZ1bmN0aW9uIGI2NF9tZDUocykgICAgeyByZXR1cm4gcnN0cjJiNjQocnN0cl9tZDUoc3RyMnJzdHJfdXRmOChzKSkpOyB9XG5mdW5jdGlvbiBhbnlfbWQ1KHMsIGUpIHsgcmV0dXJuIHJzdHIyYW55KHJzdHJfbWQ1KHN0cjJyc3RyX3V0ZjgocykpLCBlKTsgfVxuZnVuY3Rpb24gaGV4X2htYWNfbWQ1KGssIGQpXG4gIHsgcmV0dXJuIHJzdHIyaGV4KHJzdHJfaG1hY19tZDUoc3RyMnJzdHJfdXRmOChrKSwgc3RyMnJzdHJfdXRmOChkKSkpOyB9XG5mdW5jdGlvbiBiNjRfaG1hY19tZDUoaywgZClcbiAgeyByZXR1cm4gcnN0cjJiNjQocnN0cl9obWFjX21kNShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKSk7IH1cbmZ1bmN0aW9uIGFueV9obWFjX21kNShrLCBkLCBlKVxuICB7IHJldHVybiByc3RyMmFueShyc3RyX2htYWNfbWQ1KHN0cjJyc3RyX3V0ZjgoayksIHN0cjJyc3RyX3V0ZjgoZCkpLCBlKTsgfVxuXG4vKlxuICogUGVyZm9ybSBhIHNpbXBsZSBzZWxmLXRlc3QgdG8gc2VlIGlmIHRoZSBWTSBpcyB3b3JraW5nXG4gKi9cbmZ1bmN0aW9uIG1kNV92bV90ZXN0KClcbntcbiAgcmV0dXJuIGhleF9tZDUoXCJhYmNcIikudG9Mb3dlckNhc2UoKSA9PSBcIjkwMDE1MDk4M2NkMjRmYjBkNjk2M2Y3ZDI4ZTE3ZjcyXCI7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhIHJhdyBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cl9tZDUocylcbntcbiAgcmV0dXJuIGJpbmwycnN0cihiaW5sX21kNShyc3RyMmJpbmwocyksIHMubGVuZ3RoICogOCkpO1xufVxuXG4vKlxuICogQ2FsY3VsYXRlIHRoZSBITUFDLU1ENSwgb2YgYSBrZXkgYW5kIHNvbWUgZGF0YSAocmF3IHN0cmluZ3MpXG4gKi9cbmZ1bmN0aW9uIHJzdHJfaG1hY19tZDUoa2V5LCBkYXRhKVxue1xuICB2YXIgYmtleSA9IHJzdHIyYmlubChrZXkpO1xuICBpZihia2V5Lmxlbmd0aCA+IDE2KSBia2V5ID0gYmlubF9tZDUoYmtleSwga2V5Lmxlbmd0aCAqIDgpO1xuXG4gIHZhciBpcGFkID0gQXJyYXkoMTYpLCBvcGFkID0gQXJyYXkoMTYpO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKylcbiAge1xuICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjtcbiAgICBvcGFkW2ldID0gYmtleVtpXSBeIDB4NUM1QzVDNUM7XG4gIH1cblxuICB2YXIgaGFzaCA9IGJpbmxfbWQ1KGlwYWQuY29uY2F0KHJzdHIyYmlubChkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogOCk7XG4gIHJldHVybiBiaW5sMnJzdHIoYmlubF9tZDUob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDEyOCkpO1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIHJzdHIyaGV4KGlucHV0KVxue1xuICB0cnkgeyBoZXhjYXNlIH0gY2F0Y2goZSkgeyBoZXhjYXNlPTA7IH1cbiAgdmFyIGhleF90YWIgPSBoZXhjYXNlID8gXCIwMTIzNDU2Nzg5QUJDREVGXCIgOiBcIjAxMjM0NTY3ODlhYmNkZWZcIjtcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIHZhciB4O1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gIHtcbiAgICB4ID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICBvdXRwdXQgKz0gaGV4X3RhYi5jaGFyQXQoKHggPj4+IDQpICYgMHgwRilcbiAgICAgICAgICAgKyAgaGV4X3RhYi5jaGFyQXQoIHggICAgICAgICYgMHgwRik7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGEgYmFzZS02NCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcnN0cjJiNjQoaW5wdXQpXG57XG4gIHRyeSB7IGI2NHBhZCB9IGNhdGNoKGUpIHsgYjY0cGFkPScnOyB9XG4gIHZhciB0YWIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIjtcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIHZhciBsZW4gPSBpbnB1dC5sZW5ndGg7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMylcbiAge1xuICAgIHZhciB0cmlwbGV0ID0gKGlucHV0LmNoYXJDb2RlQXQoaSkgPDwgMTYpXG4gICAgICAgICAgICAgICAgfCAoaSArIDEgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrMSkgPDwgOCA6IDApXG4gICAgICAgICAgICAgICAgfCAoaSArIDIgPCBsZW4gPyBpbnB1dC5jaGFyQ29kZUF0KGkrMikgICAgICA6IDApO1xuICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAge1xuICAgICAgaWYoaSAqIDggKyBqICogNiA+IGlucHV0Lmxlbmd0aCAqIDgpIG91dHB1dCArPSBiNjRwYWQ7XG4gICAgICBlbHNlIG91dHB1dCArPSB0YWIuY2hhckF0KCh0cmlwbGV0ID4+PiA2KigzLWopKSAmIDB4M0YpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYW4gYXJiaXRyYXJ5IHN0cmluZyBlbmNvZGluZ1xuICovXG5mdW5jdGlvbiByc3RyMmFueShpbnB1dCwgZW5jb2RpbmcpXG57XG4gIHZhciBkaXZpc29yID0gZW5jb2RpbmcubGVuZ3RoO1xuICB2YXIgaSwgaiwgcSwgeCwgcXVvdGllbnQ7XG5cbiAgLyogQ29udmVydCB0byBhbiBhcnJheSBvZiAxNi1iaXQgYmlnLWVuZGlhbiB2YWx1ZXMsIGZvcm1pbmcgdGhlIGRpdmlkZW5kICovXG4gIHZhciBkaXZpZGVuZCA9IEFycmF5KE1hdGguY2VpbChpbnB1dC5sZW5ndGggLyAyKSk7XG4gIGZvcihpID0gMDsgaSA8IGRpdmlkZW5kLmxlbmd0aDsgaSsrKVxuICB7XG4gICAgZGl2aWRlbmRbaV0gPSAoaW5wdXQuY2hhckNvZGVBdChpICogMikgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KGkgKiAyICsgMSk7XG4gIH1cblxuICAvKlxuICAgKiBSZXBlYXRlZGx5IHBlcmZvcm0gYSBsb25nIGRpdmlzaW9uLiBUaGUgYmluYXJ5IGFycmF5IGZvcm1zIHRoZSBkaXZpZGVuZCxcbiAgICogdGhlIGxlbmd0aCBvZiB0aGUgZW5jb2RpbmcgaXMgdGhlIGRpdmlzb3IuIE9uY2UgY29tcHV0ZWQsIHRoZSBxdW90aWVudFxuICAgKiBmb3JtcyB0aGUgZGl2aWRlbmQgZm9yIHRoZSBuZXh0IHN0ZXAuIEFsbCByZW1haW5kZXJzIGFyZSBzdG9yZWQgZm9yIGxhdGVyXG4gICAqIHVzZS5cbiAgICovXG4gIHZhciBmdWxsX2xlbmd0aCA9IE1hdGguY2VpbChpbnB1dC5sZW5ndGggKiA4IC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChNYXRoLmxvZyhlbmNvZGluZy5sZW5ndGgpIC8gTWF0aC5sb2coMikpKTtcbiAgdmFyIHJlbWFpbmRlcnMgPSBBcnJheShmdWxsX2xlbmd0aCk7XG4gIGZvcihqID0gMDsgaiA8IGZ1bGxfbGVuZ3RoOyBqKyspXG4gIHtcbiAgICBxdW90aWVudCA9IEFycmF5KCk7XG4gICAgeCA9IDA7XG4gICAgZm9yKGkgPSAwOyBpIDwgZGl2aWRlbmQubGVuZ3RoOyBpKyspXG4gICAge1xuICAgICAgeCA9ICh4IDw8IDE2KSArIGRpdmlkZW5kW2ldO1xuICAgICAgcSA9IE1hdGguZmxvb3IoeCAvIGRpdmlzb3IpO1xuICAgICAgeCAtPSBxICogZGl2aXNvcjtcbiAgICAgIGlmKHF1b3RpZW50Lmxlbmd0aCA+IDAgfHwgcSA+IDApXG4gICAgICAgIHF1b3RpZW50W3F1b3RpZW50Lmxlbmd0aF0gPSBxO1xuICAgIH1cbiAgICByZW1haW5kZXJzW2pdID0geDtcbiAgICBkaXZpZGVuZCA9IHF1b3RpZW50O1xuICB9XG5cbiAgLyogQ29udmVydCB0aGUgcmVtYWluZGVycyB0byB0aGUgb3V0cHV0IHN0cmluZyAqL1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKGkgPSByZW1haW5kZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgIG91dHB1dCArPSBlbmNvZGluZy5jaGFyQXQocmVtYWluZGVyc1tpXSk7XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIEVuY29kZSBhIHN0cmluZyBhcyB1dGYtOC5cbiAqIEZvciBlZmZpY2llbmN5LCB0aGlzIGFzc3VtZXMgdGhlIGlucHV0IGlzIHZhbGlkIHV0Zi0xNi5cbiAqL1xuZnVuY3Rpb24gc3RyMnJzdHJfdXRmOChpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIHZhciBpID0gLTE7XG4gIHZhciB4LCB5O1xuXG4gIHdoaWxlKCsraSA8IGlucHV0Lmxlbmd0aClcbiAge1xuICAgIC8qIERlY29kZSB1dGYtMTYgc3Vycm9nYXRlIHBhaXJzICovXG4gICAgeCA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgeSA9IGkgKyAxIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckNvZGVBdChpICsgMSkgOiAwO1xuICAgIGlmKDB4RDgwMCA8PSB4ICYmIHggPD0gMHhEQkZGICYmIDB4REMwMCA8PSB5ICYmIHkgPD0gMHhERkZGKVxuICAgIHtcbiAgICAgIHggPSAweDEwMDAwICsgKCh4ICYgMHgwM0ZGKSA8PCAxMCkgKyAoeSAmIDB4MDNGRik7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgLyogRW5jb2RlIG91dHB1dCBhcyB1dGYtOCAqL1xuICAgIGlmKHggPD0gMHg3RilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xuICAgIGVsc2UgaWYoeCA8PSAweDdGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4QzAgfCAoKHggPj4+IDYgKSAmIDB4MUYpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICAgIGVsc2UgaWYoeCA8PSAweEZGRkYpXG4gICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEUwIHwgKCh4ID4+PiAxMikgJiAweDBGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoKHggPj4+IDYgKSAmIDB4M0YpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICggeCAgICAgICAgICYgMHgzRikpO1xuICAgIGVsc2UgaWYoeCA8PSAweDFGRkZGRilcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RjAgfCAoKHggPj4+IDE4KSAmIDB4MDcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMHg4MCB8ICgoeCA+Pj4gMTIpICYgMHgzRiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAweDgwIHwgKCh4ID4+PiA2ICkgJiAweDNGKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4ODAgfCAoIHggICAgICAgICAmIDB4M0YpKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi0xNlxuICovXG5mdW5jdGlvbiBzdHIycnN0cl91dGYxNmxlKGlucHV0KVxue1xuICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKVxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBpbnB1dC5jaGFyQ29kZUF0KGkpICAgICAgICAmIDB4RkYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlucHV0LmNoYXJDb2RlQXQoaSkgPj4+IDgpICYgMHhGRik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIHN0cjJyc3RyX3V0ZjE2YmUoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBcIlwiO1xuICBmb3IodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0LmNoYXJDb2RlQXQoaSkgPj4+IDgpICYgMHhGRixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQuY2hhckNvZGVBdChpKSAgICAgICAgJiAweEZGKTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLypcbiAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiByc3RyMmJpbmwoaW5wdXQpXG57XG4gIHZhciBvdXRwdXQgPSBBcnJheShpbnB1dC5sZW5ndGggPj4gMik7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpKyspXG4gICAgb3V0cHV0W2ldID0gMDtcbiAgZm9yKHZhciBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDg7IGkgKz0gOClcbiAgICBvdXRwdXRbaT4+NV0gfD0gKGlucHV0LmNoYXJDb2RlQXQoaSAvIDgpICYgMHhGRikgPDwgKGklMzIpO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGJpbmwycnN0cihpbnB1dClcbntcbiAgdmFyIG91dHB1dCA9IFwiXCI7XG4gIGZvcih2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGggKiAzMjsgaSArPSA4KVxuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dFtpPj41XSA+Pj4gKGkgJSAzMikpICYgMHhGRik7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBiaW5sX21kNSh4LCBsZW4pXG57XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKChsZW4pICUgMzIpO1xuICB4WygoKGxlbiArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBsZW47XG5cbiAgdmFyIGEgPSAgMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9ICAyNzE3MzM4Nzg7XG5cbiAgZm9yKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KVxuICB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuXG4gICAgYSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2krIDBdLCA3ICwgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2krIDJdLCAxNywgIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKyA0XSwgNyAsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpKyA1XSwgMTIsICAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSsgOF0sIDcgLCAgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2krIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2krMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpKzEyXSwgNyAsICAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSsxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpKzE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSsxNV0sIDIyLCAgMTIzNjUzNTMyOSk7XG5cbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgMV0sIDUgLCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgNl0sIDkgLCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2krIDVdLCA1ICwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2krMTBdLCA5ICwgIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDUgLCAgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsxNF0sIDkgLCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpKzEzXSwgNSAsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1X2dnKGQsIGEsIGIsIGMsIHhbaSsgMl0sIDkgLCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgNV0sIDQgLCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krMTFdLCAxNiwgIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpKzE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krIDFdLCA0ICwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpKyA0XSwgMTEsICAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2krMTNdLCA0ICwgIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNV9oaChkLCBhLCBiLCBjLCB4W2krIDBdLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2krIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNV9oaChiLCBjLCBkLCBhLCB4W2krIDZdLCAyMywgIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSsgOV0sIDQgLCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSsxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSsxNV0sIDE2LCAgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcblxuICAgIGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpKyAwXSwgNiAsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKyA3XSwgMTAsICAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSsxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsxMl0sIDYgLCAgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2krIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpKzEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2krIDhdLCA2ICwgIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpKzE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpKzEzXSwgMjEsICAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSsgNF0sIDYgLCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSsxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2krIDJdLCAxNSwgIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2krIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG5cbiAgICBhID0gc2FmZV9hZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlX2FkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZV9hZGQoZCwgb2xkZCk7XG4gIH1cbiAgcmV0dXJuIEFycmF5KGEsIGIsIGMsIGQpO1xufVxuXG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KVxue1xuICByZXR1cm4gc2FmZV9hZGQoYml0X3JvbChzYWZlX2FkZChzYWZlX2FkZChhLCBxKSwgc2FmZV9hZGQoeCwgdCkpLCBzKSxiKTtcbn1cbmZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KVxue1xuICByZXR1cm4gbWQ1X2NtbigoYiAmIGMpIHwgKCh+YikgJiBkKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfZ2coYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1X2hoKGEsIGIsIGMsIGQsIHgsIHMsIHQpXG57XG4gIHJldHVybiBtZDVfY21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdClcbntcbiAgcmV0dXJuIG1kNV9jbW4oYyBeIChiIHwgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuZnVuY3Rpb24gc2FmZV9hZGQoeCwgeSlcbntcbiAgdmFyIGxzdyA9ICh4ICYgMHhGRkZGKSArICh5ICYgMHhGRkZGKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gKG1zdyA8PCAxNikgfCAobHN3ICYgMHhGRkZGKTtcbn1cblxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuZnVuY3Rpb24gYml0X3JvbChudW0sIGNudClcbntcbiAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpO1xufVxuXG5cbmV4cG9ydHMuaGV4X21kNSA9IGhleF9tZDU7XG5leHBvcnRzLmI2NF9tZDUgPSBiNjRfbWQ1O1xuZXhwb3J0cy5hbnlfbWQ1ID0gYW55X21kNTtcbiIsIlxuZXhwb3J0cy5Db25uZWN0aW9uID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uJykuQ29ubmVjdGlvbjtcbmV4cG9ydHMuRG9jID0gcmVxdWlyZSgnLi9kb2MnKS5Eb2M7XG4iLCIvLyBUaGlzIGlzIGEgc2ltcGxlIHJld3JpdGUgb2YgbWljcm9ldmVudC5qcy4gSSd2ZSBjaGFuZ2VkIHRoZVxuLy8gZnVuY3Rpb24gbmFtZXMgdG8gYmUgY29uc2lzdGVudCB3aXRoIG5vZGUuanMgRXZlbnRFbWl0dGVyLlxuLy9cbi8vIG1pY3JvZXZlbnQuanMgaXMgY29weXJpZ2h0IEplcm9tZSBFdGllbm5lLCBhbmQgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2plcm9tZWV0aWVubmUvbWljcm9ldmVudC5qc1xuXG52YXIgTWljcm9FdmVudCA9IGZ1bmN0aW9uKCkge307XG5cbk1pY3JvRXZlbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIChldmVudHNbZXZlbnRdID0gZXZlbnRzW2V2ZW50XSB8fCBbXSkucHVzaChmbik7XG59O1xuXG5NaWNyb0V2ZW50LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbikge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzW2V2ZW50XSA9IGV2ZW50c1tldmVudF0gfHwgW107XG5cbiAgLy8gU2FkbHksIG5vIElFOCBzdXBwb3J0IGZvciBpbmRleE9mLlxuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgIGlmIChsaXN0ZW5lcnNbaV0gPT09IGZuKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGkrKztcbiAgfVxuXG4gIC8vIENvbXBhY3QgdGhlIGxpc3Qgd2hlbiBubyBldmVudCBoYW5kbGVyIGlzIGFjdHVhbGx5IHJ1bm5pbmcuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZXZlbnRzW2V2ZW50XSA9IFtdO1xuICAgIHZhciBmbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gT25seSBhZGQgYmFjayBldmVudCBoYW5kbGVycyB3aGljaCBleGlzdC5cbiAgICAgIGlmICgoZm4gPSBsaXN0ZW5lcnNbaV0pKSBldmVudHNbZXZlbnRdLnB1c2goZm4pO1xuICAgIH1cbiAgfSwgMCk7XG59O1xuXG5NaWNyb0V2ZW50LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpZiAoIWV2ZW50cyB8fCAhZXZlbnRzW2V2ZW50XSkge1xuICAgIGlmIChldmVudCA9PSAnZXJyb3InKSB7XG4gICAgICBpZiAoY29uc29sZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzW2V2ZW50XTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobGlzdGVuZXJzW2ldKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG59O1xuXG5NaWNyb0V2ZW50LnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKSB7XG4gIHZhciBsaXN0ZW5lciwgX3RoaXMgPSB0aGlzO1xuICB0aGlzLm9uKGV2ZW50LCBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgIF90aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgZm4uYXBwbHkoX3RoaXMsIGFyZ3VtZW50cyk7XG4gIH0pO1xufTtcblxuTWljcm9FdmVudC5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcHJvdG8gPSBvYmoucHJvdG90eXBlIHx8IG9iajtcbiAgcHJvdG8ub24gPSBNaWNyb0V2ZW50LnByb3RvdHlwZS5vbjtcbiAgcHJvdG8ucmVtb3ZlTGlzdGVuZXIgPSBNaWNyb0V2ZW50LnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbiAgcHJvdG8uZW1pdCA9IE1pY3JvRXZlbnQucHJvdG90eXBlLmVtaXQ7XG4gIHByb3RvLm9uY2UgPSBNaWNyb0V2ZW50LnByb3RvdHlwZS5vbmNlO1xuICByZXR1cm4gb2JqO1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIpIG1vZHVsZS5leHBvcnRzID0gTWljcm9FdmVudDtcblxuIiwidmFyIERvYztcbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgRG9jID0gcmVxdWlyZSgnLi9kb2MnKS5Eb2M7XG59XG5cbi8vIFF1ZXJpZXMgYXJlIGxpdmUgcmVxdWVzdHMgdG8gdGhlIGRhdGFiYXNlIGZvciBwYXJ0aWN1bGFyIHNldHMgb2YgZmllbGRzLlxuLy9cbi8vIFRoZSBzZXJ2ZXIgYWN0aXZlbHkgdGVsbHMgdGhlIGNsaWVudCB3aGVuIHRoZXJlJ3MgbmV3IGRhdGEgdGhhdCBtYXRjaGVzXG4vLyBhIHNldCBvZiBjb25kaXRpb25zLlxudmFyIFF1ZXJ5ID0gZXhwb3J0cy5RdWVyeSA9IGZ1bmN0aW9uKHR5cGUsIGNvbm5lY3Rpb24sIGlkLCBjb2xsZWN0aW9uLCBxdWVyeSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLy8gJ2ZldGNoJyBvciAnc3ViJ1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuXG4gIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gIHRoaXMuaWQgPSBpZDtcbiAgdGhpcy5jb2xsZWN0aW9uID0gY29sbGVjdGlvbjtcblxuICAvLyBUaGUgcXVlcnkgaXRzZWxmLiBGb3IgbW9uZ28sIHRoaXMgc2hvdWxkIGxvb2sgc29tZXRoaW5nIGxpa2Uge1wiZGF0YS54XCI6NX1cbiAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuXG4gIC8vIFJlc3VsdGFudCBkb2N1bWVudCBhY3Rpb24gZm9yIHRoZSBzZXJ2ZXIuIEZldGNoIG1vZGUgd2lsbCBhdXRvbWF0aWNhbGx5XG4gIC8vIGZldGNoIGFsbCByZXN1bHRzLiBTdWJzY3JpYmUgbW9kZSB3aWxsIGF1dG9tYXRpY2FsbHkgc3Vic2NyaWJlIGFsbFxuICAvLyByZXN1bHRzLiBSZXN1bHRzIGFyZSBuZXZlciB1bnN1YnNjcmliZWQuXG4gIHRoaXMuZG9jTW9kZSA9IG9wdGlvbnMuZG9jTW9kZTsgLy8gdW5kZWZpbmVkLCAnZmV0Y2gnIG9yICdzdWInLlxuICBpZiAodGhpcy5kb2NNb2RlID09PSAnc3Vic2NyaWJlJykgdGhpcy5kb2NNb2RlID0gJ3N1Yic7XG5cbiAgLy8gRG8gd2UgcmVwb2xsIHRoZSBlbnRpcmUgcXVlcnkgd2hlbmV2ZXIgYW55dGhpbmcgY2hhbmdlcz8gKEFzIG9wcG9zZWQgdG9cbiAgLy8ganVzdCBwb2xsaW5nIHRoZSBjaGFuZ2VkIGl0ZW0pLiBUaGlzIG5lZWRzIHRvIGJlIGVuYWJsZWQgdG8gYmUgYWJsZSB0byB1c2VcbiAgLy8gb3JkZXJlZCBxdWVyaWVzIChzb3J0Ynk6KSBhbmQgcGFnaW5hdGVkIHF1ZXJpZXMuIFNldCB0byB1bmRlZmluZWQsIGl0IHdpbGxcbiAgLy8gYmUgZW5hYmxlZCAvIGRpc2FibGVkIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdGhlIHF1ZXJ5J3MgcHJvcGVydGllcy5cbiAgdGhpcy5wb2xsID0gb3B0aW9ucy5wb2xsO1xuXG4gIC8vIFRoZSBiYWNrZW5kIHdlIGFjdHVhbGx5IGhpdC4gSWYgdGhpcyBpc24ndCBkZWZpbmVkLCBpdCBoaXRzIHRoZSBzbmFwc2hvdFxuICAvLyBkYXRhYmFzZS4gT3RoZXJ3aXNlIHRoaXMgY2FuIGJlIHVzZWQgdG8gaGl0IGFub3RoZXIgY29uZmlndXJlZCBxdWVyeVxuICAvLyBpbmRleC5cbiAgdGhpcy5iYWNrZW5kID0gb3B0aW9ucy5iYWNrZW5kIHx8IG9wdGlvbnMuc291cmNlO1xuXG4gIC8vIEEgbGlzdCBvZiByZXN1bHRpbmcgZG9jdW1lbnRzLiBUaGVzZSBhcmUgYWN0dWFsIGRvY3VtZW50cywgY29tcGxldGUgd2l0aFxuICAvLyBkYXRhIGFuZCBhbGwgdGhlIHJlc3QuIElmIGZldGNoIGlzIGZhbHNlLCB0aGVzZSBkb2N1bWVudHMgd2lsbCBub3RcbiAgLy8gaGF2ZSBhbnkgZGF0YS4gWW91IHNob3VsZCBtYW51YWxseSBjYWxsIGZldGNoKCkgb3Igc3Vic2NyaWJlKCkgb24gdGhlbS5cbiAgLy9cbiAgLy8gQ2FsbGluZyBzdWJzY3JpYmUoKSBtaWdodCBiZSBhIGdvb2QgaWRlYSBhbnl3YXksIGFzIHlvdSB3b24ndCBiZVxuICAvLyBzdWJzY3JpYmVkIHRvIHRoZSBkb2N1bWVudHMgYnkgZGVmYXVsdC5cbiAgdGhpcy5rbm93bkRvY3MgPSBvcHRpb25zLmtub3duRG9jcyB8fCBbXTtcbiAgdGhpcy5yZXN1bHRzID0gW107XG5cbiAgLy8gRG8gd2UgaGF2ZSBzb21lIGluaXRpYWwgZGF0YT9cbiAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuXG4gIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbn07XG5RdWVyeS5wcm90b3R5cGUuYWN0aW9uID0gJ3FzdWInO1xuXG4vLyBIZWxwZXIgZm9yIHN1YnNjcmliZSAmIGZldGNoLCBzaW5jZSB0aGV5IHNoYXJlIHRoZSBzYW1lIG1lc3NhZ2UgZm9ybWF0LlxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gYWN0dWFsbHkgaXNzdWVzIHRoZSBxdWVyeS5cblF1ZXJ5LnByb3RvdHlwZS5fZXhlY3V0ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY29ubmVjdGlvbi5jYW5TZW5kKSByZXR1cm47XG5cbiAgaWYgKHRoaXMuZG9jTW9kZSkge1xuICAgIHZhciBjb2xsZWN0aW9uVmVyc2lvbnMgPSB7fTtcbiAgICAvLyBDb2xsZWN0IHRoZSB2ZXJzaW9uIG9mIGFsbCB0aGUgZG9jdW1lbnRzIGluIHRoZSBjdXJyZW50IHJlc3VsdCBzZXQgc28gd2VcbiAgICAvLyBkb24ndCBuZWVkIHRvIGJlIHNlbnQgdGhlaXIgc25hcHNob3RzIGFnYWluLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rbm93bkRvY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkb2MgPSB0aGlzLmtub3duRG9jc1tpXTtcbiAgICAgIHZhciBjID0gY29sbGVjdGlvblZlcnNpb25zW2RvYy5jb2xsZWN0aW9uXSA9IGNvbGxlY3Rpb25WZXJzaW9uc1tkb2MuY29sbGVjdGlvbl0gfHwge307XG4gICAgICBjW2RvYy5uYW1lXSA9IGRvYy52ZXJzaW9uO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtc2cgPSB7XG4gICAgYTogJ3EnICsgdGhpcy50eXBlLFxuICAgIGlkOiB0aGlzLmlkLFxuICAgIGM6IHRoaXMuY29sbGVjdGlvbixcbiAgICBvOiB7fSxcbiAgICBxOiB0aGlzLnF1ZXJ5LFxuICB9O1xuXG4gIGlmICh0aGlzLmRvY01vZGUpIHtcbiAgICBtc2cuby5tID0gdGhpcy5kb2NNb2RlO1xuICAgIC8vIFRoaXMgc2hvdWxkIGJlIG9taXR0ZWQgaWYgZW1wdHksIGJ1dCB3aGF0ZXZlci5cbiAgICBtc2cuby52cyA9IGNvbGxlY3Rpb25WZXJzaW9ucztcbiAgfVxuICBpZiAodGhpcy5iYWNrZW5kICE9IG51bGwpIG1zZy5vLmIgPSB0aGlzLmJhY2tlbmQ7XG4gIGlmICh0aGlzLnBvbGwgIT09IHVuZGVmaW5lZCkgbXNnLm8ucCA9IHRoaXMucG9sbDtcblxuICB0aGlzLmNvbm5lY3Rpb24uc2VuZChtc2cpO1xufTtcblxuLy8gTWFrZSBhIGxpc3Qgb2YgZG9jdW1lbnRzIGZyb20gdGhlIGxpc3Qgb2Ygc2VydmVyLXJldHVybmVkIGRhdGEgb2JqZWN0c1xuUXVlcnkucHJvdG90eXBlLl9kYXRhVG9Eb2NzID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuICB2YXIgbGFzdFR5cGU7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkb2NEYXRhID0gZGF0YVtpXTtcblxuICAgIC8vIFR5cGVzIGFyZSBvbmx5IHB1dCBpbiBmb3IgdGhlIGZpcnN0IHJlc3VsdCBpbiB0aGUgc2V0IGFuZCBldmVyeSB0aW1lIHRoZSB0eXBlIGNoYW5nZXMgaW4gdGhlIGxpc3QuXG4gICAgaWYgKGRvY0RhdGEudHlwZSkge1xuICAgICAgbGFzdFR5cGUgPSBkb2NEYXRhLnR5cGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY0RhdGEudHlwZSA9IGxhc3RUeXBlO1xuICAgIH1cblxuICAgIHZhciBkb2MgPSB0aGlzLmNvbm5lY3Rpb24uZ2V0T3JDcmVhdGUoZG9jRGF0YS5jIHx8IHRoaXMuY29sbGVjdGlvbiwgZG9jRGF0YS5kLCBkb2NEYXRhKTtcbiAgICAvLyBGb3JjZSB0aGUgZG9jdW1lbnQgdG8ga25vdyBpdHMgc3Vic2NyaWJlZCBpZiB3ZSdyZSBpbiBkb2Ntb2RlOnN1YnNjcmliZS5cbiAgICBpZiAodGhpcy5kb2NNb2RlID09PSAnc3ViJykge1xuICAgICAgZG9jLnN1YnNjcmliZWQgPSB0cnVlOyAvLyBTZXQgYmVmb3JlIHNldFdhbnRTdWJzY3JpYmUoKSBzbyBmbHVzaCBkb2Vzbid0IHNlbmQgYSBzdWJzY3JpYmUgcmVxdWVzdC5cbiAgICAgIGRvYy5fc2V0V2FudFN1YnNjcmliZSh0cnVlKTsgLy8gdGhpcyB3aWxsIGNhbGwgYW55IHN1YnNjcmliZSBjYWxsYmFja3Mgb3Igd2hhdGV2ZXIuXG4gICAgICBkb2MuZW1pdCgnc3Vic2NyaWJlJyk7XG4gICAgICBkb2MuX2ZpbmlzaFN1Yih0cnVlKTsgLy8gdGhpcyBkb2Vzbid0IGFjdHVhbGx5IGRvIGFueXRoaW5nIGhlcmUsIGJ1dCBpdHMgbW9yZSBjb3JyZWN0IHRvIGhhdmUgaXQuXG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChkb2MpO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gRGVzdHJveSB0aGUgcXVlcnkgb2JqZWN0LiBBbnkgc3Vic2VxdWVudCBtZXNzYWdlcyBmb3IgdGhlIHF1ZXJ5IHdpbGwgYmVcbi8vIGlnbm9yZWQgYnkgdGhlIGNvbm5lY3Rpb24uIFlvdSBzaG91bGQgdW5zdWJzY3JpYmUgZnJvbSB0aGUgcXVlcnkgYmVmb3JlXG4vLyBkZXN0cm95aW5nIGl0LlxuUXVlcnkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY29ubmVjdGlvbi5jYW5TZW5kICYmIHRoaXMudHlwZSA9PT0gJ3N1YicpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24uc2VuZCh7YToncXVuc3ViJywgaWQ6dGhpcy5pZH0pO1xuICB9XG5cbiAgdGhpcy5jb25uZWN0aW9uLl9kZXN0cm95UXVlcnkodGhpcyk7XG59O1xuXG5RdWVyeS5wcm90b3R5cGUuX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlLCByZWFzb24pIHtcbiAgaWYgKHRoaXMuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgdGhpcy5fZXhlY3V0ZSgpO1xuICB9XG59O1xuXG4vLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIGZyb20gY29ubmVjdGlvbiB0byBwYXNzIHNlcnZlciBtZXNzYWdlcyB0byB0aGUgcXVlcnkuXG5RdWVyeS5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZykge1xuICBpZiAoKG1zZy5hID09PSAncWZldGNoJykgIT09ICh0aGlzLnR5cGUgPT09ICdmZXRjaCcpKSB7XG4gICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignSW52YWxpZCBtZXNzYWdlIHNlbnQgdG8gcXVlcnknLCBtc2csIHRoaXMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChtc2cuZXJyb3IpIHRoaXMuZW1pdCgnZXJyb3InLCBtc2cuZXJyb3IpO1xuXG4gIHN3aXRjaCAobXNnLmEpIHtcbiAgICBjYXNlICdxZmV0Y2gnOlxuICAgICAgdmFyIHJlc3VsdHMgPSBtc2cuZGF0YSA/IHRoaXMuX2RhdGFUb0RvY3MobXNnLmRhdGEpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHRoaXMuY2FsbGJhY2spIHRoaXMuY2FsbGJhY2sobXNnLmVycm9yLCByZXN1bHRzLCBtc2cuZXh0cmEpO1xuICAgICAgLy8gT25jZSBhIGZldGNoIHF1ZXJ5IGdldHMgaXRzIGRhdGEsIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgIHRoaXMuY29ubmVjdGlvbi5fZGVzdHJveVF1ZXJ5KHRoaXMpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdxJzpcbiAgICAgIC8vIFF1ZXJ5IGRpZmYgZGF0YSAoaW5zZXJ0cyBhbmQgcmVtb3ZlcylcbiAgICAgIGlmIChtc2cuZGlmZikge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIGxpc3QgdHdpY2UuIEZpcnN0LCB3ZSdsbCBpbmplc3QgYWxsIHRoZVxuICAgICAgICAvLyBuZXcgZG9jdW1lbnRzIGFuZCBzZXQgdGhlbSBhcyBzdWJzY3JpYmVkLiAgQWZ0ZXIgdGhhdCB3ZSdsbCBlbWl0XG4gICAgICAgIC8vIGV2ZW50cyBhbmQgYWN0dWFsbHkgdXBkYXRlIG91ciBsaXN0LiBUaGlzIGF2b2lkcyByYWNlIGNvbmRpdGlvbnNcbiAgICAgICAgLy8gYXJvdW5kIHNldHRpbmcgZG9jdW1lbnRzIHRvIGJlIHN1YnNjcmliZWQgJiB1bnN1YnNjcmliaW5nIGRvY3VtZW50c1xuICAgICAgICAvLyBpbiBldmVudCBjYWxsYmFja3MuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZCA9IG1zZy5kaWZmW2ldO1xuICAgICAgICAgIGlmIChkLnR5cGUgPT09ICdpbnNlcnQnKSBkLnZhbHVlcyA9IHRoaXMuX2RhdGFUb0RvY3MoZC52YWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cuZGlmZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBkID0gbXNnLmRpZmZbaV07XG4gICAgICAgICAgc3dpdGNoIChkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgIHZhciBuZXdEb2NzID0gZC52YWx1ZXM7XG4gICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkodGhpcy5yZXN1bHRzLCBbZC5pbmRleCwgMF0uY29uY2F0KG5ld0RvY3MpKTtcbiAgICAgICAgICAgICAgdGhpcy5lbWl0KCdpbnNlcnQnLCBuZXdEb2NzLCBkLmluZGV4KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZW1vdmUnOlxuICAgICAgICAgICAgICB2YXIgaG93TWFueSA9IGQuaG93TWFueSB8fCAxO1xuICAgICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IHRoaXMucmVzdWx0cy5zcGxpY2UoZC5pbmRleCwgaG93TWFueSk7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlJywgcmVtb3ZlZCwgZC5pbmRleCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW92ZSc6XG4gICAgICAgICAgICAgIHZhciBob3dNYW55ID0gZC5ob3dNYW55IHx8IDE7XG4gICAgICAgICAgICAgIHZhciBkb2NzID0gdGhpcy5yZXN1bHRzLnNwbGljZShkLmZyb20sIGhvd01hbnkpO1xuICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KHRoaXMucmVzdWx0cywgW2QudG8sIDBdLmNvbmNhdChkb2NzKSk7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdCgnbW92ZScsIGRvY3MsIGQuZnJvbSwgZC50byk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobXNnLmV4dHJhKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXh0cmEnLCBtc2cuZXh0cmEpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncXN1Yic6XG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgcmVwbGFjZXMgdGhlIGVudGlyZSByZXN1bHQgc2V0IHdpdGggdGhlIHNldCBwYXNzZWQuXG4gICAgICBpZiAoIW1zZy5lcnJvcikge1xuICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLnJlc3VsdHM7XG5cbiAgICAgICAgLy8gVGhlbiBhZGQgZXZlcnl0aGluZyBpbiB0aGUgbmV3IHJlc3VsdCBzZXQuXG4gICAgICAgIHRoaXMucmVzdWx0cyA9IHRoaXMua25vd25Eb2NzID0gdGhpcy5fZGF0YVRvRG9jcyhtc2cuZGF0YSk7XG4gICAgICAgIHRoaXMuZXh0cmEgPSBtc2cuZXh0cmE7XG5cbiAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnY2hhbmdlJywgdGhpcy5yZXN1bHRzLCBwcmV2aW91cyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbGxiYWNrKG1zZy5lcnJvciwgdGhpcy5yZXN1bHRzLCB0aGlzLmV4dHJhKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2s7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLy8gQ2hhbmdlIHRoZSB0aGluZyB3ZSdyZSBzZWFyY2hpbmcgZm9yLiBUaGlzIGlzbid0IGZ1bGx5IHN1cHBvcnRlZCBvbiB0aGVcbi8vIGJhY2tlbmQgKGl0IGRlc3Ryb3lzIHRoZSBvbGQgcXVlcnkgYW5kIG1ha2VzIGEgbmV3IG9uZSkgLSBidXQgaXRzXG4vLyBwcm9ncmFtYXRpY2FsbHkgdXNlZnVsIGFuZCBJIG1pZ2h0IGFkZCBiYWNrZW5kIHN1cHBvcnQgYXQgc29tZSBwb2ludC5cblF1ZXJ5LnByb3RvdHlwZS5zZXRRdWVyeSA9IGZ1bmN0aW9uKHEpIHtcbiAgaWYgKHRoaXMudHlwZSAhPT0gJ3N1YicpIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNoYW5nZSBhIGZldGNoIHF1ZXJ5Jyk7XG5cbiAgdGhpcy5xdWVyeSA9IHE7XG4gIGlmICh0aGlzLmNvbm5lY3Rpb24uY2FuU2VuZCkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gJ2NoYW5nZScgbWVzc2FnZSB0byBzZW5kIHRvIHRoZSBzZXJ2ZXIuIEp1c3QgcmVzdWJzY3JpYmUuXG4gICAgdGhpcy5jb25uZWN0aW9uLnNlbmQoe2E6J3F1bnN1YicsIGlkOnRoaXMuaWR9KTtcbiAgICB0aGlzLl9leGVjdXRlKCk7XG4gIH1cbn07XG5cbnZhciBNaWNyb0V2ZW50O1xuaWYgKHR5cGVvZiByZXF1aXJlICE9PSAndW5kZWZpbmVkJykge1xuICBNaWNyb0V2ZW50ID0gcmVxdWlyZSgnLi9taWNyb2V2ZW50Jyk7XG59XG5cbk1pY3JvRXZlbnQubWl4aW4oUXVlcnkpO1xuXG4iLCIvLyBBIENvbm5lY3Rpb24gd3JhcHMgYSBwZXJzaXN0YW50IEJDIGNvbm5lY3Rpb24gdG8gYSBzaGFyZWpzIHNlcnZlci5cbi8vXG4vLyBUaGlzIGNsYXNzIGltcGxlbWVudHMgdGhlIGNsaWVudCBzaWRlIG9mIHRoZSBwcm90b2NvbCBkZWZpbmVkIGhlcmU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vam9zZXBoZy9TaGFyZUpTL3dpa2kvV2lyZS1Qcm90b2NvbFxuLy9cbi8vIFRoZSBlcXVpdmFsZW50IHNlcnZlciBjb2RlIGlzIGluIHNyYy9zZXJ2ZXIvc2Vzc2lvbi5cbi8vXG4vLyBUaGlzIGZpbGUgaXMgYSBiaXQgb2YgYSBtZXNzLiBJJ20gZHJlYWRmdWxseSBzb3JyeSBhYm91dCB0aGF0LiBJdCBwYXNzZXMgYWxsIHRoZSB0ZXN0cyxcbi8vIHNvIEkgaGF2ZSBob3BlIHRoYXQgaXRzICpjb3JyZWN0KiBldmVuIGlmIGl0cyBub3QgY2xlYW4uXG4vL1xuLy8gVG8gbWFrZSBhIGNvbm5lY3Rpb24sIHVzZTpcbi8vICBuZXcgc2hhcmVqcy5Db25uZWN0aW9uKHNvY2tldClcbi8vXG4vLyBUaGUgc29ja2V0IHNob3VsZCBsb29rIGxpa2UgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbi4gSXQgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy8gIHNlbmQobXNnKTogU2VuZCB0aGUgZ2l2ZW4gbWVzc2FnZS4gbXNnIG1heSBiZSBhbiBvYmplY3QgLSBpZiBzbywgeW91IG1pZ2h0IG5lZWQgdG8gSlNPTi5zdHJpbmdpZnkgaXQuXG4vLyAgY2xvc2UoKTogRGlzY29ubmVjdCB0aGUgc2Vzc2lvblxuLy9cbi8vICBvbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpe306IEV2ZW50IGhhbmRsZXIgd2hpY2ggaXMgY2FsbGVkIHdoZW5ldmVyIGEgbWVzc2FnZSBpcyByZWNlaXZlZC4gVGhlIG1lc3NhZ2Vcbi8vICAgICBwYXNzZWQgaW4gc2hvdWxkIGFscmVhZHkgYmUgYW4gb2JqZWN0LiAoSXQgbWF5IG5lZWQgdG8gYmUgSlNPTi5wYXJzZWQpXG4vLyAgb25jbG9zZVxuLy8gIG9uZXJyb3Jcbi8vICBvbm9wZW5cbi8vICBvbmNvbm5lY3Rpbmdcbi8vXG4vLyBUaGUgc29ja2V0IHNob3VsZCBwcm9iYWJseSBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdC4gSWYgc28sIGl0IHNob3VsZCBlbWl0IHRoZSBhcHByb3ByaWF0ZSBldmVudHMgYXMgaXRcbi8vIGRpc2Nvbm5lY3RzICYgcmVjb25uZWN0cy4gKG9uY2xvc2UoKSwgb25jb25uZWN0aW5nKCksIG9ub3BlbigpKS5cblxudmFyIHR5cGVzLCBEb2M7XG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XG4gIHR5cGVzID0gcmVxdWlyZSgnb3R0eXBlcycpO1xuICBEb2MgPSByZXF1aXJlKCcuL2RvYycpLkRvYztcbiAgUXVlcnkgPSByZXF1aXJlKCcuL3F1ZXJ5JykuUXVlcnk7XG59IGVsc2Uge1xuICB0eXBlcyA9IHdpbmRvdy5vdHR5cGVzO1xuICBEb2MgPSBleHBvcnRzLkRvYztcbn1cblxudmFyIENvbm5lY3Rpb24gPSBleHBvcnRzLkNvbm5lY3Rpb24gPSBmdW5jdGlvbiAoc29ja2V0KSB7XG4gIHRoaXMuc29ja2V0ID0gc29ja2V0O1xuXG4gIC8vIE1hcCBvZiBjb2xsZWN0aW9uIC0+IGRvY05hbWUgLT4gZG9jIG9iamVjdCBmb3IgY3JlYXRlZCBkb2N1bWVudHMuXG4gIC8vIChjcmVhdGVkIGRvY3VtZW50cyBNVVNUIEJFIFVOSVFVRSlcbiAgdGhpcy5jb2xsZWN0aW9ucyA9IHt9O1xuXG4gIC8vIEVhY2ggcXVlcnkgaXMgY3JlYXRlZCB3aXRoIGFuIGlkIHRoYXQgdGhlIHNlcnZlciB1c2VzIHdoZW4gaXQgc2VuZHMgdXNcbiAgLy8gaW5mbyBhYm91dCB0aGUgcXVlcnkgKHVwZGF0ZXMsIGV0YykuXG4gIC8vdGhpcy5uZXh0UXVlcnlJZCA9IChNYXRoLnJhbmRvbSgpICogMTAwMCkgfDA7XG4gIHRoaXMubmV4dFF1ZXJ5SWQgPSAxO1xuXG4gIC8vIE1hcCBmcm9tIHF1ZXJ5IElEIC0+IHF1ZXJ5IG9iamVjdC5cbiAgdGhpcy5xdWVyaWVzID0ge307XG5cbiAgLy8gQ29ubmVjdGlvbiBzdGF0ZS5cbiAgLy8gXG4gIC8vIFN0YXRlczpcbiAgLy8gLSAnY29ubmVjdGluZyc6IFRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLCBidXQgd2UgZG9uJ3QgaGF2ZSBvdXIgY2xpZW50IElEIHlldFxuICAvLyAtICdjb25uZWN0ZWQnOiBXZSBoYXZlIGNvbm5lY3RlZCBhbmQgcmVjaWV2ZWQgb3VyIGNsaWVudCBJRC4gUmVhZHkgZm9yIGRhdGEuXG4gIC8vIC0gJ2Rpc2Nvbm5lY3RlZCc6IFRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCwgYnV0IGl0IHdpbGwgcmVjb25uZWN0IGF1dG9tYXRpY2FsbHkuXG4gIC8vIC0gJ3N0b3BwZWQnOiBUaGUgY29ubmVjdGlvbiBpcyBjbG9zZWQsIGFuZCBzaG91bGQgbm90IHJlY29ubmVjdC5cbiAgdGhpcy5zdGF0ZSA9IChzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMCB8fCBzb2NrZXQucmVhZHlTdGF0ZSA9PT0gMSkgPyAnY29ubmVjdGluZycgOiAnZGlzY29ubmVjdGVkJztcblxuICAvLyBUaGlzIGlzIGEgaGVscGVyIHZhcmlhYmxlIHRoZSBkb2N1bWVudCB1c2VzIHRvIHNlZSB3aGV0aGVyIHdlJ3JlIGN1cnJlbnRseVxuICAvLyBpbiBhICdsaXZlJyBzdGF0ZS4gSXQgaXMgdHJ1ZSBpZiB0aGUgc3RhdGUgaXMgJ2Nvbm5lY3RpbmcnIG9yICdjb25uZWN0ZWQnLlxuICB0aGlzLmNhblNlbmQgPSB0aGlzLnN0YXRlID09PSAnY29ubmVjdGluZyc7XG5cbiAgLy8gUmVzZXQgc29tZSBtb3JlIHN0YXRlIHZhcmlhYmxlcy5cbiAgdGhpcy5yZXNldCgpO1xuXG4gIHRoaXMuZGVidWcgPSBmYWxzZTtcblxuICB2YXIgY29ubmVjdGlvbiA9IHRoaXM7XG5cbiAgLy8gQXR0YWNoIGV2ZW50IGhhbmRsZXJzIHRvIHRoZSBzb2NrZXQuXG4gIHNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgICBpZiAoY29ubmVjdGlvbi5kZWJ1ZykgY29uc29sZS5sb2coJ1JFQ1YnLCBKU09OLnN0cmluZ2lmeShtc2cpKTtcblxuICAgIC8vIFN3aXRjaCBvbiB0aGUgbWVzc2FnZSBhY3Rpb24uIE1vc3QgbWVzc2FnZXMgYXJlIGZvciBkb2N1bWVudHMgYW5kIGFyZVxuICAgIC8vIGhhbmRsZWQgaW4gdGhlIGRvYyBjbGFzcy5cbiAgICBzd2l0Y2ggKG1zZy5hKSB7XG4gICAgICBjYXNlICdpbml0JzpcbiAgICAgICAgLy8gQ2xpZW50IGluaXRpYWxpemF0aW9uIHBhY2tldC4gVGhpcyBidW5kbGUgb2Ygam95IGNvbnRhaW5zIG91ciBjbGllbnRcbiAgICAgICAgLy8gSUQuXG4gICAgICAgIGlmIChtc2cucHJvdG9jb2wgIT09IDApIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcm90b2NvbCB2ZXJzaW9uJyk7XG4gICAgICAgIGlmICh0eXBlb2YgbXNnLmlkICE9ICdzdHJpbmcnKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2xpZW50IGlkJyk7XG5cbiAgICAgICAgY29ubmVjdGlvbi5pZCA9IG1zZy5pZDtcbiAgICAgICAgY29ubmVjdGlvbi5fc2V0U3RhdGUoJ2Nvbm5lY3RlZCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncWZldGNoJzpcbiAgICAgIGNhc2UgJ3FzdWInOlxuICAgICAgY2FzZSAncSc6XG4gICAgICBjYXNlICdxdW5zdWInOlxuICAgICAgICAvLyBRdWVyeSBtZXNzYWdlLiBQYXNzIHRoaXMgdG8gdGhlIGFwcHJvcHJpYXRlIHF1ZXJ5IG9iamVjdC5cbiAgICAgICAgdmFyIHF1ZXJ5ID0gY29ubmVjdGlvbi5xdWVyaWVzW21zZy5pZF07XG4gICAgICAgIGlmIChxdWVyeSkgcXVlcnkuX29uTWVzc2FnZShtc2cpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRG9jdW1lbnQgbWVzc2FnZS4gUHVsbCBvdXQgdGhlIHJlZmVyZW5jZWQgZG9jdW1lbnQgYW5kIGZvcndhcmQgdGhlXG4gICAgICAgIC8vIG1lc3NhZ2UuXG4gICAgICAgIHZhciBjb2xsZWN0aW9uLCBkb2NOYW1lLCBkb2M7XG4gICAgICAgIGlmIChtc2cuZCkge1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLl9sYXN0UmVjZWl2ZWRDb2xsZWN0aW9uID0gbXNnLmM7XG4gICAgICAgICAgZG9jTmFtZSA9IHRoaXMuX2xhc3RSZWNlaXZlZERvYyA9IG1zZy5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBtc2cuYyA9IHRoaXMuX2xhc3RSZWNlaXZlZENvbGxlY3Rpb247XG4gICAgICAgICAgZG9jTmFtZSA9IG1zZy5kID0gdGhpcy5fbGFzdFJlY2VpdmVkRG9jO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jID0gY29ubmVjdGlvbi5nZXQoY29sbGVjdGlvbiwgZG9jTmFtZSk7XG4gICAgICAgIGlmICghZG9jKSB7XG4gICAgICAgICAgaWYgKGNvbnNvbGUpIGNvbnNvbGUuZXJyb3IoJ01lc3NhZ2UgZm9yIHVua25vd24gZG9jLiBJZ25vcmluZy4nLCBtc2cpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRvYy5fb25NZXNzYWdlKG1zZyk7XG4gICAgfVxuICB9O1xuXG4gIHNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICBjb25uZWN0aW9uLl9zZXRTdGF0ZSgnY29ubmVjdGluZycpO1xuICB9O1xuXG4gIHNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIC8vIFRoaXMgaXNuJ3QgdGhlIHNhbWUgYXMgYSByZWd1bGFyIGVycm9yLCBiZWNhdXNlIGl0IHdpbGwgaGFwcGVuIG5vcm1hbGx5XG4gICAgLy8gZnJvbSB0aW1lIHRvIHRpbWUuIFlvdXIgY29ubmVjdGlvbiBzaG91bGQgcHJvYmFibHkgYXV0b21hdGljYWxseVxuICAgIC8vIHJlY29ubmVjdCBhbnl3YXksIGJ1dCB0aGF0IHNob3VsZCBiZSB0cmlnZ2VyZWQgb2ZmIG9uY2xvc2Ugbm90IG9uZXJyb3IuXG4gICAgLy8gKG9uY2xvc2UgaGFwcGVucyB3aGVuIG9uZXJyb3IgZ2V0cyBjYWxsZWQgYW55d2F5KS5cbiAgICBjb25uZWN0aW9uLmVtaXQoJ2Nvbm5lY3Rpb24gZXJyb3InLCBlKTtcbiAgfTtcblxuICBzb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgIGNvbm5lY3Rpb24uX3NldFN0YXRlKCdkaXNjb25uZWN0ZWQnLCByZWFzb24pO1xuICAgIGlmIChyZWFzb24gPT09ICdDbG9zZWQnIHx8IHJlYXNvbiA9PT0gJ1N0b3BwZWQgYnkgc2VydmVyJykge1xuICAgICAgY29ubmVjdGlvbi5fc2V0U3RhdGUoJ3N0b3BwZWQnLCByZWFzb24pO1xuICAgIH1cbiAgfTtcbn1cblxuLyogV2h5IGRvZXMgdGhpcyBmdW5jdGlvbiBleGlzdD8gSXMgaXQgaW1wb3J0YW50P1xuQ29ubmVjdGlvbi5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oZSkge1xuICB0aGlzLl9zZXRTdGF0ZSgnc3RvcHBlZCcsIGUpO1xuICByZXR1cm4gdGhpcy5kaXNjb25uZWN0KGUpO1xufTtcbiovXG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaWQgPSB0aGlzLmxhc3RFcnJvciA9XG4gICAgdGhpcy5fbGFzdFJlY2VpdmVkQ29sbGVjdGlvbiA9IHRoaXMuX2xhc3RSZWNlaXZlZERvYyA9XG4gICAgdGhpcy5fbGFzdFNlbnRDb2xsZWN0aW9uID0gdGhpcy5fbGFzdFNlbnREb2MgPSBudWxsO1xuXG4gIHRoaXMuc2VxID0gMTtcbn07XG5cbi8vIFNldCB0aGUgY29ubmVjdGlvbidzIHN0YXRlLiBUaGUgY29ubmVjdGlvbiBpcyBiYXNpY2FsbHkgYSBzdGF0ZSBtYWNoaW5lLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuX3NldFN0YXRlID0gZnVuY3Rpb24obmV3U3RhdGUsIGRhdGEpIHtcbiAgaWYgKHRoaXMuc3RhdGUgPT09IG5ld1N0YXRlKSByZXR1cm47XG5cbiAgLy8gSSBtYWRlIGEgc3RhdGUgZGlhZ3JhbS4gVGhlIG9ubHkgaW52YWxpZCB0cmFuc2l0aW9ucyBhcmUgZ2V0dGluZyB0b1xuICAvLyAnY29ubmVjdGluZycgZnJvbSBhbnl3aGVyZSBvdGhlciB0aGFuICdkaXNjb25uZWN0ZWQnIGFuZCBnZXR0aW5nIHRvXG4gIC8vICdjb25uZWN0ZWQnIGZyb20gYW55d2hlcmUgb3RoZXIgdGhhbiAnY29ubmVjdGluZycuXG4gIGlmICgobmV3U3RhdGUgPT09ICdjb25uZWN0aW5nJyAmJiAodGhpcy5zdGF0ZSAhPT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgdGhpcy5zdGF0ZSAhPT0gJ3N0b3BwZWQnKSlcbiAgICAgIHx8IChuZXdTdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcgJiYgdGhpcy5zdGF0ZSAhPT0gJ2Nvbm5lY3RpbmcnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB0cmFuc2l0aW9uIGRpcmVjdGx5IGZyb20gXCIgKyB0aGlzLnN0YXRlICsgXCIgdG8gXCIgKyBuZXdTdGF0ZSk7XG4gIH1cblxuICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gIHRoaXMuY2FuU2VuZCA9IG5ld1N0YXRlID09PSAnY29ubmVjdGluZycgfHwgbmV3U3RhdGUgPT09ICdjb25uZWN0ZWQnO1xuXG4gIGlmIChuZXdTdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHRoaXMucmVzZXQoKTtcblxuICB0aGlzLmVtaXQobmV3U3RhdGUsIGRhdGEpO1xuXG4gIC8vICYgRW1pdCB0aGUgZXZlbnQgdG8gYWxsIGRvY3VtZW50cyAmIHF1ZXJpZXMuIEl0IG1pZ2h0IG1ha2Ugc2Vuc2UgZm9yXG4gIC8vIGRvY3VtZW50cyB0byBqdXN0IHJlZ2lzdGVyIGZvciB0aGlzIHN0dWZmIHVzaW5nIGV2ZW50cywgYnV0IHRoYXQgY291cGxlc1xuICAvLyBjb25uZWN0aW9ucyBhbmQgZG9jdW1lbnRzIGEgYml0IG11Y2guIEl0cyBub3QgYSBiaWcgZGVhbCBlaXRoZXIgd2F5LlxuICB0aGlzLm9wUXVldWUgPSBbXTtcbiAgZm9yICh2YXIgYyBpbiB0aGlzLmNvbGxlY3Rpb25zKSB7XG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb25zW2NdO1xuICAgIGZvciAodmFyIGRvY05hbWUgaW4gY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbltkb2NOYW1lXS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKG5ld1N0YXRlLCBkYXRhKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9wUXVldWUuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLnNlcSAtIGIuc2VxOyB9KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnNlbmQodGhpcy5vcFF1ZXVlW2ldKTtcbiAgfVxuICB0aGlzLm9wUXVldWUgPSBudWxsO1xuICBcbiAgZm9yICh2YXIgaWQgaW4gdGhpcy5xdWVyaWVzKSB7XG4gICAgdGhpcy5xdWVyaWVzW2lkXS5fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkKG5ld1N0YXRlLCBkYXRhKTtcbiAgfVxufTtcblxuLy8gU28sIHRoZXJlJ3MgYW4gYXdmdWwgZXJyb3IgY2FzZSB3aGVyZSB0aGUgY2xpZW50IHNlbmRzIHR3byByZXF1ZXN0cyAod2hpY2hcbi8vIGZhaWwpLCB0aGVuIHJlY29ubmVjdHMuIFRoZSBkb2N1bWVudHMgY291bGQgaGF2ZSBfb25Db25uZWN0aW9uU3RhdGVDaGFuZ2VkXG4vLyBjYWxsZWQgaW4gdGhlIHdyb25nIG9yZGVyIGFuZCB0aGUgb3BlcmF0aW9ucyB0aGVuIGdldCBzZW50IHdpdGggcmV2ZXJzZWRcbi8vIHNlcXVlbmNlIG51bWJlcnMuIFRoaXMgY2F1c2VzIHRoZSBzZXJ2ZXIgdG8gaW5jb3JyZWN0bHkgcmVqZWN0IHRoZSBzZWNvbmRcbi8vIHNlbnQgb3AuIFNvIHdlIG5lZWQgdG8gcXVldWUgdGhlIG9wZXJhdGlvbnMgd2hpbGUgd2UncmUgcmVjb25uZWN0aW5nIGFuZFxuLy8gcmVzZW5kIHRoZW0gaW4gdGhlIGNvcnJlY3Qgb3JkZXIuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5zZW5kT3AgPSBmdW5jdGlvbihkYXRhKSB7XG4gIGlmICh0aGlzLm9wUXVldWUpIHtcbiAgICB0aGlzLm9wUXVldWUucHVzaChkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmQoZGF0YSk7XG4gIH1cbn07XG5cbi8vIFNlbmQgYSBtZXNzYWdlIHRvIHRoZSBjb25uZWN0aW9uLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1zZykge1xuICBpZiAodGhpcy5kZWJ1ZykgY29uc29sZS5sb2coXCJTRU5EXCIsIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuXG4gIGlmIChtc2cuZCkgeyAvLyBUaGUgZG9jdW1lbnQgdGhlIG1lc3NhZ2UgcmVmZXJzIHRvLiBOb3Qgc2V0IGZvciBxdWVyaWVzLlxuICAgIHZhciBjb2xsZWN0aW9uID0gbXNnLmM7XG4gICAgdmFyIGRvY05hbWUgPSBtc2cuZDtcbiAgICBpZiAoY29sbGVjdGlvbiA9PT0gdGhpcy5fbGFzdFNlbnRDb2xsZWN0aW9uICYmIGRvY05hbWUgPT09IHRoaXMuX2xhc3RTZW50RG9jKSB7XG4gICAgICBkZWxldGUgbXNnLmM7XG4gICAgICBkZWxldGUgbXNnLmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xhc3RTZW50Q29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICB0aGlzLl9sYXN0U2VudERvYyA9IGRvY05hbWU7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5zb2NrZXQuc2VuZChtc2cpO1xufTtcblxuQ29ubmVjdGlvbi5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICAvLyBUaGlzIHdpbGwgY2FsbCBAc29ja2V0Lm9uY2xvc2UoKSwgd2hpY2ggaW4gdHVybiB3aWxsIGVtaXQgdGhlICdkaXNjb25uZWN0ZWQnIGV2ZW50LlxuICB0aGlzLnNvY2tldC5jbG9zZSgpO1xufTtcblxuXG4vLyAqKioqKiBEb2N1bWVudCBtYW5hZ2VtZW50XG5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG5hbWUpIHtcbiAgaWYgKHRoaXMuY29sbGVjdGlvbnNbY29sbGVjdGlvbl0pIHJldHVybiB0aGlzLmNvbGxlY3Rpb25zW2NvbGxlY3Rpb25dW25hbWVdO1xufTtcblxuLy8gQ3JlYXRlIGEgZG9jdW1lbnQgaWYgaXQgZG9lc24ndCBleGlzdC4gUmV0dXJucyB0aGUgZG9jdW1lbnQgc3luY2hyb25vdXNseS5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmdldE9yQ3JlYXRlID0gZnVuY3Rpb24oY29sbGVjdGlvbiwgbmFtZSwgZGF0YSkge1xuICB2YXIgZG9jID0gdGhpcy5nZXQoY29sbGVjdGlvbiwgbmFtZSk7XG5cbiAgaWYgKCFkb2MpIHtcbiAgICAvLyBDcmVhdGUgaXQuXG4gICAgZG9jID0gbmV3IERvYyh0aGlzLCBjb2xsZWN0aW9uLCBuYW1lKTtcblxuICAgIHZhciBjb2xsZWN0aW9uT2JqZWN0ID0gdGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSA9XG4gICAgICAodGhpcy5jb2xsZWN0aW9uc1tjb2xsZWN0aW9uXSB8fCB7fSk7XG4gICAgY29sbGVjdGlvbk9iamVjdFtuYW1lXSA9IGRvYztcbiAgfVxuXG4gIC8vIEV2ZW4gaWYgdGhlIGRvY3VtZW50IGlzbid0IG5ldywgaXRzIHBvc3NpYmxlIHRoZSBkb2N1bWVudCB3YXMgY3JlYXRlZFxuICAvLyBtYW51YWxseSBhbmQgdGhlbiB0cmllZCB0byBiZSByZS1jcmVhdGVkIHdpdGggZGF0YSAoc3VwcG9zZSBhIHF1ZXJ5XG4gIC8vIHJldHVybnMgd2l0aCBkYXRhIGZvciB0aGUgZG9jdW1lbnQpLiBXZSBzaG91bGQgaHlkcmF0ZSB0aGUgZG9jdW1lbnRcbiAgLy8gaW1tZWRpYXRlbHkgaWYgd2UgY2FuIGJlY2F1c2UgdGhlIHF1ZXJ5IGNhbGxiYWNrIHdpbGwgZXhwZWN0IHRoZSBkb2N1bWVudFxuICAvLyB0byBoYXZlIGRhdGEuXG4gIGlmIChkYXRhICYmIGRhdGEuc25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhZG9jLnN0YXRlKSB7XG4gICAgZG9jLmluamVzdERhdGEoZGF0YSk7XG4gIH1cblxuICByZXR1cm4gZG9jO1xufTtcblxuLy8gQ2FsbCBkb2MuZGVzdHJveSgpXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZGVzdHJveURvYyA9IGZ1bmN0aW9uKGRvYykge1xuICB2YXIgY29sbGVjdGlvbk9iamVjdCA9IHRoaXMuY29sbGVjdGlvbnNbZG9jLmNvbGxlY3Rpb25dO1xuICBpZiAoIWNvbGxlY3Rpb25PYmplY3QpIHJldHVybjtcblxuICBkZWxldGUgY29sbGVjdGlvbk9iamVjdFtkb2MubmFtZV07XG5cbiAgLy8gRGVsZXRlIHRoZSBjb2xsZWN0aW9uIGNvbnRhaW5lciBpZiBpdHMgZW1wdHkuIFRoaXMgY291bGQgYmUgYSBzb3VyY2Ugb2ZcbiAgLy8gbWVtb3J5IGxlYWtzIGlmIHlvdSBzbG93bHkgbWFrZSBhIGJpbGxpb24gY29sbGVjdGlvbnMsIHdoaWNoIHlvdSBwcm9iYWJseVxuICAvLyB3b24ndCBkbyBhbnl3YXksIGJ1dCB3aGF0ZXZlci5cbiAgaWYgKCFoYXNLZXlzKGNvbGxlY3Rpb25PYmplY3QpKVxuICAgIGRlbGV0ZSB0aGlzLmNvbGxlY3Rpb25zW2RvYy5jb2xsZWN0aW9uXTtcbn07XG4gXG5mdW5jdGlvbiBoYXNLZXlzKG9iamVjdCkge1xuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gKioqKiBRdWVyaWVzLlxuXG4vLyBIZWxwZXIgZm9yIGNyZWF0ZUZldGNoUXVlcnkgYW5kIGNyZWF0ZVN1YnNjcmliZVF1ZXJ5LCBiZWxvdy5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLl9jcmVhdGVRdWVyeSA9IGZ1bmN0aW9uKHR5cGUsIGNvbGxlY3Rpb24sIHEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlICE9PSAnZmV0Y2gnICYmIHR5cGUgIT09ICdzdWInKVxuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBxdWVyeSB0eXBlOiAnICsgdHlwZSk7XG5cbiAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gIHZhciBpZCA9IHRoaXMubmV4dFF1ZXJ5SWQrKztcbiAgdmFyIHF1ZXJ5ID0gbmV3IFF1ZXJ5KHR5cGUsIHRoaXMsIGlkLCBjb2xsZWN0aW9uLCBxLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gIHRoaXMucXVlcmllc1tpZF0gPSBxdWVyeTtcbiAgcXVlcnkuX2V4ZWN1dGUoKTtcbiAgcmV0dXJuIHF1ZXJ5O1xufTtcblxuLy8gSW50ZXJuYWwgZnVuY3Rpb24uIFVzZSBxdWVyeS5kZXN0cm95KCkgdG8gcmVtb3ZlIHF1ZXJpZXMuXG5Db25uZWN0aW9uLnByb3RvdHlwZS5fZGVzdHJveVF1ZXJ5ID0gZnVuY3Rpb24ocXVlcnkpIHtcbiAgZGVsZXRlIHRoaXMucXVlcmllc1txdWVyeS5pZF07XG59O1xuXG4vLyBUaGUgcXVlcnkgb3B0aW9ucyBvYmplY3QgY2FuIGNvbnRhaW4gdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4vL1xuLy8gZG9jTW9kZTogV2hhdCB0byBkbyB3aXRoIGRvY3VtZW50cyB0aGF0IGFyZSBpbiB0aGUgcmVzdWx0IHNldC4gQ2FuIGJlXG4vLyAgIG51bGwvdW5kZWZpbmVkIChkZWZhdWx0KSwgJ2ZldGNoJyBvciAnc3Vic2NyaWJlJy4gRmV0Y2ggbW9kZSBpbmRpY2F0ZXNcbi8vICAgdGhhdCB0aGUgc2VydmVyIHNob3VsZCBzZW5kIGRvY3VtZW50IHNuYXBzaG90cyB0byB0aGUgY2xpZW50IGZvciBhbGwgcXVlcnlcbi8vICAgcmVzdWx0cy4gVGhlc2Ugd2lsbCBiZSBoeWRyYXRlZCBpbnRvIHRoZSBkb2N1bWVudCBvYmplY3RzIGJlZm9yZSB0aGUgcXVlcnlcbi8vICAgcmVzdWx0IGNhbGxiYWNrcyBhcmUgcmV0dXJuZWQuIFN1YnNjcmliZSBtb2RlIGdldHMgZG9jdW1lbnQgc25hcHNob3RzIGFuZFxuLy8gICBhdXRvbWF0aWNhbGx5IHN1YnNjcmliZXMgdGhlIGNsaWVudCB0byBhbGwgcmVzdWx0cy4gTm90ZSB0aGF0IHRoZVxuLy8gICBkb2N1bWVudHMgKldJTEwgTk9UKiBiZSBhdXRvbWF0aWNhbGx5IHVuc3Vic2NyaWJlZCB3aGVuIHRoZSBxdWVyeSBpc1xuLy8gICBkZXN0cm95ZWQuIChTaGFyZUpTIGRvZXNuJ3QgaGF2ZSBlbm91Z2ggaW5mb3JtYXRpb24gdG8gZG8gdGhhdCBzYWZlbHkpLlxuLy8gICBCZXdhcmUgb2YgbWVtb3J5IGxlYWtzIHdoZW4gdXNpbmcgdGhpcyBvcHRpb24uXG4vL1xuLy8gcG9sbDogRm9yY2FibHkgZW5hYmxlIG9yIGRpc2FibGUgcG9sbGluZyBtb2RlLiBQb2xsaW5nIG1vZGUgd2lsbCByZWlzc3VlIHRoZSBxdWVyeVxuLy8gICBldmVyeSB0aW1lIGFueXRoaW5nIGluIHRoZSBjb2xsZWN0aW9uIGNoYW5nZXMgKCEhKSBzbywgaXRzIHF1aXRlXG4vLyAgIGV4cGVuc2l2ZS4gIEl0IGlzIGF1dG9tYXRpY2FsbHkgZW5hYmxlZCBmb3IgcGFnaW5hdGVkIGFuZCBzb3J0ZWQgcXVlcmllcy5cbi8vICAgQnkgZGVmYXVsdCBxdWVyaWVzIHJ1biB3aXRoIHBvbGxpbmcgbW9kZSBkaXNhYmxlZDsgd2hpY2ggd2lsbCBvbmx5IGNoZWNrXG4vLyAgIGNoYW5nZWQgZG9jdW1lbnRzIHRvIHRlc3QgaWYgdGhleSBub3cgbWF0Y2ggdGhlIHNwZWNpZmllZCBxdWVyeS5cbi8vICAgU2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgcG9sbGluZyBtb2RlLCBvciB0cnVlIHRvIGVuYWJsZSBpdC4gSWYgeW91IGRvbid0XG4vLyAgIHNwZWNpZnkgYSBwb2xsIG9wdGlvbiwgcG9sbGluZyBtb2RlIGlzIGVuYWJsZWQgb3IgZGlzYWJsZWQgYXV0b21hdGljYWxseVxuLy8gICBieSB0aGUgcXVlcnkncyBiYWNrZW5kLlxuLy9cbi8vIGJhY2tlbmQ6IFNldCB0aGUgYmFja2VuZCBzb3VyY2UgZm9yIHRoZSBxdWVyeS4gWW91IGNhbiBhdHRhY2ggZGlmZmVyZW50XG4vLyAgIHF1ZXJ5IGJhY2tlbmRzIHRvIGxpdmVkYiBhbmQgcGljayB3aGljaCBvbmUgdGhlIHF1ZXJ5IHNob3VsZCBoaXQgdXNpbmdcbi8vICAgdGhpcyBwYXJhbWV0ZXIuXG4vL1xuLy8gcmVzdWx0czogKGV4cGVyaW1lbnRhbCkgSW5pdGlhbCBsaXN0IG9mIHJlc3VsdGFudCBkb2N1bWVudHMuIFRoaXMgaXNcbi8vICAgdXNlZnVsIGZvciByZWh5ZHJhdGluZyBxdWVyaWVzIHdoZW4geW91J3JlIHVzaW5nIGF1dG9GZXRjaCAvIGF1dG9TdWJzY3JpYmVcbi8vICAgc28gdGhlIHNlcnZlciBkb2Vzbid0IGhhdmUgdG8gc2VuZCBvdmVyIHNuYXBzaG90cyBmb3IgZG9jdW1lbnRzIHRoZSBjbGllbnRcbi8vICAgYWxyZWFkeSBrbm93cyBhYm91dC4gVGhpcyBpcyBleHBlcmltZW50YWwgLSB0aGUgQVBJIG1heSBjaGFuZ2UgaW4gdXBjb21pbmdcbi8vICAgdmVyc2lvbnMuXG5cbi8vIENyZWF0ZSBhIGZldGNoIHF1ZXJ5LiBGZXRjaCBxdWVyaWVzIGFyZSBvbmx5IGlzc3VlZCBvbmNlLCByZXR1cm5pbmcgdGhlXG4vLyByZXN1bHRzIGRpcmVjdGx5IGludG8gdGhlIGNhbGxiYWNrLlxuLy9cbi8vIFRoZSBpbmRleCBpcyBzcGVjaWZpYyB0byB0aGUgc291cmNlLCBidXQgaWYgeW91J3JlIHVzaW5nIG1vbmdvZGIgaXQnbGwgYmVcbi8vIHRoZSBjb2xsZWN0aW9uIHRvIHdoaWNoIHRoZSBxdWVyeSBpcyBtYWRlLlxuLy8gVGhlIGNhbGxiYWNrIHNob3VsZCBoYXZlIHRoZSBzaWduYXR1cmUgZnVuY3Rpb24oZXJyb3IsIHJlc3VsdHMsIGV4dHJhRGF0YSlcbi8vIHdoZXJlIHJlc3VsdHMgaXMgYSBsaXN0IG9mIERvYyBvYmplY3RzLlxuQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlRmV0Y2hRdWVyeSA9IGZ1bmN0aW9uKGluZGV4LCBxLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICByZXR1cm4gdGhpcy5fY3JlYXRlUXVlcnkoJ2ZldGNoJywgaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbi8vIENyZWF0ZSBhIHN1YnNjcmliZSBxdWVyeS4gU3Vic2NyaWJlIHF1ZXJpZXMgcmV0dXJuIHdpdGggdGhlIGluaXRpYWwgZGF0YVxuLy8gdGhyb3VnaCB0aGUgY2FsbGJhY2ssIHRoZW4gdXBkYXRlIHRoZW1zZWx2ZXMgd2hlbmV2ZXIgdGhlIHF1ZXJ5IHJlc3VsdCBzZXRcbi8vIGNoYW5nZXMgdmlhIHRoZWlyIG93biBldmVudCBlbWl0dGVyLlxuLy9cbi8vIElmIHByZXNlbnQsIHRoZSBjYWxsYmFjayBzaG91bGQgaGF2ZSB0aGUgc2lnbmF0dXJlIGZ1bmN0aW9uKGVycm9yLCByZXN1bHRzLCBleHRyYURhdGEpXG4vLyB3aGVyZSByZXN1bHRzIGlzIGEgbGlzdCBvZiBEb2Mgb2JqZWN0cy5cbkNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmliZVF1ZXJ5ID0gZnVuY3Rpb24oaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHJldHVybiB0aGlzLl9jcmVhdGVRdWVyeSgnc3ViJywgaW5kZXgsIHEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbn07XG5cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgTWljcm9FdmVudCA9IHJlcXVpcmUoJy4vbWljcm9ldmVudCcpO1xufVxuXG5NaWNyb0V2ZW50Lm1peGluKENvbm5lY3Rpb24pO1xuXG4iLCJ2YXIgdHlwZXMsIE1pY3JvRXZlbnQ7XG5cbmlmICh0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB0eXBlcyA9IHJlcXVpcmUoJ290dHlwZXMnKTtcbiAgTWljcm9FdmVudCA9IHJlcXVpcmUoJy4vbWljcm9ldmVudCcpO1xufSBlbHNlIHtcbiAgdHlwZXMgPSB3aW5kb3cub3R0eXBlcztcbn1cblxuLypcbiAqIEEgRG9jIGlzIGEgY2xpZW50J3MgdmlldyBvbiBhIHNoYXJlanMgZG9jdW1lbnQuXG4gKlxuICogRG9jdW1lbnRzIHNob3VsZCBub3QgYmUgY3JlYXRlZCBkaXJlY3RseS4gQ3JlYXRlIHRoZW0gYnkgY2FsbGluZyB0aGVcbiAqIGRvY3VtZW50IGdldHRpbmcgZnVuY3Rpb25zIGluIGNvbm5lY3Rpb24uXG4gKlxuICogRG9jdW1lbnRzIGFyZSBldmVudCBlbWl0dGVycy4gVXNlIGRvYy5vbihldmVudG5hbWUsIGZuKSB0byBzdWJzY3JpYmUuXG4gKlxuICogRG9jdW1lbnRzIGN1cnJlbnRseSBnZXQgbWl4ZWQgaW4gd2l0aCB0aGVpciB0eXBlJ3MgQVBJIG1ldGhvZHMuIFNvLCB5b3UgY2FuXG4gKiAuaW5zZXJ0KCdmb28nLCAwKSBpbnRvIGEgdGV4dCBkb2N1bWVudCBhbmQgc3R1ZmYgbGlrZSB0aGF0LlxuICpcbiAqIEV2ZW50czpcbiAqIC0gYmVmb3JlIG9wIChvcCwgbG9jYWxTaXRlKTogRmlyZWQgYmVmb3JlIGFuIG9wZXJhdGlvbiBpcyBhcHBsaWVkIHRvIHRoZVxuICogICBkb2N1bWVudC5cbiAqIC0gb3AgKG9wLCBsb2NhbFNpdGUpOiBGaXJlZCByaWdodCBhZnRlciBhbiBvcGVyYXRpb24gKG9yIHBhcnQgb2YgYW5cbiAqICAgb3BlcmF0aW9uKSBoYXMgYmVlbiBhcHBsaWVkIHRvIHRoZSBkb2N1bWVudC4gU3VibWl0dGluZyBhbm90aGVyIG9wIGhlcmUgaXNcbiAqICAgaW52YWxpZCAtIHdhaXQgdW50aWwgJ2FmdGVyIG9wJyBpZiB5b3Ugd2FudCB0byBzdWJtaXQgbW9yZSBvcGVyYXRpb25zLiAgLVxuICogICBjaGFuZ2VkIChvcClcbiAqIC0gYWZ0ZXIgb3AgKG9wLCBsb2NhbFNpdGUpOiBGaXJlZCBhZnRlciBhbiBvcGVyYXRpb24gaGFzIGJlZW4gYXBwbGllZC4gWW91XG4gKiAgIGNhbiBzdWJtaXQgbW9yZSBvcHMgaGVyZS5cbiAqIC0gc3Vic2NyaWJlZCAoZXJyb3IpOiBUaGUgZG9jdW1lbnQgd2FzIHN1YnNjcmliZWRcbiAqIC0gdW5zdWJzY3JpYmVkIChlcnJvcik6IFRoZSBkb2N1bWVudCB3YXMgdW5zdWJzY3JpYmVkXG4gKiAtIGNyZWF0ZWQ6IFRoZSBkb2N1bWVudCB3YXMgY3JlYXRlZC4gVGhhdCBtZWFucyBpdHMgdHlwZSB3YXMgc2V0IGFuZCBpdCBoYXNcbiAqICAgc29tZSBpbml0aWFsIGRhdGEuXG4gKiAtIGVycm9yXG4gKi9cbnZhciBEb2MgPSBleHBvcnRzLkRvYyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb24sIGNvbGxlY3Rpb24sIG5hbWUpIHtcbiAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcblxuICB0aGlzLmNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gIHRoaXMudmVyc2lvbiA9IHRoaXMudHlwZSA9IG51bGw7XG5cbiAgLy8gKioqKiBTdGF0ZSBpbiBkb2N1bWVudDpcbiBcbiAgLy8gQWN0aW9uLiBUaGlzIGlzIGVpdGhlciBudWxsLCBvciBvbmUgb2YgdGhlIGFjdGlvbnMgKHN1YnNjcmliZSxcbiAgLy8gdW5zdWJzY3JpYmUsIGZldGNoLCBzdWJtaXQpLiBPbmx5IG9uZSBhY3Rpb24gY2FuIGJlIGhhcHBlbmluZyBhdCBhIHRpbWUgdG9cbiAgLy8gcHJldmVudCBtZSBmcm9tIGdvaW5nIG1hZC5cbiAgLy9cbiAgLy8gUG9zc2libGUgdmFsdWVzOlxuICAvLyAtIHN1YnNjcmliZVxuICAvLyAtIHVuc3Vic2NyaWJlXG4gIC8vIC0gZmV0Y2hcbiAgLy8gLSBzdWJtaXRcbiAgdGhpcy5hY3Rpb24gPSBudWxsO1xuIFxuICAvLyBUaGUgZGF0YSB0aGUgZG9jdW1lbnQgb2JqZWN0IHN0b3JlcyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgdGhyZWUgc3RhdGVzOlxuICAvLyAgIC0gTm8gZGF0YS4gKG51bGwpIFdlIGhvbmVzdGx5IGRvbid0IGtub3cgd2hhdHMgZ29pbmcgb24uXG4gIC8vICAgLSBGbG9hdGluZyAoJ2Zsb2F0aW5nJyk6IHdlIGhhdmUgYSBsb2NhbGx5IGNyZWF0ZWQgZG9jdW1lbnQgdGhhdCBoYXNuJ3RcbiAgLy8gICAgIGJlZW4gY3JlYXRlZCBvbiB0aGUgc2VydmVyIHlldClcbiAgLy8gICAtIExpdmUgKCdyZWFkeScpICh3ZSBoYXZlIGRhdGEgdGhhdHMgY3VycmVudCBvbiB0aGUgc2VydmVyIGF0IHNvbWUgdmVyc2lvbikuXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuXG4gIC8vIE91ciBzdWJzY3JpcHRpb24gc3RhdHVzLiBFaXRoZXIgd2UncmUgc3Vic2NyaWJlZCBvbiB0aGUgc2VydmVyLCBvciB3ZSBhcmVuJ3QuXG4gIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAvLyBFaXRoZXIgd2Ugd2FudCB0byBiZSBzdWJzY3JpYmVkICh0cnVlKSwgd2Ugd2FudCBhIG5ldyBzbmFwc2hvdCBmcm9tIHRoZVxuICAvLyBzZXJ2ZXIgKCdmZXRjaCcpLCBvciB3ZSBkb24ndCBjYXJlIChmYWxzZSkuICBUaGlzIGlzIGFsc28gdXNlZCB3aGVuIHdlXG4gIC8vIGRpc2Nvbm5lY3QgJiByZWNvbm5lY3QgdG8gZGVjaWRlIHdoYXQgdG8gZG8uXG4gIHRoaXMud2FudFN1YnNjcmliZSA9IGZhbHNlO1xuICAvLyBUaGlzIGxpc3QgaXMgdXNlZCBmb3Igc3Vic2NyaWJlIGFuZCB1bnN1YnNjcmliZSwgc2luY2Ugd2UnbGwgb25seSB3YW50IHRvXG4gIC8vIGRvIG9uZSB0aGluZyBhdCBhIHRpbWUuXG4gIHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcyA9IFtdO1xuXG5cbiAgLy8gKioqIGVuZCBzdGF0ZSBzdHVmZi5cblxuICAvLyBUaGlzIGRvZXNuJ3QgcHJvdmlkZSBhbnkgc3RhbmRhcmQgQVBJIGFjY2VzcyByaWdodCBub3cuXG4gIHRoaXMucHJvdmlkZXMgPSB7fTtcblxuICAvLyBUaGUgZWRpdGluZyBjb250ZXh0cy4gVGhlc2UgYXJlIHVzdWFsbHkgaW5zdGFuY2VzIG9mIHRoZSB0eXBlIEFQSSB3aGVuIHRoZVxuICAvLyBkb2N1bWVudCBpcyByZWFkeSBmb3IgZWRpdHMuXG4gIHRoaXMuZWRpdGluZ0NvbnRleHRzID0gW107XG4gIFxuICAvLyBUaGUgb3AgdGhhdCBpcyBjdXJyZW50bHkgcm91bmR0cmlwcGluZyB0byB0aGUgc2VydmVyLCBvciBudWxsLlxuICAvL1xuICAvLyBXaGVuIHRoZSBjb25uZWN0aW9uIHJlY29ubmVjdHMsIHRoZSBpbmZsaWdodCBvcCBpcyByZXN1Ym1pdHRlZC5cbiAgLy9cbiAgLy8gVGhpcyBoYXMgdGhlIHNhbWUgZm9ybWF0IGFzIGFuIGVudHJ5IGluIHBlbmRpbmdEYXRhLCB3aGljaCBpczpcbiAgLy8ge1tjcmVhdGU6ey4uLn1dLCBbZGVsOnRydWVdLCBbb3A6Li4uXSwgY2FsbGJhY2tzOlsuLi5dLCBzcmM6LCBzZXE6fVxuICB0aGlzLmluZmxpZ2h0RGF0YSA9IG51bGw7XG5cbiAgLy8gQWxsIG9wcyB0aGF0IGFyZSB3YWl0aW5nIGZvciB0aGUgc2VydmVyIHRvIGFja25vd2xlZGdlIEBpbmZsaWdodERhdGFcbiAgLy8gVGhpcyB1c2VkIHRvIGp1c3QgYmUgYSBzaW5nbGUgb3BlcmF0aW9uLCBidXQgY3JlYXRlcyAmIGRlbGV0ZXMgY2FuJ3QgYmUgY29tcG9zZWQgd2l0aFxuICAvLyByZWd1bGFyIG9wZXJhdGlvbnMuXG4gIC8vXG4gIC8vIFRoaXMgaXMgYSBsaXN0IG9mIHtbY3JlYXRlOnsuLi59XSwgW2RlbDp0cnVlXSwgW29wOi4uLl0sIGNhbGxiYWNrczpbLi4uXX1cbiAgdGhpcy5wZW5kaW5nRGF0YSA9IFtdO1xufTtcblxuTWljcm9FdmVudC5taXhpbihEb2MpO1xuXG5Eb2MucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgZG9jID0gdGhpcztcbiAgdGhpcy51bnN1YnNjcmliZShmdW5jdGlvbigpIHtcbiAgICAvLyBEb24ndCBjYXJlIGlmIHRoZXJlJ3MgYW4gZXJyb3IgdW5zdWJzY3JpYmluZy5cblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBUaGVyZSdsbCBwcm9iYWJseSBiZSBub3RoaW5nIGhlcmUgc2VlaW5nIGFzIGhvdyB3ZSBqdXN0IHVuc3Vic2NyaWJlZC5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZG9jLl9zdWJzY3JpYmVDYWxsYmFja3NbaV0oJ0RvY3VtZW50IGRlc3Ryb3llZCcpO1xuICAgICAgfVxuICAgICAgZG9jLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICB9LCAwKTtcblxuICAgIGRvYy5jb25uZWN0aW9uLl9kZXN0cm95RG9jKGRvYyk7XG4gICAgZG9jLnJlbW92ZUNvbnRleHRzKCk7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICB9KTtcbn07XG5cblxuLy8gKioqKioqIE1hbmlwdWxhdGluZyB0aGUgZG9jdW1lbnQgc25hcHNob3QsIHZlcnNpb24gYW5kIHR5cGUuXG5cbi8vIFNldCB0aGUgZG9jdW1lbnQncyB0eXBlLCBhbmQgYXNzb2NpYXRlZCBwcm9wZXJ0aWVzLiBNb3N0IG9mIHRoZSBsb2dpYyBpblxuLy8gdGhpcyBmdW5jdGlvbiBleGlzdHMgdG8gdXBkYXRlIHRoZSBkb2N1bWVudCBiYXNlZCBvbiBhbnkgYWRkZWQgJiByZW1vdmVkIEFQSVxuLy8gbWV0aG9kcy5cbkRvYy5wcm90b3R5cGUuX3NldFR5cGUgPSBmdW5jdGlvbihuZXdUeXBlKSB7XG4gIGlmICh0eXBlb2YgbmV3VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoIXR5cGVzW25ld1R5cGVdKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHR5cGUgXCIgKyBuZXdUeXBlKTtcbiAgICBuZXdUeXBlID0gdHlwZXNbbmV3VHlwZV07XG4gIH1cbiAgdGhpcy5yZW1vdmVDb250ZXh0cygpO1xuXG4gIC8vIFNldCB0aGUgbmV3IHR5cGVcbiAgdGhpcy50eXBlID0gbmV3VHlwZTtcblxuICAvLyBJZiB3ZSByZW1vdmVkIHRoZSB0eXBlIGZyb20gdGhlIG9iamVjdCwgYWxzbyByZW1vdmUgaXRzIHNuYXBzaG90LlxuICBpZiAoIW5ld1R5cGUpIHtcbiAgICB0aGlzLnByb3ZpZGVzID0ge307XG4gIH0gZWxzZSBpZiAobmV3VHlwZS5hcGkpIHtcbiAgICAvLyBSZWdpc3RlciB0aGUgbmV3IHR5cGUncyBBUEkuXG4gICAgdGhpcy5wcm92aWRlcyA9IG5ld1R5cGUuYXBpLnByb3ZpZGVzO1xuICB9XG59O1xuXG4vLyBJbmplc3Qgc25hcHNob3QgZGF0YS4gVGhpcyBkYXRhIG11c3QgaW5jbHVkZSBhIHZlcnNpb24sIHNuYXBzaG90IGFuZCB0eXBlLlxuLy8gVGhpcyBpcyB1c2VkIGJvdGggdG8gaW5qZXN0IGRhdGEgdGhhdCB3YXMgZXhwb3J0ZWQgd2l0aCBhIHdlYnBhZ2UgYW5kIGRhdGFcbi8vIHRoYXQgd2FzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBkdXJpbmcgYSBmZXRjaC5cbkRvYy5wcm90b3R5cGUuaW5qZXN0RGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgaWYgKHRoaXMuc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybignSWdub3JpbmcgYXR0ZW1wdCB0byBpbmplc3QgZGF0YSBpbiBzdGF0ZScsIHRoaXMuc3RhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGEudiAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2ZXJzaW9uIGluIGluamVzdGVkIGRhdGEnKTtcblxuXG4gIHRoaXMudmVyc2lvbiA9IGRhdGEudjtcbiAgdGhpcy5zbmFwc2hvdCA9IGRhdGEuc25hcHNob3Q7XG4gIHRoaXMuX3NldFR5cGUoZGF0YS50eXBlKTtcblxuICB0aGlzLnN0YXRlID0gJ3JlYWR5JztcbiAgdGhpcy5lbWl0KCdyZWFkeScpO1xufTtcblxuLy8gR2V0IGFuZCByZXR1cm4gdGhlIGN1cnJlbnQgZG9jdW1lbnQgc25hcHNob3QuXG5Eb2MucHJvdG90eXBlLmdldFNuYXBzaG90ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnNuYXBzaG90O1xufTtcblxuLy8gVGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGF0IGEgdGltZSB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYSBzbmFwc2hvdCBhbmRcbi8vIHlvdSBjYW4gc3RhcnQgYXBwbHlpbmcgb3BlcmF0aW9ucy4gVGhpcyBtYXkgYmUgaW1tZWRpYXRlbHkuXG5Eb2MucHJvdG90eXBlLndoZW5SZWFkeSA9IGZ1bmN0aW9uKGZuKSB7XG4gIGlmICh0aGlzLnN0YXRlID09PSAncmVhZHknKSB7XG4gICAgZm4oKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9uKCdyZWFkeScsIGZuKTtcbiAgfVxufTtcblxuRG9jLnByb3RvdHlwZS5oYXNQZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmluZmxpZ2h0RGF0YSAhPSBudWxsIHx8ICEhdGhpcy5wZW5kaW5nRGF0YS5sZW5ndGg7XG59O1xuXG5cbi8vICoqKiogSGVscGVycyBmb3IgbmV0d29yayBtZXNzYWdlc1xuXG4vLyBTZW5kIGEgbWVzc2FnZSB0byB0aGUgY29ubmVjdGlvbiBmcm9tIHRoaXMgZG9jdW1lbnQuXG5Eb2MucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBtZXNzYWdlLmMgPSB0aGlzLmNvbGxlY3Rpb247XG4gIG1lc3NhZ2UuZCA9IHRoaXMubmFtZTtcbiAgdGhpcy5jb25uZWN0aW9uLnNlbmQobWVzc2FnZSk7XG59O1xuXG4vLyBUaGlzIGlzIGNhbGxlZCBieSB0aGUgY29ubmVjdGlvbiB3aGVuIGl0IHJlY2VpdmVzIGEgbWVzc2FnZSBmb3IgdGhlIGRvY3VtZW50LlxuRG9jLnByb3RvdHlwZS5fb25NZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGlmICghKG1zZy5jID09PSB0aGlzLmNvbGxlY3Rpb24gJiYgbXNnLmQgPT09IHRoaXMubmFtZSkpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4gLSBpdHMgYSBzYW5pdHkgY2hlY2sgZm9yIGJ1Z3MgaW4gdGhlIGNvbm5lY3Rpb24gY29kZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJHb3QgbWVzc2FnZSBmb3Igd3JvbmcgZG9jdW1lbnQuXCIpO1xuICB9XG5cbiAgLy8gbXNnLmEgPSB0aGUgYWN0aW9uLlxuICBzd2l0Y2ggKG1zZy5hKSB7XG4gICAgY2FzZSAnZmV0Y2gnOlxuICAgICAgLy8gV2UncmUgZG9uZSBmZXRjaGluZy4gVGhpcyBtZXNzYWdlIGhhcyBubyBvdGhlciBpbmZvcm1hdGlvbi5cbiAgICAgIGlmIChtc2cuZGF0YSkgdGhpcy5pbmplc3REYXRhKG1zZy5kYXRhKTtcbiAgICAgIHRoaXMuX2ZpbmlzaFN1YignZmV0Y2gnLCBtc2cuZXJyb3IpO1xuICAgICAgaWYgKHRoaXMud2FudFN1YnNjcmliZSA9PT0gJ2ZldGNoJykgdGhpcy53YW50U3Vic2NyaWJlID0gZmFsc2U7XG4gICAgICB0aGlzLl9jbGVhckFjdGlvbignZmV0Y2gnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnc3ViJzpcbiAgICAgIC8vIFN1YnNjcmliZSByZXBseS5cbiAgICAgIGlmIChtc2cuZXJyb3IgJiYgbXNnLmVycm9yICE9PSAnQWxyZWFkeSBzdWJzY3JpYmVkJykge1xuICAgICAgICBpZiAoY29uc29sZSkgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBzdWJzY3JpYmU6IFwiICsgbXNnLmVycm9yKTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG1zZy5lcnJvcik7XG4gICAgICAgIC8vIFRoZXJlJ3MgcHJvYmFibHkgYSByZWFzb24gd2UgY291bGRuJ3Qgc3Vic2NyaWJlLiBEb24ndCByZXRyeS5cbiAgICAgICAgdGhpcy5fc2V0V2FudFN1YnNjcmliZShmYWxzZSwgbnVsbCwgbXNnLmVycm9yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1zZy5kYXRhKSB0aGlzLmluamVzdERhdGEobXNnLmRhdGEpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ3N1YnNjcmliZScpO1xuICAgICAgICB0aGlzLl9maW5pc2hTdWIodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFyQWN0aW9uKCdzdWJzY3JpYmUnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndW5zdWInOlxuICAgICAgLy8gVW5zdWJzY3JpYmUgcmVwbHlcbiAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KCd1bnN1YnNjcmliZScpO1xuXG4gICAgICB0aGlzLl9maW5pc2hTdWIoZmFsc2UsIG1zZy5lcnJvcik7XG4gICAgICB0aGlzLl9jbGVhckFjdGlvbigndW5zdWJzY3JpYmUnKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYWNrJzpcbiAgICAgIC8vIEFja25vd2xlZGdlIGEgbG9jYWxseSBzdWJtaXR0ZWQgb3BlcmF0aW9uLlxuICAgICAgLy9cbiAgICAgIC8vIFVzdWFsbHkgd2UgZG8gbm90aGluZyBoZXJlIC0gYWxsIHRoZSBpbnRlcmVzdGluZyBsb2dpYyBoYXBwZW5zIHdoZW4gd2VcbiAgICAgIC8vIGdldCBzZW50IG91ciBvcCBiYWNrIGluIHRoZSBvcCBzdHJlYW0gKHdoaWNoIGhhcHBlbnMgZXZlbiBpZiB3ZSBhcmVuJ3RcbiAgICAgIC8vIHN1YnNjcmliZWQpLiBIb3dldmVyLCBpZiB0aGUgb3AgZG9lc24ndCBnZXQgYWNjZXB0ZWQsIHdlIHN0aWxsIG5lZWQgdG9cbiAgICAgIC8vIGNsZWFyIHNvbWUgc3RhdGUuXG4gICAgICAvL1xuICAgICAgLy8gSWYgdGhlIG1lc3NhZ2UgZXJyb3IgaXMgJ09wIGFscmVhZHkgc3VibWl0dGVkJywgdGhhdCBtZWFucyB3ZSd2ZVxuICAgICAgLy8gcmVzZW50IGFuIG9wIHRoYXQgdGhlIHNlcnZlciBhbHJlYWR5IGdvdC4gSXQgd2lsbCBhbHNvIGJlIGNvbmZpcm1lZFxuICAgICAgLy8gbm9ybWFsbHkuXG4gICAgICBpZiAobXNnLmVycm9yICYmIG1zZy5lcnJvciAhPT0gJ09wIGFscmVhZHkgc3VibWl0dGVkJykge1xuICAgICAgICAvLyBUaGUgc2VydmVyIGhhcyByZWplY3RlZCBhbiBvcCBmcm9tIHRoZSBjbGllbnQgZm9yIHNvbWUgcmVhc29uLlxuICAgICAgICAvLyBXZSdsbCBzZW5kIHRoZSBlcnJvciBtZXNzYWdlIHRvIHRoZSB1c2VyIGFuZCB0cnkgdG8gcm9sbCBiYWNrIHRoZSBjaGFuZ2UuXG4gICAgICAgIGlmICh0aGlzLmluZmxpZ2h0RGF0YSkge1xuICAgICAgICAgIHRoaXMuX3RyeVJvbGxiYWNrKHRoaXMuaW5mbGlnaHREYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJIG1hbmFnZWQgdG8gZ2V0IGludG8gdGhpcyBzdGF0ZSBvbmNlLiBJJ20gbm90IHN1cmUgaG93IGl0IGhhcHBlbmVkLlxuICAgICAgICAgIC8vIFRoZSBvcCB3YXMgbWF5YmUgZG91YmxlLWFja25vd2xlZGdlZD9cbiAgICAgICAgICBpZiAoY29uc29sZSkgY29uc29sZS53YXJuKCdTZWNvbmQgYWNrbm93bGVkZ2VtZW50IG1lc3NhZ2UgKGVycm9yKSByZWNlaXZlZCcsIG1zZywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgdGhpcy5fY2xlYXJJbmZsaWdodE9wKG1zZy5lcnJvcik7XG4gICAgICB9XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ29wJzpcbiAgICAgIGlmICh0aGlzLmluZmxpZ2h0RGF0YSAmJlxuICAgICAgICAgIG1zZy5zcmMgPT09IHRoaXMuaW5mbGlnaHREYXRhLnNyYyAmJlxuICAgICAgICAgIG1zZy5zZXEgPT09IHRoaXMuaW5mbGlnaHREYXRhLnNlcSkge1xuICAgICAgICAvLyBUaGlzIG9uZSBpcyBtaW5lLiBBY2NlcHQgaXQgYXMgYWNrbm93bGVkZ2VkLlxuICAgICAgICB0aGlzLl9vcEFja25vd2xlZGdlZChtc2cpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKG1zZy52ICE9PSB0aGlzLnZlcnNpb24pIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIFwiRXhwZWN0ZWQgdmVyc2lvbiBcIiArIHRoaXMudmVyc2lvbiArIFwiIGJ1dCBnb3QgXCIgKyBtc2cudik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pbmZsaWdodERhdGEpIHhmKHRoaXMuaW5mbGlnaHREYXRhLCBtc2cpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeGYodGhpcy5wZW5kaW5nRGF0YVtpXSwgbXNnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy52ZXJzaW9uKys7XG4gICAgICB0aGlzLl9vdEFwcGx5KG1zZywgZmFsc2UpO1xuICAgICAgdGhpcy5fYWZ0ZXJPdEFwcGx5KG1zZywgZmFsc2UpO1xuICAgICAgLy9jb25zb2xlLmxvZygnYXBwbGllZCcsIEpTT04uc3RyaW5naWZ5KG1zZykpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdtZXRhJzpcbiAgICAgIGlmIChjb25zb2xlKSBjb25zb2xlLndhcm4oJ1VuaGFuZGxlZCBtZXRhIG9wOicsIG1zZyk7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY29uc29sZSkgY29uc29sZS53YXJuKCdVbmhhbmRsZWQgZG9jdW1lbnQgbWVzc2FnZTonLCBtc2cpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8vIENhbGxlZCB3aGVuZXZlciAoeW91IGd1ZXNzZWQgaXQhKSB0aGUgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2VzLiBUaGlzIHdpbGxcbi8vIGhhcHBlbiB3aGVuIHdlIGdldCBkaXNjb25uZWN0ZWQgJiByZWNvbm5lY3QuXG5Eb2MucHJvdG90eXBlLl9vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSwgcmVhc29uKSB7XG4gIGlmIChzdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgaWYgKHRoaXMuaW5mbGlnaHREYXRhKSB7XG4gICAgICB0aGlzLl9zZW5kT3BEYXRhKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgLy8gV2UgZ28gaW50byB0aGUgY29ubmVjdGVkIHN0YXRlIG9uY2Ugd2UgaGF2ZSBhIHNlc3Npb25JRC4gV2UgY2FuJ3Qgc2VuZFxuICAgIC8vIG5ldyBvcHMgdW50aWwgdGhlbiwgc28gd2UgbmVlZCB0byBmbHVzaCBhZ2Fpbi5cbiAgICB0aGlzLmZsdXNoKCk7XG4gIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgdGhpcy5hY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnN1YnNjcmliZWQpIHRoaXMuZW1pdCgndW5zdWJzY3JpYmVkJyk7XG4gIH1cbn07XG5cblxuXG5cbi8vICoqKioqKiBEZWFsaW5nIHdpdGggYWN0aW9uc1xuXG5Eb2MucHJvdG90eXBlLl9jbGVhckFjdGlvbiA9IGZ1bmN0aW9uKGV4cGVjdGVkQWN0aW9uKSB7XG4gIGlmICh0aGlzLmFjdGlvbiAhPT0gZXhwZWN0ZWRBY3Rpb24pIHtcbiAgICBjb25zb2xlLndhcm4oJ1VuZXhwZWN0ZWQgYWN0aW9uICcgKyB0aGlzLmFjdGlvbiArICcgZXhwZWN0ZWQ6ICcgKyBleHBlY3RlZEFjdGlvbik7XG4gIH1cbiAgdGhpcy5hY3Rpb24gPSBudWxsO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG5cblxuLy8gU2VuZCB0aGUgbmV4dCBwZW5kaW5nIG9wIHRvIHRoZSBzZXJ2ZXIsIGlmIHdlIGNhbi5cbi8vXG4vLyBPbmx5IG9uZSBvcGVyYXRpb24gY2FuIGJlIGluLWZsaWdodCBhdCBhIHRpbWUuIElmIGFuIG9wZXJhdGlvbiBpcyBhbHJlYWR5IG9uXG4vLyBpdHMgd2F5LCBvciB3ZSdyZSBub3QgY3VycmVudGx5IGNvbm5lY3RlZCwgdGhpcyBtZXRob2QgZG9lcyBub3RoaW5nLlxuRG9jLnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY29ubmVjdGlvbi5jYW5TZW5kIHx8IHRoaXMuYWN0aW9uKSByZXR1cm47XG5cbiAgdmFyIG9wRGF0YTtcbiAgLy8gUHVtcCBhbmQgZHVtcCBhbnkgbm8tb3BzIGZyb20gdGhlIGZyb250IG9mIHRoZSBwZW5kaW5nIG9wIGxpc3QuXG4gIHdoaWxlICh0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAmJiBpc05vT3Aob3BEYXRhID0gdGhpcy5wZW5kaW5nRGF0YVswXSkpIHtcbiAgICB2YXIgY2FsbGJhY2tzID0gb3BEYXRhLmNhbGxiYWNrcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY2FsbGJhY2tzW2ldKG9wRGF0YS5lcnJvcik7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0RhdGEuc2hpZnQoKTtcbiAgfVxuXG4gIC8vIEZpcnN0IGNvbnNpZGVyIGNoYW5naW5nIHN0YXRlXG4gIGlmICh0aGlzLnN1YnNjcmliZWQgJiYgIXRoaXMud2FudFN1YnNjcmliZSkge1xuICAgIHRoaXMuYWN0aW9uID0gJ3Vuc3Vic2NyaWJlJztcbiAgICB0aGlzLl9zZW5kKHthOid1bnN1Yid9KTtcbiAgfSBlbHNlIGlmICghdGhpcy5zdWJzY3JpYmVkICYmIHRoaXMud2FudFN1YnNjcmliZSA9PT0gJ2ZldGNoJykge1xuICAgIHRoaXMuYWN0aW9uID0gJ2ZldGNoJztcbiAgICB0aGlzLl9zZW5kKHRoaXMuc3RhdGUgPT09ICdyZWFkeScgPyB7YTonZmV0Y2gnLCB2OnRoaXMudmVyc2lvbn0gOiB7YTonZmV0Y2gnfSk7XG4gIH0gZWxzZSBpZiAoIXRoaXMuc3Vic2NyaWJlZCAmJiB0aGlzLndhbnRTdWJzY3JpYmUpIHtcbiAgICB0aGlzLmFjdGlvbiA9ICdzdWJzY3JpYmUnO1xuICAgIHRoaXMuX3NlbmQodGhpcy5zdGF0ZSA9PT0gJ3JlYWR5JyA/IHthOidzdWInLCB2OnRoaXMudmVyc2lvbn0gOiB7YTonc3ViJ30pO1xuICB9IGVsc2UgaWYgKCF0aGlzLnBhdXNlZCAmJiB0aGlzLnBlbmRpbmdEYXRhLmxlbmd0aCAmJiB0aGlzLmNvbm5lY3Rpb24uc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgLy8gVHJ5IGFuZCBzZW5kIGFueSBwZW5kaW5nIG9wcy4gV2UgY2FuJ3Qgc2VuZCBvcHMgd2hpbGUgaW4gXG4gICAgdGhpcy5pbmZsaWdodERhdGEgPSB0aGlzLnBlbmRpbmdEYXRhLnNoaWZ0KCk7XG5cbiAgICAvLyBEZWxheSBmb3IgZGVidWdnaW5nLlxuICAgIC8vdmFyIHRoYXQgPSB0aGlzO1xuICAgIC8vc2V0VGltZW91dChmdW5jdGlvbigpIHsgdGhhdC5fc2VuZE9wRGF0YSgpOyB9LCAxMDAwKTtcblxuICAgIC8vIFRoaXMgYWxzbyBzZXRzIGFjdGlvbiB0byAnc3VibWl0Jy5cbiAgICB0aGlzLl9zZW5kT3BEYXRhKCk7XG4gIH1cbn07XG5cblxuLy8gKioqKioqIFN1YnNjcmliaW5nLCB1bnN1YnNjcmliaW5nIGFuZCBmZXRjaGluZ1xuXG4vLyBUaGVzZSBmdW5jdGlvbnMgaWFyZSBjb3BpZWQgaW50byB0aGUgcXVlcnkgY2xhc3MgYXMgd2VsbCwgc28gYmUgY2FyZWZ1bCBtYWtpbmdcbi8vIGNoYW5nZXMgaGVyZS5cblxuLy8gVmFsdWUgaXMgdHJ1ZSwgZmFsc2Ugb3IgJ2ZldGNoJy5cbkRvYy5wcm90b3R5cGUuX3NldFdhbnRTdWJzY3JpYmUgPSBmdW5jdGlvbih2YWx1ZSwgY2FsbGJhY2ssIGVycikge1xuICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSB0aGlzLndhbnRTdWJzY3JpYmUgJiZcbiAgICAgICh0aGlzLnN1YnNjcmliZWQgPT09IHZhbHVlIHx8IHZhbHVlID09PSAnZmV0Y2gnICYmIHRoaXMuc3Vic2NyaWJlZCkpIHtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGVycik7XG4gICAgcmV0dXJuO1xuICB9XG4gIFxuICBpZiAoIXRoaXMud2FudFN1YnNjcmliZSAhPT0gIXZhbHVlKSB7XG4gICAgLy8gQ2FsbCBhbGwgdGhlIGN1cnJlbnQgc3Vic2NyaWJlL3Vuc3Vic2NyaWJlIGNhbGxiYWNrcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N1YnNjcmliZUNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gU2hvdWxkIEkgcmV0dXJuIGFuIGVycm9yIGhlcmU/IFdoYXQgaGFwcGVuZWQgaXMgdGhlIHVzZXIgdW5zdWJjcmliZWRcbiAgICAgIC8vIHdpdGggYSBjYWxsYmFjayB0aGVuIHJlc3Vic2NyaWJlZCBzdHJhaWdodCBhZnRlci4gRG9lcyB0aGF0IG1lYW4gdGhlXG4gICAgICAvLyB1bnN1YnNjcmliZSBmYWlsZWQ/XG4gICAgICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3NbaV0oZXJyKTtcbiAgICB9XG4gICAgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzLmxlbmd0aCA9IDA7XG4gIH1cblxuICAvLyBJZiB3ZSB3YW50IHRvIHN1YnNjcmliZSwgZG9uJ3Qgd2Vha2VuIGl0IHRvIGEgZmV0Y2guXG4gIGlmICh2YWx1ZSAhPT0gJ2ZldGNoJyB8fCB0aGlzLndhbnRTdWJzY3JpYmUgIT09IHRydWUpXG4gICAgdGhpcy53YW50U3Vic2NyaWJlID0gdmFsdWU7XG5cbiAgaWYgKGNhbGxiYWNrKSB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8vIE9wZW4gdGhlIGRvY3VtZW50LiBUaGVyZSBpcyBubyBjYWxsYmFjayBhbmQgbm8gZXJyb3IgaGFuZGxpbmcgaWYgeW91J3JlXG4vLyBhbHJlYWR5IGNvbm5lY3RlZC5cbi8vXG4vLyBPbmx5IGNhbGwgdGhpcyBvbmNlIHBlciBkb2N1bWVudC5cbkRvYy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fc2V0V2FudFN1YnNjcmliZSh0cnVlLCBjYWxsYmFjayk7XG59O1xuXG5Eb2MucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdGhpcy5fc2V0V2FudFN1YnNjcmliZShmYWxzZSwgY2FsbGJhY2spO1xufTtcblxuLy8gQ2FsbCB0byByZXF1ZXN0IGZyZXNoIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxuRG9jLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuX3NldFdhbnRTdWJzY3JpYmUoJ2ZldGNoJywgY2FsbGJhY2spO1xufTtcblxuLy8gQ2FsbGVkIHdoZW4gb3VyIHN1YnNjcmliZSwgZmV0Y2ggb3IgdW5zdWJzY3JpYmUgbWVzc2FnZXMgYXJlIGFja25vd2xlZGdlZC5cbkRvYy5wcm90b3R5cGUuX2ZpbmlzaFN1YiA9IGZ1bmN0aW9uKHZhbHVlLCBlcnJvcikge1xuICBpZiAodmFsdWUgPT09IHRoaXMud2FudFN1YnNjcmliZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3Vic2NyaWJlQ2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3NbaV0oZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLl9zdWJzY3JpYmVDYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgfVxufTtcblxuXG4vLyBPcGVyYXRpb25zXG5cblxuLy8gKioqKioqKioqKioqIERlYWxpbmcgd2l0aCBvcGVyYXRpb25zLlxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gc2V0IG9wRGF0YSB0byBjb250YWluIGEgbm8tb3AuXG52YXIgc2V0Tm9PcCA9IGZ1bmN0aW9uKG9wRGF0YSkge1xuICBkZWxldGUgb3BEYXRhLm9wO1xuICBkZWxldGUgb3BEYXRhLmNyZWF0ZTtcbiAgZGVsZXRlIG9wRGF0YS5kZWw7XG59O1xuXG52YXIgaXNOb09wID0gZnVuY3Rpb24ob3BEYXRhKSB7XG4gIHJldHVybiAhb3BEYXRhLm9wICYmICFvcERhdGEuY3JlYXRlICYmICFvcERhdGEuZGVsO1xufVxuXG4vLyBUcnkgdG8gY29tcG9zZSBkYXRhMiBpbnRvIGRhdGExLiBSZXR1cm5zIHRydXRoeSBpZiBpdCBzdWNjZWVkcywgb3RoZXJ3aXNlIGZhbHN5LlxudmFyIHRyeUNvbXBvc2UgPSBmdW5jdGlvbih0eXBlLCBkYXRhMSwgZGF0YTIpIHtcbiAgaWYgKGRhdGExLmNyZWF0ZSAmJiBkYXRhMi5kZWwpIHtcbiAgICBzZXROb09wKGRhdGExKTtcbiAgfSBlbHNlIGlmIChkYXRhMS5jcmVhdGUgJiYgZGF0YTIub3ApIHtcbiAgICAvLyBDb21wb3NlIHRoZSBkYXRhIGludG8gdGhlIGNyZWF0ZSBkYXRhLlxuICAgIHZhciBkYXRhID0gKGRhdGExLmNyZWF0ZS5kYXRhID09PSB1bmRlZmluZWQpID8gdHlwZS5jcmVhdGUoKSA6IGRhdGExLmNyZWF0ZS5kYXRhO1xuICAgIGRhdGExLmNyZWF0ZS5kYXRhID0gdHlwZS5hcHBseShkYXRhLCBkYXRhMi5vcCk7XG4gIH0gZWxzZSBpZiAoaXNOb09wKGRhdGExKSkge1xuICAgIGRhdGExLmNyZWF0ZSA9IGRhdGEyLmNyZWF0ZTtcbiAgICBkYXRhMS5kZWwgPSBkYXRhMi5kZWw7XG4gICAgZGF0YTEub3AgPSBkYXRhMi5vcDtcbiAgfSBlbHNlIGlmIChkYXRhMS5vcCAmJiBkYXRhMi5vcCAmJiB0eXBlLmNvbXBvc2UpIHtcbiAgICBkYXRhMS5vcCA9IHR5cGUuY29tcG9zZShkYXRhMS5vcCwgZGF0YTIub3ApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIFRyYW5zZm9ybSBzZXJ2ZXIgb3AgZGF0YSBieSBhIGNsaWVudCBvcCwgYW5kIHZpY2UgdmVyc2EuIE9wcyBhcmUgZWRpdGVkIGluIHBsYWNlLlxudmFyIHhmID0gZnVuY3Rpb24oY2xpZW50LCBzZXJ2ZXIpIHtcbiAgLy8gSW4gdGhpcyBjYXNlLCB3ZSdyZSBpbiBmb3Igc29tZSBmdW4uIFRoZXJlIGFyZSBzb21lIGxvY2FsIG9wZXJhdGlvbnNcbiAgLy8gd2hpY2ggYXJlIHRvdGFsbHkgaW52YWxpZCAtIGVpdGhlciB0aGUgY2xpZW50IGNvbnRpbnVlZCBlZGl0aW5nIGFcbiAgLy8gZG9jdW1lbnQgdGhhdCBzb21lb25lIGVsc2UgZGVsZXRlZCBvciBhIGRvY3VtZW50IHdhcyBjcmVhdGVkIGJvdGggb24gdGhlXG4gIC8vIGNsaWVudCBhbmQgb24gdGhlIHNlcnZlci4gSW4gZWl0aGVyIGNhc2UsIHRoZSBsb2NhbCBkb2N1bWVudCBpcyB3YXlcbiAgLy8gaW52YWxpZCBhbmQgdGhlIGNsaWVudCdzIG9wcyBhcmUgdXNlbGVzcy5cbiAgLy9cbiAgLy8gVGhlIGNsaWVudCBiZWNvbWVzIGEgbm8tb3AsIGFuZCB3ZSBrZWVwIHRoZSBzZXJ2ZXIgb3AgZW50aXJlbHkuXG4gIGlmIChzZXJ2ZXIuY3JlYXRlIHx8IHNlcnZlci5kZWwpIHJldHVybiBzZXROb09wKGNsaWVudCk7XG4gIGlmIChjbGllbnQuY3JlYXRlKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUuIFRoaXMgaXMgYSBidWcuJyk7XG5cbiAgLy8gVGhlIGNsaWVudCBoYXMgZGVsZXRlZCB0aGUgZG9jdW1lbnQgd2hpbGUgdGhlIHNlcnZlciBlZGl0ZWQgaXQuIEtpbGwgdGhlXG4gIC8vIHNlcnZlcidzIG9wLlxuICBpZiAoY2xpZW50LmRlbCkgcmV0dXJuIHNldE5vT3Aoc2VydmVyKTtcblxuICAvLyBXZSBvbmx5IGdldCBoZXJlIGlmIGVpdGhlciB0aGUgc2VydmVyIG9yIGNsaWVudCBvcHMgYXJlIG5vLW9wLiBDYXJyeSBvbixcbiAgLy8gbm90aGluZyB0byBzZWUgaGVyZS5cbiAgaWYgKCFzZXJ2ZXIub3AgfHwgIWNsaWVudC5vcCkgcmV0dXJuO1xuXG4gIC8vIFRoZXkgYm90aCBlZGl0ZWQgdGhlIGRvY3VtZW50LiBUaGlzIGlzIHRoZSBub3JtYWwgY2FzZSBmb3IgdGhpcyBmdW5jdGlvbiAtXG4gIC8vIGFzIGluLCBtb3N0IG9mIHRoZSB0aW1lIHdlJ2xsIGVuZCB1cCBkb3duIGhlcmUuXG4gIC8vXG4gIC8vIFlvdSBzaG91bGQgYmUgd29uZGVyaW5nIHdoeSBJJ20gdXNpbmcgY2xpZW50LnR5cGUgaW5zdGVhZCBvZiB0aGlzLnR5cGUuXG4gIC8vIFRoZSByZWFzb24gaXMsIGlmIHdlIGdldCBvcHMgYXQgYW4gb2xkIHZlcnNpb24gb2YgdGhlIGRvY3VtZW50LCB0aGlzLnR5cGVcbiAgLy8gbWlnaHQgYmUgdW5kZWZpbmVkIG9yIGEgdG90YWxseSBkaWZmZXJlbnQgdHlwZS4gQnkgcGlubmluZyB0aGUgdHlwZSB0byB0aGVcbiAgLy8gb3AgZGF0YSwgd2UgbWFrZSBzdXJlIHRoZSByaWdodCB0eXBlIGhhcyBpdHMgdHJhbnNmb3JtIGZ1bmN0aW9uIGNhbGxlZC5cbiAgaWYgKGNsaWVudC50eXBlLnRyYW5zZm9ybVgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2xpZW50LnR5cGUudHJhbnNmb3JtWChjbGllbnQub3AsIHNlcnZlci5vcCk7XG4gICAgY2xpZW50Lm9wID0gcmVzdWx0WzBdO1xuICAgIHNlcnZlci5vcCA9IHJlc3VsdFsxXTtcbiAgfSBlbHNlIHtcbiAgICAvL2NvbnNvbGUubG9nKCd4ZicsIEpTT04uc3RyaW5naWZ5KGNsaWVudC5vcCksIEpTT04uc3RyaW5naWZ5KHNlcnZlci5vcCkpO1xuICAgIHZhciBfYyA9IGNsaWVudC50eXBlLnRyYW5zZm9ybShjbGllbnQub3AsIHNlcnZlci5vcCwgJ2xlZnQnKTtcbiAgICB2YXIgX3MgPSBjbGllbnQudHlwZS50cmFuc2Zvcm0oc2VydmVyLm9wLCBjbGllbnQub3AsICdyaWdodCcpO1xuICAgIGNsaWVudC5vcCA9IF9jOyBzZXJ2ZXIub3AgPSBfcztcbiAgICAvL2NvbnNvbGUubG9nKCctPicsIEpTT04uc3RyaW5naWZ5KGNsaWVudC5vcCksIEpTT04uc3RyaW5naWZ5KHNlcnZlci5vcCkpO1xuICB9XG59O1xuXG4vLyBJbnRlcm5hbCBtZXRob2QgdG8gYWN0dWFsbHkgYXBwbHkgdGhlIGdpdmVuIG9wIGRhdGEgdG8gb3VyIGxvY2FsIG1vZGVsLlxuLy9cbi8vIF9hZnRlck90QXBwbHkoKSBzaG91bGQgYWx3YXlzIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5IGFmdGVyd2FyZHMuXG5Eb2MucHJvdG90eXBlLl9vdEFwcGx5ID0gZnVuY3Rpb24ob3BEYXRhLCBjb250ZXh0KSB7XG4gIC8vIExvY2sgdGhlIGRvY3VtZW50LiBOb2JvZHkgaXMgYWxsb3dlZCB0byBjYWxsIHN1Ym1pdE9wKCkgdW50aWwgX2FmdGVyT3RBcHBseSBpcyBjYWxsZWQuXG4gIHRoaXMubG9ja2VkID0gdHJ1ZTtcblxuICBpZiAob3BEYXRhLmNyZWF0ZSkge1xuICAgIC8vIElmIHRoZSB0eXBlIGlzIGN1cnJlbnRseSBzZXQsIGl0IG1lYW5zIHdlIHRyaWVkIGNyZWF0aW5nIHRoZSBkb2N1bWVudFxuICAgIC8vIGFuZCBzb21lb25lIGVsc2Ugd29uLiBjbGllbnQgY3JlYXRlIHggc2VydmVyIGNyZWF0ZSA9IHNlcnZlciBjcmVhdGUuXG4gICAgdmFyIGNyZWF0ZSA9IG9wRGF0YS5jcmVhdGU7XG4gICAgdGhpcy5fc2V0VHlwZShjcmVhdGUudHlwZSk7XG4gICAgdGhpcy5zbmFwc2hvdCA9IHRoaXMudHlwZS5jcmVhdGUoY3JlYXRlLmRhdGEpO1xuXG4gICAgLy8gVGhpcyBpcyBhIGJpdCBoZWF2eXdlaWdodCwgYnV0IEkgd2FudCB0aGUgY3JlYXRlZCBldmVudCB0byBmaXJlIG91dHNpZGUgb2YgdGhlIGxvY2suXG4gICAgdGhpcy5vbmNlKCd1bmxvY2snLCBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZW1pdCgnY3JlYXRlJywgY29udGV4dCk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAob3BEYXRhLmRlbCkge1xuICAgIC8vIFRoZSB0eXBlIHNob3VsZCBhbHdheXMgZXhpc3QgaW4gdGhpcyBjYXNlLiBkZWwgeCBfID0gZGVsXG4gICAgdmFyIG9sZFNuYXBzaG90ID0gdGhpcy5zbmFwc2hvdDtcbiAgICB0aGlzLl9zZXRUeXBlKG51bGwpO1xuICAgIHRoaXMub25jZSgndW5sb2NrJywgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmVtaXQoJ2RlbCcsIGNvbnRleHQsIG9sZFNuYXBzaG90KTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChvcERhdGEub3ApIHtcbiAgICBpZiAoIXRoaXMudHlwZSkgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCBkb2VzIG5vdCBleGlzdCcpO1xuXG4gICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICB2YXIgb3AgPSBvcERhdGEub3A7XG4gICAgXG4gICAgLy8gVGhlIGNvbnRleHQgbmVlZHMgdG8gYmUgdG9sZCB3ZSdyZSBhYm91dCB0byBlZGl0LCBqdXN0IGluIGNhc2UgaXQgbmVlZHNcbiAgICAvLyB0byBzdG9yZSBhbnkgZXh0cmEgZGF0YS4gKHRleHQtdHAyIGhhcyB0aGlzIGNvbnN0cmFpbnQuKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lZGl0aW5nQ29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gdGhpcy5lZGl0aW5nQ29udGV4dHNbaV07XG4gICAgICBpZiAoYyAhPSBjb250ZXh0ICYmIGMuX2JlZm9yZU9wKSBjLl9iZWZvcmVPcChvcERhdGEub3ApO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnYmVmb3JlIG9wJywgb3AsIGNvbnRleHQpO1xuXG4gICAgLy8gVGhpcyBleGlzdHMgc28gY2xpZW50cyBjYW4gcHVsbCBhbnkgbmVjZXNzYXJ5IGRhdGEgb3V0IG9mIHRoZSBzbmFwc2hvdFxuICAgIC8vIGJlZm9yZSBpdCBnZXRzIGNoYW5nZWQuICBQcmV2aW91c2x5IHdlIGtlcHQgdGhlIG9sZCBzbmFwc2hvdCBvYmplY3QgYW5kXG4gICAgLy8gcGFzc2VkIGl0IHRvIHRoZSBvcCBldmVudCBoYW5kbGVyLiBIb3dldmVyLCBhcHBseSBubyBsb25nZXIgZ3VhcmFudGVlc1xuICAgIC8vIHRoZSBvbGQgb2JqZWN0IGlzIHN0aWxsIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gQmVjYXVzZSB0aGlzIGNvdWxkIGJlIHRvdGFsbHkgdW5uZWNlc3Nhcnkgd29yaywgaXRzIGJlaGluZCBhIGZsYWcuIHNldFxuICAgIC8vIGRvYy5pbmNyZW1lbnRhbCB0byBlbmFibGUuXG4gICAgaWYgKHRoaXMuaW5jcmVtZW50YWwgJiYgdHlwZS5pbmNyZW1lbnRhbEFwcGx5KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdHlwZS5pbmNyZW1lbnRhbEFwcGx5KHRoaXMuc25hcHNob3QsIG9wLCBmdW5jdGlvbihvLCBzbmFwc2hvdCkge1xuICAgICAgICBfdGhpcy5zbmFwc2hvdCA9IHNuYXBzaG90O1xuICAgICAgICBfdGhpcy5lbWl0KCdvcCcsIG8sIGNvbnRleHQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIG1vc3QgY29tbW9uIGNhc2UsIHNpbXBseSBhcHBseWluZyB0aGUgb3BlcmF0aW9uIHRvIHRoZSBsb2NhbCBzbmFwc2hvdC5cbiAgICAgIHRoaXMuc25hcHNob3QgPSB0eXBlLmFwcGx5KHRoaXMuc25hcHNob3QsIG9wKTtcbiAgICAgIHRoaXMuZW1pdCgnb3AnLCBvcCwgY29udGV4dCk7XG4gICAgfVxuICB9XG4gIC8vIEl0cyBwb3NzaWJsZSBmb3Igbm9uZSBvZiB0aGUgYWJvdmUgY2FzZXMgdG8gbWF0Y2gsIGluIHdoaWNoIGNhc2UgdGhlIG9wIGlzXG4gIC8vIGEgbm8tb3AuIFRoaXMgd2lsbCBoYXBwZW4gd2hlbiBhIGRvY3VtZW50IGhhcyBiZWVuIGRlbGV0ZWQgbG9jYWxseSBhbmRcbiAgLy8gcmVtb3RlIG9wcyBlZGl0IHRoZSBkb2N1bWVudC5cbn07XG5cbi8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCByaWdodCBhZnRlciBfb3RBcHBseS5cbkRvYy5wcm90b3R5cGUuX2FmdGVyT3RBcHBseSA9IGZ1bmN0aW9uKG9wRGF0YSwgY29udGV4dCkge1xuICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ3VubG9jaycpO1xuICBpZiAob3BEYXRhLm9wKSB7XG4gICAgdmFyIGNvbnRleHRzID0gdGhpcy5lZGl0aW5nQ29udGV4dHM7XG4gICAgLy8gTm90aWZ5IGFsbCB0aGUgY29udGV4dHMgYWJvdXQgdGhlIG9wICh3ZWxsLCBhbGwgdGhlIGNvbnRleHRzIGV4Y2VwdFxuICAgIC8vIHRoZSBvbmUgd2hpY2ggaW5pdGlhdGVkIHRoZSBzdWJtaXQgaW4gdGhlIGZpcnN0IHBsYWNlKS5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNvbnRleHRzW2ldO1xuICAgICAgaWYgKGMgIT0gY29udGV4dCAmJiBjLl9vbk9wKSBjLl9vbk9wKG9wRGF0YS5vcCk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjb250ZXh0cy5yZW1vdmUpIGNvbnRleHRzLnNwbGljZShpLS0sIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmVtaXQoJ2FmdGVyIG9wJywgb3BEYXRhLm9wLCBjb250ZXh0KTtcbiAgfVxufTtcblxuXG5cbi8vICoqKioqIFNlbmRpbmcgb3BlcmF0aW9uc1xuXG5cbi8vIEFjdHVhbGx5IHNlbmQgb3AgZGF0YSB0byB0aGUgc2VydmVyLlxuRG9jLnByb3RvdHlwZS5fc2VuZE9wRGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgZCA9IHRoaXMuaW5mbGlnaHREYXRhO1xuXG4gIGlmICh0aGlzLmFjdGlvbikgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlICcgKyB0aGlzLmFjdGlvbiArICcgZm9yIHNlbmRPcERhdGEnKTtcbiAgdGhpcy5hY3Rpb24gPSAnc3VibWl0JztcblxuICB2YXIgbXNnID0ge2E6ICdvcCcsIHY6IHRoaXMudmVyc2lvbn07XG4gIGlmIChkLnNyYykge1xuICAgIG1zZy5zcmMgPSBkLnNyYztcbiAgICBtc2cuc2VxID0gZC5zZXE7XG4gIH1cblxuICAvLyBUaGUgc2VydmVyIGF1dG9kZXRlY3RzIHRoaXMuXG4gIC8vaWYgKHRoaXMuc3RhdGUgPT09ICd1bnN1YnNjcmliZWQnKSBtc2cuZiA9IHRydWU7IC8vIGZldGNoIGludGVybWVkaWF0ZSBvcHNcblxuICBpZiAoZC5vcCkgbXNnLm9wID0gZC5vcDtcbiAgaWYgKGQuY3JlYXRlKSBtc2cuY3JlYXRlID0gZC5jcmVhdGU7XG4gIGlmIChkLmRlbCkgbXNnLmRlbCA9IGQuZGVsO1xuXG4gIG1zZy5jID0gdGhpcy5jb2xsZWN0aW9uO1xuICBtc2cuZCA9IHRoaXMubmFtZTtcblxuICB0aGlzLmNvbm5lY3Rpb24uc2VuZE9wKG1zZyk7XG4gICBcbiAgLy8gVGhlIGZpcnN0IHRpbWUgd2Ugc2VuZCBhbiBvcCwgaXRzIGlkIGFuZCBzZXF1ZW5jZSBudW1iZXIgaXMgaW1wbGljaXQuXG4gIGlmICghZC5zcmMpIHtcbiAgICBkLnNyYyA9IHRoaXMuY29ubmVjdGlvbi5pZDtcbiAgICBkLnNlcSA9IHRoaXMuY29ubmVjdGlvbi5zZXErKztcbiAgfVxufTtcblxuXG4vLyBJbnRlcm5hbCBtZXRob2QgY2FsbGVkIHRvIGRvIHRoZSBhY3R1YWwgd29yayBmb3Igc3VibWl0T3AoKSwgY3JlYXRlKCkgYW5kIGRlbCgpLlxuLy9cbi8vIGNvbnRleHQgaXMgb3B0aW9uYWwuXG5Eb2MucHJvdG90eXBlLl9zdWJtaXRPcERhdGEgPSBmdW5jdGlvbihvcERhdGEsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIC8vY29uc29sZS5sb2coJ3N1Ym1pdCcsIEpTT04uc3RyaW5naWZ5KG9wRGF0YSksICd2PScsIHRoaXMudmVyc2lvbik7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBjb250ZXh0O1xuICAgIGNvbnRleHQgPSB0cnVlOyAvLyBUaGUgZGVmYXVsdCBjb250ZXh0IGlzIHRydWUuXG4gIH1cbiAgaWYgKGNvbnRleHQgPT0gbnVsbCkgY29udGV4dCA9IHRydWU7XG5cbiAgdmFyIGVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhlcnIpO1xuICAgIGVsc2UgaWYgKGNvbnNvbGUpIGNvbnNvbGUud2FybignRmFpbGVkIGF0dGVtcHQgdG8gc3VibWl0T3A6JywgZXJyKTtcbiAgfTtcblxuICBpZiAodGhpcy5sb2NrZWQpIHtcbiAgICByZXR1cm4gZXJyb3IoXCJDYW5ub3QgY2FsbCBzdWJtaXRPcCBmcm9tIGluc2lkZSBhbiAnb3AnIGV2ZW50IGhhbmRsZXJcIik7XG4gIH1cblxuICAvLyBUaGUgb3BEYXRhIGNvbnRhaW5zIGVpdGhlciBvcCwgY3JlYXRlLCBkZWxldGUsIG9yIG5vbmUgb2YgdGhlIGFib3ZlIChhIG5vLW9wKS5cblxuICBpZiAob3BEYXRhLm9wKSB7XG4gICAgaWYgKCF0aGlzLnR5cGUpIHJldHVybiBlcnJvcignRG9jdW1lbnQgaGFzIG5vdCBiZWVuIGNyZWF0ZWQnKTtcblxuICAgIC8vIFRyeSB0byBub3JtYWxpemUgdGhlIG9wLiBUaGlzIHJlbW92ZXMgdHJhaWxpbmcgc2tpcDowJ3MgYW5kIHRoaW5ncyBsaWtlIHRoYXQuXG4gICAgaWYgKHRoaXMudHlwZS5ub3JtYWxpemUpIG9wRGF0YS5vcCA9IHRoaXMudHlwZS5ub3JtYWxpemUob3BEYXRhLm9wKTtcbiAgfVxuXG4gIGlmICghdGhpcy5zdGF0ZSkge1xuICAgIHRoaXMuc3RhdGUgPSAnZmxvYXRpbmcnO1xuICB9XG5cbiAgLy8gQWN0dWFsbHkgYXBwbHkgdGhlIG9wZXJhdGlvbiBsb2NhbGx5LlxuICB0aGlzLl9vdEFwcGx5KG9wRGF0YSwgY29udGV4dCk7XG5cbiAgLy8gSWYgdGhlIHR5cGUgc3VwcG9ydHMgY29tcG9zZXMsIHRyeSB0byBjb21wb3NlIHRoZSBvcGVyYXRpb24gb250byB0aGUgZW5kXG4gIC8vIG9mIHRoZSBsYXN0IHBlbmRpbmcgb3BlcmF0aW9uLlxuICB2YXIgZW50cnkgPSB0aGlzLnBlbmRpbmdEYXRhW3RoaXMucGVuZGluZ0RhdGEubGVuZ3RoIC0gMV07XG5cbiAgaWYgKHRoaXMucGVuZGluZ0RhdGEubGVuZ3RoICYmXG4gICAgICAoZW50cnkgPSB0aGlzLnBlbmRpbmdEYXRhW3RoaXMucGVuZGluZ0RhdGEubGVuZ3RoIC0gMV0sXG4gICAgICAgdHJ5Q29tcG9zZSh0aGlzLnR5cGUsIGVudHJ5LCBvcERhdGEpKSkge1xuICB9IGVsc2Uge1xuICAgIGVudHJ5ID0gb3BEYXRhO1xuICAgIG9wRGF0YS50eXBlID0gdGhpcy50eXBlO1xuICAgIG9wRGF0YS5jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdEYXRhLnB1c2gob3BEYXRhKTtcbiAgfVxuXG4gIGlmIChjYWxsYmFjaykgZW50cnkuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXG4gIHRoaXMuX2FmdGVyT3RBcHBseShvcERhdGEsIGNvbnRleHQpO1xuXG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkgeyBfdGhpcy5mbHVzaCgpOyB9KSwgMCk7XG59O1xuXG5cbi8vICoqKiBDbGllbnQgT1QgZW50cnlwb2ludHMuXG5cbi8vIFN1Ym1pdCBhbiBvcGVyYXRpb24gdG8gdGhlIGRvY3VtZW50LiBUaGUgb3AgbXVzdCBiZSB2YWxpZCBnaXZlbiB0aGUgY3VycmVudCBPVCB0eXBlLlxuRG9jLnByb3RvdHlwZS5zdWJtaXRPcCA9IGZ1bmN0aW9uKG9wLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICB0aGlzLl9zdWJtaXRPcERhdGEoe29wOiBvcH0sIGNvbnRleHQsIGNhbGxiYWNrKTtcbn07XG5cbi8vIENyZWF0ZSB0aGUgZG9jdW1lbnQsIHdoaWNoIGluIFNoYXJlSlMgc2VtYW50aWNzIG1lYW5zIHRvIHNldCBpdHMgdHlwZS4gRXZlcnlcbi8vIG9iamVjdCBpbXBsaWNpdGx5IGV4aXN0cyBpbiB0aGUgZGF0YWJhc2UgYnV0IGhhcyBubyBkYXRhIGFuZCBubyB0eXBlLiBDcmVhdGVcbi8vIHNldHMgdGhlIHR5cGUgb2YgdGhlIG9iamVjdCBhbmQgY2FuIG9wdGlvbmFsbHkgc2V0IHNvbWUgaW5pdGlhbCBkYXRhIG9uIHRoZVxuLy8gb2JqZWN0LCBkZXBlbmRpbmcgb24gdGhlIHR5cGUuXG5Eb2MucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFNldHRpbmcgdGhlIGNvbnRleHQgdG8gYmUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGluIHRoaXMgY2FzZSBzbyBfc3VibWl0T3BEYXRhXG4gICAgLy8gY2FuIGhhbmRsZSB0aGUgZGVmYXVsdCB2YWx1ZSB0aGluZy5cbiAgICBjb250ZXh0ID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmICh0aGlzLnR5cGUpIHtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCdEb2N1bWVudCBhbHJlYWR5IGV4aXN0cycpO1xuICAgIHJldHVybiBcbiAgfVxuXG4gIHRoaXMuX3N1Ym1pdE9wRGF0YSh7Y3JlYXRlOiB7dHlwZTp0eXBlLCBkYXRhOmRhdGF9fSwgY29udGV4dCwgY2FsbGJhY2spO1xufTtcblxuLy8gRGVsZXRlIHRoZSBkb2N1bWVudC4gVGhpcyBjcmVhdGVzIGFuZCBzdWJtaXRzIGEgZGVsZXRlIG9wZXJhdGlvbiB0byB0aGVcbi8vIHNlcnZlci4gRGVsZXRpbmcgcmVzZXRzIHRoZSBvYmplY3QncyB0eXBlIHRvIG51bGwgYW5kIGRlbGV0ZXMgaXRzIGRhdGEuIFRoZVxuLy8gZG9jdW1lbnQgc3RpbGwgZXhpc3RzLCBhbmQgc3RpbGwgaGFzIHRoZSB2ZXJzaW9uIGl0IHVzZWQgdG8gaGF2ZSBiZWZvcmUgeW91XG4vLyBkZWxldGVkIGl0ICh3ZWxsLCBvbGQgdmVyc2lvbiArMSkuXG5Eb2MucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gIGlmICghdGhpcy50eXBlKSB7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygnRG9jdW1lbnQgZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9zdWJtaXRPcERhdGEoe2RlbDogdHJ1ZX0sIGNvbnRleHQsIGNhbGxiYWNrKTtcbn07XG5cblxuLy8gUGF1c2luZyBzdG9wcyB0aGUgZG9jdW1lbnQgZnJvbSBzZW5kaW5nIGFueSBvcGVyYXRpb25zIHRvIHRoZSBzZXJ2ZXIuXG5Eb2MucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTtcbn07XG5cbkRvYy5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGF1c2VkID0gZmFsc2U7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cblxuLy8gKioqIFJlY2VpdmluZyBvcGVyYXRpb25zXG5cblxuLy8gVGhpcyB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgcmVqZWN0cyBvdXIgb3BlcmF0aW9ucyBmb3Igc29tZSByZWFzb24uXG4vLyBUaGVyZSdzIG5vdCBtdWNoIHdlIGNhbiBkbyBoZXJlIGlmIHRoZSBPVCB0eXBlIGlzIG5vbmludmVydGFibGUsIGJ1dCB0aGF0XG4vLyBzaG91bGRuJ3QgaGFwcGVuIHRvbyBtdWNoIGluIHJlYWwgbGlmZSBiZWNhdXNlIHJlYWRvbmx5IGRvY3VtZW50cyBzaG91bGQgYmVcbi8vIGZsYWdnZWQgYXMgc3VjaC4gKEkgc2hvdWxkIHByb2JhYmx5IGZpZ3VyZSBvdXQgYSBmbGFnIGZvciB0aGF0KS5cbi8vXG4vLyBUaGlzIGRvZXMgTk9UIGdldCBjYWxsZWQgaWYgb3VyIG9wIGZhaWxzIHRvIHJlYWNoIHRoZSBzZXJ2ZXIgZm9yIHNvbWUgcmVhc29uXG4vLyAtIHdlIG9wdGltaXN0aWNhbGx5IGFzc3VtZSBpdCdsbCBtYWtlIGl0IHRoZXJlIGV2ZW50dWFsbHkuXG5Eb2MucHJvdG90eXBlLl90cnlSb2xsYmFjayA9IGZ1bmN0aW9uKG9wRGF0YSkge1xuICAvLyBUaGlzIGlzIHByb2JhYmx5IGhvcnJpYmx5IGJyb2tlbi5cbiAgaWYgKG9wRGF0YS5jcmVhdGUpIHtcbiAgICB0aGlzLl9zZXRUeXBlKG51bGwpO1xuXG4gICAgLy8gSSBkb24ndCB0aGluayBpdHMgcG9zc2libGUgdG8gZ2V0IGhlcmUgaWYgd2UgYXJlbid0IGluIGEgZmxvYXRpbmcgc3RhdGUuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09ICdmbG9hdGluZycpXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICBlbHNlXG4gICAgICBjb25zb2xlLndhcm4oJ1JvbGxiYWNrIGEgY3JlYXRlIGZyb20gc3RhdGUgJyArIHRoaXMuc3RhdGUpO1xuXG4gIH0gZWxzZSBpZiAob3BEYXRhLm9wICYmIG9wRGF0YS50eXBlLmludmVydCkge1xuICAgIHZhciB1bmRvID0gb3BEYXRhLnR5cGUuaW52ZXJ0KG9wRGF0YS5vcCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIHVuZG8gb3BlcmF0aW9uIGJ5IGFueSBwZW5kaW5nIG9wcy5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHhmKHRoaXMucGVuZGluZ0RhdGFbaV0sIHVuZG8pO1xuICAgIH1cblxuICAgIC8vIC4uLiBhbmQgYXBwbHkgaXQgbG9jYWxseSwgcmV2ZXJ0aW5nIHRoZSBjaGFuZ2VzLlxuICAgIC8vIFxuICAgIC8vIFRoaXMgb3BlcmF0aW9uIGlzIGFwcGxpZWQgdG8gbG9vayBsaWtlIGl0IGNvbWVzIGZyb20gYSByZW1vdGUgY29udGV4dC5cbiAgICAvLyBJJ20gc3RpbGwgbm90IDEwMCUgc3VyZSBhYm91dCB0aGlzIGZ1bmN0aW9uYWxpdHksIGJlY2F1c2UgaXRzIHJlYWxseSBhXG4gICAgLy8gbG9jYWwgb3AuIEJhc2ljYWxseSwgdGhlIHByb2JsZW0gaXMgdGhhdCBpZiB0aGUgY2xpZW50J3Mgb3AgaXMgcmVqZWN0ZWRcbiAgICAvLyBieSB0aGUgc2VydmVyLCB0aGUgZWRpdG9yIHdpbmRvdyBzaG91bGQgdXBkYXRlIHRvIHJlZmxlY3QgdGhlIHVuZG8uXG4gICAgdGhpcy5fb3RBcHBseSh1bmRvLCBmYWxzZSk7XG4gICAgdGhpcy5fYWZ0ZXJPdEFwcGx5KHVuZG8sIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChvcERhdGEub3AgfHwgb3BEYXRhLmRlbCkge1xuICAgIC8vIFRoaXMgaXMgd2hlcmUgYW4gdW5kbyBzdGFjayB3b3VsZCBjb21lIGluIGhhbmR5LlxuICAgIHRoaXMuX3NldFR5cGUobnVsbCk7XG4gICAgdGhpcy52ZXJzaW9uID0gbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgXCJPcCBhcHBseSBmYWlsZWQgYW5kIHRoZSBvcGVyYXRpb24gY291bGQgbm90IGJlIHJldmVydGVkXCIpO1xuXG4gICAgLy8gVHJpZ2dlciBhIGZldGNoLiBJbiBvdXIgaW52YWxpZCBzdGF0ZSwgd2UgY2FuJ3QgcmVhbGx5IGRvIGFueXRoaW5nLlxuICAgIHRoaXMuZmV0Y2goKTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbkRvYy5wcm90b3R5cGUuX2NsZWFySW5mbGlnaHRPcCA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLmluZmxpZ2h0RGF0YS5jYWxsYmFja3M7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2FsbGJhY2tzW2ldKGVycm9yIHx8IHRoaXMuaW5mbGlnaHREYXRhLmVycm9yKTtcbiAgfVxuXG4gIHRoaXMuaW5mbGlnaHREYXRhID0gbnVsbDtcbiAgdGhpcy5fY2xlYXJBY3Rpb24oJ3N1Ym1pdCcpO1xuXG4gIGlmICghdGhpcy5wZW5kaW5nRGF0YS5sZW5ndGgpIHtcbiAgICAvLyBUaGlzIGlzbid0IGEgdmVyeSBnb29kIG5hbWUuXG4gICAgdGhpcy5lbWl0KCdub3RoaW5nIHBlbmRpbmcnKTtcbiAgfVxufTtcblxuLy8gVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc2VydmVyIGFja25vd2xlZGdlcyBhbiBvcGVyYXRpb24gZnJvbSB0aGUgY2xpZW50LlxuRG9jLnByb3RvdHlwZS5fb3BBY2tub3dsZWRnZWQgPSBmdW5jdGlvbihtc2cpIHtcbiAgLy8gT3VyIGluZmxpZ2h0IG9wIGhhcyBiZWVuIGFja25vd2xlZGdlZCwgc28gd2UgY2FuIHRocm93IGF3YXkgdGhlIGluZmxpZ2h0IGRhdGEuXG4gIC8vIChXZSB3ZXJlIG9ubHkgaG9sZGluZyBvbiB0byBpdCBpbmNhc2Ugd2UgbmVlZGVkIHRvIHJlc2VuZCB0aGUgb3AuKVxuICBpZiAoIXRoaXMuc3RhdGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ29wQWNrbm93bGVkZ2VkIGNhbGxlZCBmcm9tIGEgbnVsbCBzdGF0ZS4gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLicpO1xuICB9IGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdmbG9hdGluZycpIHtcbiAgICBpZiAoIXRoaXMuaW5mbGlnaHREYXRhLmNyZWF0ZSkgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYWNrbm93bGVkZ2UgYW4gb3AuJyk7XG5cbiAgICAvLyBPdXIgY3JlYXRlIGhhcyBiZWVuIGFja25vd2xlZGdlZC4gVGhpcyBpcyB0aGUgc2FtZSBhcyBpbmplc3Rpbmcgc29tZSBkYXRhLlxuICAgIHRoaXMudmVyc2lvbiA9IG1zZy52O1xuICAgIHRoaXMuc3RhdGUgPSAncmVhZHknO1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgX3RoaXMuZW1pdCgncmVhZHknKTsgfSwgMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGEgc25hcHNob3QuIFRoZSBzbmFwc2hvdCBzaG91bGQgYmUgYXQgdGhlIGFja25vd2xlZGdlZFxuICAgIC8vIHZlcnNpb24sIGJlY2F1c2UgdGhlIHNlcnZlciBoYXMgc2VudCB1cyBhbGwgdGhlIG9wcyB0aGF0IGhhdmUgaGFwcGVuZWRcbiAgICAvLyBiZWZvcmUgYWNrbm93bGVkZ2luZyBvdXIgb3AuXG5cbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4gLSBzb21ldGhpbmcgaXMgb3V0IG9mIG9yZGVyLlxuICAgIGlmIChtc2cudiAhPT0gdGhpcy52ZXJzaW9uKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnNpb24gZnJvbSBzZXJ2ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLCB0aGlzIGlzIGEgYnVnLicpO1xuICB9XG4gIFxuICAvLyBUaGUgb3Agd2FzIGNvbW1pdHRlZCBzdWNjZXNzZnVsbHkuIEluY3JlbWVudCB0aGUgdmVyc2lvbiBudW1iZXJcbiAgdGhpcy52ZXJzaW9uKys7XG5cbiAgdGhpcy5fY2xlYXJJbmZsaWdodE9wKCk7XG59O1xuXG5cbi8vIEFQSSBDb250ZXh0c1xuXG4vLyBUaGlzIGNyZWF0ZXMgYW5kIHJldHVybnMgYW4gZWRpdGluZyBjb250ZXh0IHVzaW5nIHRoZSBjdXJyZW50IE9UIHR5cGUuXG5Eb2MucHJvdG90eXBlLmNyZWF0ZUNvbnRleHQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG4gIGlmICghdHlwZSkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHR5cGUnKTtcblxuICAvLyBJIGNvdWxkIHVzZSB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGRvIHRoaXMgaW5zdGVhZCwgYnV0IE9iamVjdC5jcmVhdGVcbiAgLy8gaXNuJ3QgZGVmaW5lZCBvbiBvbGQgYnJvd3NlcnMuIFRoaXMgd2lsbCBiZSBmaW5lLlxuICB2YXIgZG9jID0gdGhpcztcbiAgdmFyIGNvbnRleHQgPSB7XG4gICAgZ2V0U25hcHNob3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRvYy5zbmFwc2hvdDtcbiAgICB9LFxuICAgIHN1Ym1pdE9wOiBmdW5jdGlvbihvcCwgY2FsbGJhY2spIHtcbiAgICAgIGRvYy5zdWJtaXRPcChvcCwgY29udGV4dCwgY2FsbGJhY2spO1xuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5kZXRhY2gpIHtcbiAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgICAgLy8gRG9uJ3QgZG91YmxlLWRldGFjaC5cbiAgICAgICAgZGVsZXRlIHRoaXMuZGV0YWNoO1xuICAgICAgfVxuICAgICAgLy8gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGFjdHVhbCBlZGl0aW5nQ29udGV4dHMgbGlzdCBuZXh0IHRpbWVcbiAgICAgIC8vIHdlIHJlY2VpdmUgYW4gb3Agb24gdGhlIGRvY3VtZW50IChhbmQgdGhlIGxpc3QgaXMgaXRlcmF0ZWQgdGhyb3VnaCkuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBpcyBwb3RlbnRpYWxseSBkb2RneSwgYWxsb3dpbmcgYSBtZW1vcnkgbGVhayBpZiB5b3UgY3JlYXRlICZcbiAgICAgIC8vIGRlc3Ryb3kgYSB3aG9sZSBidW5jaCBvZiBjb250ZXh0cyB3aXRob3V0IHJlY2VpdmluZyBvciBzZW5kaW5nIGFueSBvcHNcbiAgICAgIC8vIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9vbk9wO1xuICAgICAgdGhpcy5yZW1vdmUgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvLyBUaGlzIGlzIGRhbmdlcm91cywgYnV0IHJlYWxseSByZWFsbHkgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuIEkgaG9wZSBwZW9wbGVcbiAgICAvLyBkb24ndCBkZXBlbmQgb24gaXQuXG4gICAgX2RvYzogdGhpcyxcbiAgfTtcblxuICBpZiAodHlwZS5hcGkpIHtcbiAgICAvLyBDb3B5IGV2ZXJ5dGhpbmcgZWxzZSBmcm9tIHRoZSB0eXBlJ3MgQVBJIGludG8gdGhlIGVkaXRpbmcgY29udGV4dC5cbiAgICBmb3IgKHZhciBrIGluIHR5cGUuYXBpKSB7XG4gICAgICBjb250ZXh0W2tdID0gdHlwZS5hcGlba107XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHQucHJvdmlkZXMgPSB7fTtcbiAgfVxuXG4gIHRoaXMuZWRpdGluZ0NvbnRleHRzLnB1c2goY29udGV4dCk7XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59O1xuXG5Eb2MucHJvdG90eXBlLnJlbW92ZUNvbnRleHRzID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lZGl0aW5nQ29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLmVkaXRpbmdDb250ZXh0c1tpXS5kZXN0cm95KCk7XG4gIH1cbiAgdGhpcy5lZGl0aW5nQ29udGV4dHMubGVuZ3RoID0gMDtcbn07XG5cbiIsIlxudmFyIHJlZ2lzdGVyID0gZnVuY3Rpb24odHlwZSkge1xuICBleHBvcnRzW3R5cGUubmFtZV0gPSB0eXBlO1xuICBpZiAodHlwZS51cmkpIHtcbiAgICByZXR1cm4gZXhwb3J0c1t0eXBlLnVyaV0gPSB0eXBlO1xuICB9XG59O1xuXG4vLyBJbXBvcnQgYWxsIHRoZSBidWlsdC1pbiB0eXBlcy4gUmVxdWlyaW5nIGRpcmVjdGx5IHJhdGhlciB0aGFuIGluIHJlZ2lzdGVyKClcbi8vIHNvIGJyb3dzZXJpZnkgd29ya3MuXG5yZWdpc3RlcihyZXF1aXJlKCcuL3NpbXBsZScpKTtcblxucmVnaXN0ZXIocmVxdWlyZSgnLi90ZXh0JykpO1xucmVnaXN0ZXIocmVxdWlyZSgnLi90ZXh0LXRwMicpKTtcblxucmVnaXN0ZXIocmVxdWlyZSgnLi9qc29uMCcpKTtcblxuIiwiLyogVGV4dCBPVCFcbiAqXG4gKiBUaGlzIGlzIGFuIE9UIGltcGxlbWVudGF0aW9uIGZvciB0ZXh0LiBJdCBpcyB0aGUgc3RhbmRhcmQgaW1wbGVtZW50YXRpb24gb2ZcbiAqIHRleHQgdXNlZCBieSBTaGFyZUpTLlxuICpcbiAqIFRoaXMgdHlwZSBpcyBjb21wb3NhYmxlIGJ1dCBub24taW52ZXJ0YWJsZS4gSXRzIHNpbWlsYXIgdG8gU2hhcmVKUydzIG9sZFxuICogdGV4dC1jb21wb3NhYmxlIHR5cGUsIGJ1dCBpdHMgbm90IGludmVydGFibGUgYW5kIGl0cyB2ZXJ5IHNpbWlsYXIgdG8gdGhlXG4gKiB0ZXh0LXRwMiBpbXBsZW1lbnRhdGlvbiBidXQgaXQgZG9lc24ndCBzdXBwb3J0IHRvbWJzdG9uZXMgb3IgcHVyZ2luZy5cbiAqXG4gKiBPcHMgYXJlIGxpc3RzIG9mIGNvbXBvbmVudHMgd2hpY2ggaXRlcmF0ZSBvdmVyIHRoZSBkb2N1bWVudC5cbiAqIENvbXBvbmVudHMgYXJlIGVpdGhlcjpcbiAqICAgQSBudW1iZXIgTjogU2tpcCBOIGNoYXJhY3RlcnMgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50XG4gKiAgIFwic3RyXCIgICAgIDogSW5zZXJ0IFwic3RyXCIgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50XG4gKiAgIHtkOidzdHInfSA6IERlbGV0ZSAnc3RyJywgd2hpY2ggYXBwZWFycyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnRcbiAqXG4gKiBFZzogWzMsICdoaScsIDUsIHtkOjh9XVxuICpcbiAqIFRoZSBvcGVyYXRpb24gZG9lcyBub3QgaGF2ZSB0byBza2lwIHRoZSBsYXN0IGNoYXJhY3RlcnMgaW4gdGhlIGRvY3VtZW50LlxuICpcbiAqIFNuYXBzaG90cyBhcmUgc3RyaW5ncy5cbiAqXG4gKiBDdXJzb3JzIGFyZSBlaXRoZXIgYSBzaW5nbGUgbnVtYmVyICh3aGljaCBpcyB0aGUgY3Vyc29yIHBvc2l0aW9uKSBvciBhIHBhaXIgb2ZcbiAqIFthbmNob3IsIGZvY3VzXSAoYWthIFtzdGFydCwgZW5kXSkuIEJlIGF3YXJlIHRoYXQgZW5kIGNhbiBiZSBiZWZvcmUgc3RhcnQuXG4gKi9cblxuLyoqIEBtb2R1bGUgdGV4dCAqL1xuXG5leHBvcnRzLm5hbWUgPSAndGV4dCc7XG5leHBvcnRzLnVyaSA9ICdodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvdGV4dHYxJztcblxuLyoqIENyZWF0ZSBhIG5ldyB0ZXh0IHNuYXBzaG90LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbml0aWFsIC0gaW5pdGlhbCBzbmFwc2hvdCBkYXRhLiBPcHRpb25hbC4gRGVmYXVsdHMgdG8gJycuXG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oaW5pdGlhbCkge1xuICBpZiAoKGluaXRpYWwgIT0gbnVsbCkgJiYgdHlwZW9mIGluaXRpYWwgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbml0aWFsIGRhdGEgbXVzdCBiZSBhIHN0cmluZycpO1xuICB9XG4gIHJldHVybiBpbml0aWFsIHx8ICcnO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbn07XG5cbi8qKiBDaGVjayB0aGUgb3BlcmF0aW9uIGlzIHZhbGlkLiBUaHJvd3MgaWYgbm90IHZhbGlkLiAqL1xudmFyIGNoZWNrT3AgPSBmdW5jdGlvbihvcCkge1xuICBpZiAoIWlzQXJyYXkob3ApKSB0aHJvdyBuZXcgRXJyb3IoJ09wIG11c3QgYmUgYW4gYXJyYXkgb2YgY29tcG9uZW50cycpO1xuXG4gIHZhciBsYXN0ID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG4gICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgLy8gVGhlIG9ubHkgdmFsaWQgb2JqZWN0cyBhcmUge2Q6WH0gZm9yICtpdmUgdmFsdWVzIG9mIFguXG4gICAgICAgIGlmICghKHR5cGVvZiBjLmQgPT09ICdudW1iZXInICYmIGMuZCA+IDApKSB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdCBjb21wb25lbnRzIG11c3QgYmUgZGVsZXRlcyBvZiBzaXplID4gMCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIC8vIFN0cmluZ3MgYXJlIGluc2VydHMuXG4gICAgICAgIGlmICghKGMubGVuZ3RoID4gMCkpIHRocm93IG5ldyBFcnJvcignSW5zZXJ0cyBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAvLyBOdW1iZXJzIG11c3QgYmUgc2tpcHMuIFRoZXkgaGF2ZSB0byBiZSAraXZlIG51bWJlcnMuXG4gICAgICAgIGlmICghKGMgPiAwKSkgdGhyb3cgbmV3IEVycm9yKCdTa2lwIGNvbXBvbmVudHMgbXVzdCBiZSA+MCcpO1xuICAgICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ0FkamFjZW50IHNraXAgY29tcG9uZW50cyBzaG91bGQgYmUgY29tYmluZWQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxhc3QgPSBjO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBsYXN0ID09PSAnbnVtYmVyJykgdGhyb3cgbmV3IEVycm9yKCdPcCBoYXMgYSB0cmFpbGluZyBza2lwJyk7XG59O1xuXG4vKiogTWFrZSBhIGZ1bmN0aW9uIHRoYXQgYXBwZW5kcyB0byB0aGUgZ2l2ZW4gb3BlcmF0aW9uLiAqL1xudmFyIG1ha2VBcHBlbmQgPSBmdW5jdGlvbihvcCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgY29tcG9uZW50LmQgPT09IDApIHtcbiAgICAgIC8vIFRoZSBjb21wb25lbnQgaXMgYSBuby1vcC4gSWdub3JlIVxuIFxuICAgIH0gZWxzZSBpZiAob3AubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gb3AucHVzaChjb21wb25lbnQpO1xuXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSB0eXBlb2Ygb3Bbb3AubGVuZ3RoIC0gMV0pIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gb3Bbb3AubGVuZ3RoIC0gMV0uZCArPSBjb21wb25lbnQuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcFtvcC5sZW5ndGggLSAxXSArPSBjb21wb25lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvcC5wdXNoKGNvbXBvbmVudCk7XG4gICAgfVxuICB9O1xufTtcblxuLyoqIE1ha2VzIGFuZCByZXR1cm5zIHV0aWxpdHkgZnVuY3Rpb25zIHRha2UgYW5kIHBlZWsuICovXG52YXIgbWFrZVRha2UgPSBmdW5jdGlvbihvcCkge1xuICAvLyBUaGUgaW5kZXggb2YgdGhlIG5leHQgY29tcG9uZW50IHRvIHRha2VcbiAgdmFyIGlkeCA9IDA7XG4gIC8vIFRoZSBvZmZzZXQgaW50byB0aGUgY29tcG9uZW50XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIC8vIFRha2UgdXAgdG8gbGVuZ3RoIG4gZnJvbSB0aGUgZnJvbnQgb2Ygb3AuIElmIG4gaXMgLTEsIHRha2UgdGhlIGVudGlyZSBuZXh0XG4gIC8vIG9wIGNvbXBvbmVudC4gSWYgaW5kaXZpc2FibGVGaWVsZCA9PSAnZCcsIGRlbGV0ZSBjb21wb25lbnRzIHdvbid0IGJlIHNlcGFyYXRlZC5cbiAgLy8gSWYgaW5kaXZpc2FibGVGaWVsZCA9PSAnaScsIGluc2VydCBjb21wb25lbnRzIHdvbid0IGJlIHNlcGFyYXRlZC5cbiAgdmFyIHRha2UgPSBmdW5jdGlvbihuLCBpbmRpdmlzYWJsZUZpZWxkKSB7XG4gICAgLy8gV2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uLiBUaGUgb3AgaGFzIHNraXBzLCBmb3JldmVyLiBJbmZpbml0eVxuICAgIC8vIG1pZ2h0IG1ha2UgbW9yZSBzZW5zZSB0aGFuIG51bGwgaGVyZS5cbiAgICBpZiAoaWR4ID09PSBvcC5sZW5ndGgpXG4gICAgICByZXR1cm4gbiA9PT0gLTEgPyBudWxsIDogbjtcblxuICAgIHZhciBwYXJ0O1xuICAgIHZhciBjID0gb3BbaWR4XTtcbiAgICBpZiAodHlwZW9mIGMgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBTa2lwXG4gICAgICBpZiAobiA9PT0gLTEgfHwgYyAtIG9mZnNldCA8PSBuKSB7XG4gICAgICAgIHBhcnQgPSBjIC0gb2Zmc2V0O1xuICAgICAgICArK2lkeDtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgcmV0dXJuIHBhcnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gbjtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgaWYgKG4gPT09IC0xIHx8IGluZGl2aXNhYmxlRmllbGQgPT09ICdpJyB8fCBjLmxlbmd0aCAtIG9mZnNldCA8PSBuKSB7XG4gICAgICAgIHBhcnQgPSBjLnNsaWNlKG9mZnNldCk7XG4gICAgICAgICsraWR4O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnQgPSBjLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbik7XG4gICAgICAgIG9mZnNldCArPSBuO1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVsZXRlXG4gICAgICBpZiAobiA9PT0gLTEgfHwgaW5kaXZpc2FibGVGaWVsZCA9PT0gJ2QnIHx8IGMuZCAtIG9mZnNldCA8PSBuKSB7XG4gICAgICAgIHBhcnQgPSB7ZDogYy5kIC0gb2Zmc2V0fTtcbiAgICAgICAgKytpZHg7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ICs9IG47XG4gICAgICAgIHJldHVybiB7ZDogbn07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFBlZWsgYXQgdGhlIG5leHQgb3AgdGhhdCB3aWxsIGJlIHJldHVybmVkLlxuICB2YXIgcGVla1R5cGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG9wW2lkeF07IH07XG5cbiAgcmV0dXJuIFt0YWtlLCBwZWVrVHlwZV07XG59O1xuXG4vKiogR2V0IHRoZSBsZW5ndGggb2YgYSBjb21wb25lbnQgKi9cbnZhciBjb21wb25lbnRMZW5ndGggPSBmdW5jdGlvbihjKSB7XG4gIC8vIFVnbGlmeSB3aWxsIGNvbXByZXNzIHRoaXMgZG93biBpbnRvIGEgdGVybmFyeVxuICBpZiAodHlwZW9mIGMgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGMubGVuZ3RoIHx8IGMuZDtcbiAgfVxufTtcblxuLyoqIFRyaW0gYW55IGV4Y2VzcyBza2lwcyBmcm9tIHRoZSBlbmQgb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIFRoZXJlIHNob3VsZCBvbmx5IGJlIGF0IG1vc3Qgb25lLCBiZWNhdXNlIHRoZSBvcGVyYXRpb24gd2FzIG1hZGUgd2l0aCBhcHBlbmQuXG4gKi9cbnZhciB0cmltID0gZnVuY3Rpb24ob3ApIHtcbiAgaWYgKG9wLmxlbmd0aCA+IDAgJiYgdHlwZW9mIG9wW29wLmxlbmd0aCAtIDFdID09PSAnbnVtYmVyJykge1xuICAgIG9wLnBvcCgpO1xuICB9XG4gIHJldHVybiBvcDtcbn07XG5cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIG5ld09wID0gW107XG4gIHZhciBhcHBlbmQgPSBtYWtlQXBwZW5kKG5ld09wKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIGFwcGVuZChvcFtpXSk7XG4gIH1cbiAgcmV0dXJuIHRyaW0obmV3T3ApO1xufTtcblxuLyoqIEFwcGx5IGFuIG9wZXJhdGlvbiB0byBhIGRvY3VtZW50IHNuYXBzaG90ICovXG5leHBvcnRzLmFwcGx5ID0gZnVuY3Rpb24oc3RyLCBvcCkge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NuYXBzaG90IHNob3VsZCBiZSBhIHN0cmluZycpO1xuICB9XG4gIGNoZWNrT3Aob3ApO1xuXG4gIC8vIFdlJ2xsIGdhdGhlciB0aGUgbmV3IGRvY3VtZW50IGhlcmUgYW5kIGpvaW4gYXQgdGhlIGVuZC5cbiAgdmFyIG5ld0RvYyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gb3BbaV07XG4gICAgc3dpdGNoICh0eXBlb2YgY29tcG9uZW50KSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpZiAoY29tcG9uZW50ID4gc3RyLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgb3AgaXMgdG9vIGxvbmcgZm9yIHRoaXMgZG9jdW1lbnQnKTtcblxuICAgICAgICBuZXdEb2MucHVzaChzdHIuc2xpY2UoMCwgY29tcG9uZW50KSk7XG4gICAgICAgIC8vIFRoaXMgbWlnaHQgYmUgc2xvdyBmb3IgYmlnIHN0cmluZ3MuIENvbnNpZGVyIHN0b3JpbmcgdGhlIG9mZnNldCBpblxuICAgICAgICAvLyBzdHIgaW5zdGVhZCBvZiByZXdyaXRpbmcgaXQgZWFjaCB0aW1lLlxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoY29tcG9uZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBuZXdEb2MucHVzaChjb21wb25lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShjb21wb25lbnQuZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdEb2Muam9pbignJykgKyBzdHI7XG59O1xuXG4vKiogVHJhbnNmb3JtIG9wIGJ5IG90aGVyT3AuXG4gKlxuICogQHBhcmFtIG9wIC0gVGhlIG9wZXJhdGlvbiB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSBvdGhlck9wIC0gT3BlcmF0aW9uIHRvIHRyYW5zZm9ybSBpdCBieVxuICogQHBhcmFtIHNpZGUgLSBFaXRoZXIgJ2xlZnQnIG9yICdyaWdodCdcbiAqL1xuZXhwb3J0cy50cmFuc2Zvcm0gPSBmdW5jdGlvbihvcCwgb3RoZXJPcCwgc2lkZSkge1xuICBpZiAoc2lkZSAhPSAnbGVmdCcgJiYgc2lkZSAhPSAncmlnaHQnKSB0aHJvdyBuZXcgRXJyb3IoXCJzaWRlIChcIiArIHNpZGUgKyBcIikgbXVzdCBiZSAnbGVmdCcgb3IgJ3JpZ2h0J1wiKTtcblxuICBjaGVja09wKG9wKTtcbiAgY2hlY2tPcChvdGhlck9wKTtcblxuICB2YXIgbmV3T3AgPSBbXTtcbiAgdmFyIGFwcGVuZCA9IG1ha2VBcHBlbmQobmV3T3ApO1xuXG4gIHZhciBfZm5zID0gbWFrZVRha2Uob3ApO1xuICB2YXIgdGFrZSA9IF9mbnNbMF0sXG4gICAgICBwZWVrID0gX2Zuc1sxXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyT3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gb3RoZXJPcFtpXTtcblxuICAgIHZhciBsZW5ndGgsIGNodW5rO1xuICAgIHN3aXRjaCAodHlwZW9mIGNvbXBvbmVudCkge1xuICAgICAgY2FzZSAnbnVtYmVyJzogLy8gU2tpcFxuICAgICAgICBsZW5ndGggPSBjb21wb25lbnQ7XG4gICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2h1bmsgPSB0YWtlKGxlbmd0aCwgJ2knKTtcbiAgICAgICAgICBhcHBlbmQoY2h1bmspO1xuICAgICAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBsZW5ndGggLT0gY29tcG9uZW50TGVuZ3RoKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3N0cmluZyc6IC8vIEluc2VydFxuICAgICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgLy8gVGhlIGxlZnQgaW5zZXJ0IHNob3VsZCBnbyBmaXJzdC5cbiAgICAgICAgICBpZiAodHlwZW9mIHBlZWsoKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFwcGVuZCh0YWtlKC0xKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHNraXAgdGhlIGluc2VydGVkIHRleHQuXG4gICAgICAgIGFwcGVuZChjb21wb25lbnQubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ29iamVjdCc6IC8vIERlbGV0ZVxuICAgICAgICBsZW5ndGggPSBjb21wb25lbnQuZDtcbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjaHVuayA9IHRha2UobGVuZ3RoLCAnaScpO1xuICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGNodW5rKSB7XG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICBsZW5ndGggLT0gY2h1bms7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgYXBwZW5kKGNodW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgICAvLyBUaGUgZGVsZXRlIGlzIHVubmVjZXNzYXJ5IG5vdyAtIHRoZSB0ZXh0IGhhcyBhbHJlYWR5IGJlZW4gZGVsZXRlZC5cbiAgICAgICAgICAgICAgbGVuZ3RoIC09IGNodW5rLmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBcbiAgLy8gQXBwZW5kIGFueSBleHRyYSBkYXRhIGluIG9wMS5cbiAgd2hpbGUgKChjb21wb25lbnQgPSB0YWtlKC0xKSkpXG4gICAgYXBwZW5kKGNvbXBvbmVudCk7XG4gIFxuICByZXR1cm4gdHJpbShuZXdPcCk7XG59O1xuXG4vKiogQ29tcG9zZSBvcDEgYW5kIG9wMiB0b2dldGhlciBhbmQgcmV0dXJuIHRoZSByZXN1bHQgKi9cbmV4cG9ydHMuY29tcG9zZSA9IGZ1bmN0aW9uKG9wMSwgb3AyKSB7XG4gIGNoZWNrT3Aob3AxKTtcbiAgY2hlY2tPcChvcDIpO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGFwcGVuZCA9IG1ha2VBcHBlbmQocmVzdWx0KTtcbiAgdmFyIHRha2UgPSBtYWtlVGFrZShvcDEpWzBdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IG9wMltpXTtcbiAgICB2YXIgbGVuZ3RoLCBjaHVuaztcbiAgICBzd2l0Y2ggKHR5cGVvZiBjb21wb25lbnQpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6IC8vIFNraXBcbiAgICAgICAgbGVuZ3RoID0gY29tcG9uZW50O1xuICAgICAgICB3aGlsZSAobGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNodW5rID0gdGFrZShsZW5ndGgsICdkJyk7XG4gICAgICAgICAgYXBwZW5kKGNodW5rKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgbGVuZ3RoIC09IGNvbXBvbmVudExlbmd0aChjaHVuayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzdHJpbmcnOiAvLyBJbnNlcnRcbiAgICAgICAgYXBwZW5kKGNvbXBvbmVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOiAvLyBEZWxldGVcbiAgICAgICAgbGVuZ3RoID0gY29tcG9uZW50LmQ7XG5cbiAgICAgICAgd2hpbGUgKGxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjaHVuayA9IHRha2UobGVuZ3RoLCAnZCcpO1xuXG4gICAgICAgICAgc3dpdGNoICh0eXBlb2YgY2h1bmspIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgIGFwcGVuZCh7ZDogY2h1bmt9KTtcbiAgICAgICAgICAgICAgbGVuZ3RoIC09IGNodW5rO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgIGxlbmd0aCAtPSBjaHVuay5sZW5ndGg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgYXBwZW5kKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgd2hpbGUgKChjb21wb25lbnQgPSB0YWtlKC0xKSkpXG4gICAgYXBwZW5kKGNvbXBvbmVudCk7XG5cbiAgcmV0dXJuIHRyaW0ocmVzdWx0KTtcbn07XG5cbnZhciB0cmFuc2Zvcm1Qb3NpdGlvbiA9IGZ1bmN0aW9uKGN1cnNvciwgb3ApIHtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYyA9IG9wW2ldO1xuICAgIGlmIChjdXJzb3IgPD0gcG9zKSBicmVhaztcblxuICAgIC8vIEkgY291bGQgYWN0dWFsbHkgdXNlIHRoZSBvcF9pdGVyIHN0dWZmIGFib3ZlIC0gYnV0IEkgdGhpbmsgaXRzIHNpbXBsZXJcbiAgICAvLyBsaWtlIHRoaXMuXG4gICAgc3dpdGNoICh0eXBlb2YgYykge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaWYgKGN1cnNvciA8PSBwb3MgKyBjKVxuICAgICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgICAgIHBvcyArPSBjO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcG9zICs9IGMubGVuZ3RoO1xuICAgICAgICBjdXJzb3IgKz0gYy5sZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBjdXJzb3IgLT0gTWF0aC5taW4oYy5kLCBjdXJzb3IgLSBwb3MpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGN1cnNvcjtcbn07XG5cbmV4cG9ydHMudHJhbnNmb3JtQ3Vyc29yID0gZnVuY3Rpb24oY3Vyc29yLCBvcCwgaXNPd25PcCkge1xuICB2YXIgcG9zID0gMDtcbiAgaWYgKGlzT3duT3ApIHtcbiAgICAvLyBKdXN0IHRyYWNrIHRoZSBwb3NpdGlvbi4gV2UnbGwgdGVsZXBvcnQgdGhlIGN1cnNvciB0byB0aGUgZW5kIGFueXdheS5cbiAgICAvLyBUaGlzIHdvcmtzIGJlY2F1c2UgdGV4dCBvcHMgZG9uJ3QgaGF2ZSBhbnkgdHJhaWxpbmcgc2tpcHMgYXQgdGhlIGVuZCAtIHNvIHRoZSBsYXN0XG4gICAgLy8gY29tcG9uZW50IGlzIHRoZSBsYXN0IHRoaW5nLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gb3BbaV07XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBjKSB7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgcG9zICs9IGM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgcG9zICs9IGMubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBKdXN0IGVhdCBkZWxldGVzLlxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3BvcywgcG9zXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW3RyYW5zZm9ybVBvc2l0aW9uKGN1cnNvclswXSwgb3ApLCB0cmFuc2Zvcm1Qb3NpdGlvbihjdXJzb3JbMV0sIG9wKV07XG4gIH1cbn07XG4iLCIvLyBUaGlzIGlzIGEgcmVhbGx5IHNpbXBsZSBPVCB0eXBlLiBJdHMgbm90IGNvbXBpbGVkIHdpdGggdGhlIHdlYiBjbGllbnQsIGJ1dCBpdCBjb3VsZCBiZS5cbi8vXG4vLyBJdHMgbW9zdGx5IGluY2x1ZGVkIGZvciBkZW1vbnN0cmF0aW9uIHB1cnBvc2VzIGFuZCBpdHMgdXNlZCBpbiB0aGUgbWV0YSB1bml0IHRlc3RzLlxuLy9cbi8vIFRoaXMgZGVmaW5lcyBhIHJlYWxseSBzaW1wbGUgdGV4dCBPVCB0eXBlIHdoaWNoIG9ubHkgYWxsb3dzIGluc2VydHMuIChObyBkZWxldGVzKS5cbi8vXG4vLyBPcHMgbG9vayBsaWtlOlxuLy8gICB7cG9zaXRpb246IywgdGV4dDpcImFzZGZcIn1cbi8vXG4vLyBEb2N1bWVudCBzbmFwc2hvdHMgbG9vayBsaWtlOlxuLy8gICB7c3RyOnN0cmluZ31cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIFRoZSBuYW1lIG9mIHRoZSBPVCB0eXBlLiBUaGUgdHlwZSBpdHNlbGYgaXMgZXhwb3NlZCB0byBvdHR5cGVzW3R5cGUubmFtZV0gYW5kIG90dHlwZXNbdHlwZS51cmldLlxuICAvLyBUaGUgbmFtZSBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBhY3R1YWwgdHlwZSBpbiBhbGwgQVBJIG1ldGhvZHMgaW4gU2hhcmVKUy5cbiAgbmFtZTogJ3NpbXBsZScsXG5cbiAgLy8gQ2Fub25pY2FsIG5hbWUuXG4gIHVyaTogJ2h0dHA6Ly9zaGFyZWpzLm9yZy90eXBlcy9zaW1wbGUnLFxuXG4gIC8vIENyZWF0ZSBhIG5ldyBkb2N1bWVudCBzbmFwc2hvdC4gSW5pdGlhbCBkYXRhIGNhbiBiZSBwYXNzZWQgaW4uXG4gIGNyZWF0ZTogZnVuY3Rpb24oaW5pdGlhbCkge1xuICAgIGlmIChpbml0aWFsID09IG51bGwpXG4gICAgICBpbml0aWFsID0gJyc7XG5cbiAgICByZXR1cm4ge3N0cjogaW5pdGlhbH07XG4gIH0sXG5cbiAgLy8gQXBwbHkgdGhlIGdpdmVuIG9wIHRvIHRoZSBkb2N1bWVudCBzbmFwc2hvdC4gUmV0dXJucyB0aGUgbmV3IHNuYXBzaG90LlxuICBhcHBseTogZnVuY3Rpb24oc25hcHNob3QsIG9wKSB7XG4gICAgaWYgKG9wLnBvc2l0aW9uIDwgMCB8fCBvcC5wb3NpdGlvbiA+IHNuYXBzaG90LnN0ci5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcG9zaXRpb24nKTtcblxuICAgIHZhciBzdHIgPSBzbmFwc2hvdC5zdHI7XG4gICAgc3RyID0gc3RyLnNsaWNlKDAsIG9wLnBvc2l0aW9uKSArIG9wLnRleHQgKyBzdHIuc2xpY2Uob3AucG9zaXRpb24pO1xuICAgIHJldHVybiB7c3RyOiBzdHJ9O1xuICB9LFxuXG4gIC8vIFRyYW5zZm9ybSBvcDEgYnkgb3AyLiBSZXR1cm5zIHRyYW5zZm9ybWVkIHZlcnNpb24gb2Ygb3AxLlxuICAvLyBTeW0gZGVzY3JpYmVzIHRoZSBzeW1tZXRyeSBvZiB0aGUgb3BlcmF0aW9uLiBJdHMgZWl0aGVyICdsZWZ0JyBvciAncmlnaHQnXG4gIC8vIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBvcCBiZWluZyB0cmFuc2Zvcm1lZCBjb21lcyBmcm9tIHRoZSBjbGllbnQgb3IgdGhlXG4gIC8vIHNlcnZlci5cbiAgdHJhbnNmb3JtOiBmdW5jdGlvbihvcDEsIG9wMiwgc3ltKSB7XG4gICAgdmFyIHBvcyA9IG9wMS5wb3NpdGlvbjtcblxuICAgIGlmIChvcDIucG9zaXRpb24gPCBwb3MgfHwgKG9wMi5wb3NpdGlvbiA9PT0gcG9zICYmIHN5bSA9PT0gJ2xlZnQnKSkge1xuICAgICAgcG9zICs9IG9wMi50ZXh0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4ge3Bvc2l0aW9uOiBwb3MsIHRleHQ6IG9wMS50ZXh0fTtcbiAgfVxufTtcblxuIiwiKGZ1bmN0aW9uKCl7Ly8gQSBUUDIgaW1wbGVtZW50YXRpb24gb2YgdGV4dCwgZm9sbG93aW5nIHRoaXMgc3BlYzpcbi8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9saWdodHdhdmUvc291cmNlL2Jyb3dzZS90cnVuay9leHBlcmltZW50YWwvb3QvUkVBRE1FXG4vL1xuLy8gQSBkb2N1bWVudCBpcyBtYWRlIHVwIG9mIGEgc3RyaW5nIGFuZCBhIHNldCBvZiB0b21ic3RvbmVzIGluc2VydGVkIHRocm91Z2hvdXRcbi8vIHRoZSBzdHJpbmcuIEZvciBleGFtcGxlLCAnc29tZSAnLCAoMiB0b21ic3RvbmVzKSwgJ3N0cmluZycuXG4vL1xuLy8gVGhpcyBpcyBlbmNvZGVkIGluIGEgZG9jdW1lbnQgYXM6IHtzOidzb21lIHN0cmluZycsIHQ6WzUsIC0yLCA2XX1cbi8vXG4vLyBPcHMgYXJlIGxpc3RzIG9mIGNvbXBvbmVudHMgd2hpY2ggaXRlcmF0ZSBvdmVyIHRoZSB3aG9sZSBkb2N1bWVudC4gKEkgbWlnaHRcbi8vIGNoYW5nZSB0aGlzIGF0IHNvbWUgcG9pbnQsIGJ1dCBhIHZlcnNpb24gdGhhdHMgbGVzcyBzdHJpY3QgaXMgYmFja3dhcmRzXG4vLyBjb21wYXRpYmxlLilcbi8vXG4vLyBDb21wb25lbnRzIGFyZSBlaXRoZXI6XG4vLyAgIE46ICAgICAgICAgU2tpcCBOIGNoYXJhY3RlcnMgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50XG4vLyAgIHtpOidzdHInfTogSW5zZXJ0ICdzdHInIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudFxuLy8gICB7aTpOfTogICAgIEluc2VydCBOIHRvbWJzdG9uZXMgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50XG4vLyAgIHtkOk59OiAgICAgRGVsZXRlICh0b21ic3RvbmUpIE4gY2hhcmFjdGVycyBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnRcbi8vXG4vLyBFZzogWzMsIHtpOidoaSd9LCA1LCB7ZDo4fV1cbi8vXG4vLyBTbmFwc2hvdHMgYXJlIGxpc3RzIHdpdGggY2hhcmFjdGVycyBhbmQgdG9tYnN0b25lcy4gQ2hhcmFjdGVycyBhcmUgc3RvcmVkIGluIHN0cmluZ3Ncbi8vIGFuZCBhZGphY2VudCB0b21ic3RvbmVzIGFyZSBmbGF0dGVuZWQgaW50byBudW1iZXJzLlxuLy9cbi8vIEVnLCB0aGUgZG9jdW1lbnQ6ICdIZWxsbyAuLi4uLndvcmxkJyAoJy4nIGRlbm90ZXMgdG9tYnN0b25lZCAoZGVsZXRlZCkgY2hhcmFjdGVycylcbi8vIHdvdWxkIGJlIHJlcHJlc2VudGVkIGJ5IGEgZG9jdW1lbnQgc25hcHNob3Qgb2YgWydIZWxsbyAnLCA1LCAnd29ybGQnXVxuXG4vL3ZhciBhcHBlbmQsIGFwcGVuZERvYywgY29tcG9uZW50TGVuZ3RoLCBtYWtlVGFrZSwgdGFrZURvYywgdHJhbnNmb3JtZXI7XG5cbnZhciB0eXBlID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5hbWU6ICd0ZXh0LXRwMicsXG4gIHRwMjogdHJ1ZSxcbiAgdXJpOiAnaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL3RleHQtdHAydjEnLFxuICBjcmVhdGU6IGZ1bmN0aW9uKGluaXRpYWwpIHtcbiAgICBpZiAoaW5pdGlhbCA9PSBudWxsKSB7XG4gICAgICBpbml0aWFsID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgaW5pdGlhbCAhPSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCdJbml0aWFsIGRhdGEgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaGFyTGVuZ3RoOiBpbml0aWFsLmxlbmd0aCxcbiAgICAgIHRvdGFsTGVuZ3RoOiBpbml0aWFsLmxlbmd0aCxcbiAgICAgIGRhdGE6IGluaXRpYWwubGVuZ3RoID8gW2luaXRpYWxdIDogW11cbiAgICB9O1xuICB9LFxuXG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24oZG9jKSB7XG4gICAgaWYgKCFkb2MuZGF0YSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRvYyBzbmFwc2hvdCcpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jLmRhdGE7XG4gIH0sXG5cbiAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgZG9jID0gdHlwZS5jcmVhdGUoKTtcbiAgICBkb2MuZGF0YSA9IGRhdGE7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjb21wb25lbnQgPSBkYXRhW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZG9jLmNoYXJMZW5ndGggKz0gY29tcG9uZW50Lmxlbmd0aDtcbiAgICAgICAgZG9jLnRvdGFsTGVuZ3RoICs9IGNvbXBvbmVudC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb2MudG90YWxMZW5ndGggKz0gY29tcG9uZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBkb2M7XG4gIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgY2hlY2tPcCA9IGZ1bmN0aW9uKG9wKSB7XG4gIGlmICghaXNBcnJheShvcCkpIHRocm93IG5ldyBFcnJvcignT3AgbXVzdCBiZSBhbiBhcnJheSBvZiBjb21wb25lbnRzJyk7XG5cbiAgdmFyIGxhc3QgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBvcFtpXTtcbiAgICBpZiAodHlwZW9mIGMgPT0gJ29iamVjdCcpIHtcbiAgICAgIC8vIFRoZSBjb21wb25lbnQgaXMgYW4gaW5zZXJ0IG9yIGEgZGVsZXRlLlxuICAgICAgaWYgKGMuaSAhPT0gdW5kZWZpbmVkKSB7IC8vIEluc2VydC5cbiAgICAgICAgaWYgKCEoKHR5cGVvZiBjLmkgPT09ICdzdHJpbmcnICYmIGMuaS5sZW5ndGggPiAwKSAvLyBTdHJpbmcgaW5zZXJ0c1xuICAgICAgICAgICAgICB8fCAodHlwZW9mIGMuaSA9PT0gJ251bWJlcicgJiYgYy5pID4gMCkpKSAvLyBUb21ic3RvbmUgaW5zZXJ0c1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5zZXJ0cyBtdXN0IGluc2VydCBhIHN0cmluZyBvciBhICtpdmUgbnVtYmVyJyk7XG5cbiAgICAgIH0gZWxzZSBpZiAoYy5kICE9PSB1bmRlZmluZWQpIHsgLy8gRGVsZXRlXG4gICAgICAgIGlmICghKHR5cGVvZiBjLmQgPT09ICdudW1iZXInICYmIGMuZCA+IDApKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVsZXRlcyBtdXN0IGJlIGEgK2l2ZSBudW1iZXInKTtcblxuICAgICAgfSBlbHNlIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIGNvbXBvbmVudCBtdXN0IGRlZmluZSAuaSBvciAuZCcpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBjb21wb25lbnQgbXVzdCBiZSBhIHNraXAuXG4gICAgICBpZiAodHlwZW9mIGMgIT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignT3AgY29tcG9uZW50cyBtdXN0IGJlIG9iamVjdHMgb3IgbnVtYmVycycpO1xuXG4gICAgICBpZiAoYyA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ1NraXAgY29tcG9uZW50cyBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBpZiAodHlwZW9mIGxhc3QgPT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ0FkamFjZW50IHNraXAgY29tcG9uZW50cyBzaG91bGQgYmUgY29tYmluZWQnKTtcbiAgICB9XG5cbiAgICBsYXN0ID0gYztcbiAgfVxufTtcblxuLy8gVGFrZSB0aGUgbmV4dCBwYXJ0IGZyb20gdGhlIHNwZWNpZmllZCBwb3NpdGlvbiBpbiBhIGRvY3VtZW50IHNuYXBzaG90LlxuLy8gcG9zaXRpb24gPSB7aW5kZXgsIG9mZnNldH0uIEl0IHdpbGwgYmUgdXBkYXRlZC5cbnZhciB0YWtlRG9jID0gdHlwZS5fdGFrZURvYyA9IGZ1bmN0aW9uKGRvYywgcG9zaXRpb24sIG1heGxlbmd0aCwgdG9tYnNJbmRpdmlzaWJsZSkge1xuICBpZiAocG9zaXRpb24uaW5kZXggPj0gZG9jLmRhdGEubGVuZ3RoKVxuICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIGdvZXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCcpO1xuXG4gIHZhciBwYXJ0ID0gZG9jLmRhdGFbcG9zaXRpb24uaW5kZXhdO1xuXG4gIC8vIFRoaXMgY2FuIGJlIHdyaXR0ZW4gYXMgYW4gdWdseS1hcnNlZCBnaWFudCB0ZXJuYXJ5IHN0YXRlbWVudCwgYnV0IGl0cyBtdWNoXG4gIC8vIG1vcmUgcmVhZGFibGUgbGlrZSB0aGlzLiBVZ2xpZnkgd2lsbCBjb252ZXJ0IGl0IGludG8gc2FpZCB0ZXJuYXJ5IGFueXdheS5cbiAgdmFyIHJlc3VsdDtcbiAgaWYgKHR5cGVvZiBwYXJ0ID09ICdzdHJpbmcnKSB7XG4gICAgaWYgKG1heGxlbmd0aCAhPSBudWxsKSB7XG4gICAgICByZXN1bHQgPSBwYXJ0LnNsaWNlKHBvc2l0aW9uLm9mZnNldCwgcG9zaXRpb24ub2Zmc2V0ICsgbWF4bGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcGFydC5zbGljZShwb3NpdGlvbi5vZmZzZXQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobWF4bGVuZ3RoID09IG51bGwgfHwgdG9tYnNJbmRpdmlzaWJsZSkge1xuICAgICAgcmVzdWx0ID0gcGFydCAtIHBvc2l0aW9uLm9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gTWF0aC5taW4obWF4bGVuZ3RoLCBwYXJ0IC0gcG9zaXRpb24ub2Zmc2V0KTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVzdWx0TGVuID0gcmVzdWx0Lmxlbmd0aCB8fCByZXN1bHQ7XG5cbiAgaWYgKChwYXJ0Lmxlbmd0aCB8fCBwYXJ0KSAtIHBvc2l0aW9uLm9mZnNldCA+IHJlc3VsdExlbikge1xuICAgIHBvc2l0aW9uLm9mZnNldCArPSByZXN1bHRMZW47XG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb24uaW5kZXgrKztcbiAgICBwb3NpdGlvbi5vZmZzZXQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIEFwcGVuZCBhIHBhcnQgdG8gdGhlIGVuZCBvZiBhIGRvY3VtZW50XG52YXIgYXBwZW5kRG9jID0gdHlwZS5fYXBwZW5kRG9jID0gZnVuY3Rpb24oZG9jLCBwKSB7XG4gIGlmIChwID09PSAwIHx8IHAgPT09ICcnKSByZXR1cm47XG5cbiAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJykge1xuICAgIGRvYy5jaGFyTGVuZ3RoICs9IHAubGVuZ3RoO1xuICAgIGRvYy50b3RhbExlbmd0aCArPSBwLmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBkb2MudG90YWxMZW5ndGggKz0gcDtcbiAgfVxuXG4gIHZhciBkYXRhID0gZG9jLmRhdGE7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgIGRhdGEucHVzaChwKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSB0eXBlb2YgcCkge1xuICAgIGRhdGFbZGF0YS5sZW5ndGggLSAxXSArPSBwO1xuICB9IGVsc2Uge1xuICAgIGRhdGEucHVzaChwKTtcbiAgfVxufTtcblxuLy8gQXBwbHkgdGhlIG9wIHRvIHRoZSBkb2N1bWVudC4gVGhlIGRvY3VtZW50IGlzIG5vdCBtb2RpZmllZCBpbiB0aGUgcHJvY2Vzcy5cbnR5cGUuYXBwbHkgPSBmdW5jdGlvbihkb2MsIG9wKSB7XG4gIGlmIChkb2MudG90YWxMZW5ndGggPT0gbnVsbCB8fCBkb2MuY2hhckxlbmd0aCA9PSBudWxsIHx8ICFpc0FycmF5KGRvYy5kYXRhKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU25hcHNob3QgaXMgaW52YWxpZCcpO1xuICB9XG4gIGNoZWNrT3Aob3ApO1xuXG4gIHZhciBuZXdEb2MgPSB0eXBlLmNyZWF0ZSgpO1xuICB2YXIgcG9zaXRpb24gPSB7aW5kZXg6IDAsIG9mZnNldDogMH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjb21wb25lbnQgPSBvcFtpXTtcbiAgICB2YXIgcmVtYWluZGVyLCBwYXJ0O1xuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT0gJ251bWJlcicpIHsgLy8gU2tpcFxuICAgICAgcmVtYWluZGVyID0gY29tcG9uZW50O1xuICAgICAgd2hpbGUgKHJlbWFpbmRlciA+IDApIHtcbiAgICAgICAgcGFydCA9IHRha2VEb2MoZG9jLCBwb3NpdGlvbiwgcmVtYWluZGVyKTtcbiAgICAgICAgYXBwZW5kRG9jKG5ld0RvYywgcGFydCk7XG4gICAgICAgIHJlbWFpbmRlciAtPSBwYXJ0Lmxlbmd0aCB8fCBwYXJ0O1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuaSAhPT0gdW5kZWZpbmVkKSB7IC8vIEluc2VydFxuICAgICAgYXBwZW5kRG9jKG5ld0RvYywgY29tcG9uZW50LmkpO1xuXG4gICAgfSBlbHNlIGlmIChjb21wb25lbnQuZCAhPT0gdW5kZWZpbmVkKSB7IC8vIERlbGV0ZVxuICAgICAgcmVtYWluZGVyID0gY29tcG9uZW50LmQ7XG4gICAgICB3aGlsZSAocmVtYWluZGVyID4gMCkge1xuICAgICAgICBwYXJ0ID0gdGFrZURvYyhkb2MsIHBvc2l0aW9uLCByZW1haW5kZXIpO1xuICAgICAgICByZW1haW5kZXIgLT0gcGFydC5sZW5ndGggfHwgcGFydDtcbiAgICAgIH1cbiAgICAgIGFwcGVuZERvYyhuZXdEb2MsIGNvbXBvbmVudC5kKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ld0RvYztcbn07XG5cbi8vIEFwcGVuZCBhbiBvcCBjb21wb25lbnQgdG8gdGhlIGVuZCBvZiB0aGUgc3BlY2lmaWVkIG9wLiAgRXhwb3J0ZWQgZm9yIHRoZVxuLy8gcmFuZG9tT3BHZW5lcmF0b3IuXG52YXIgYXBwZW5kID0gdHlwZS5fYXBwZW5kID0gZnVuY3Rpb24ob3AsIGNvbXBvbmVudCkge1xuICB2YXIgbGFzdDtcblxuICBpZiAoY29tcG9uZW50ID09PSAwIHx8IGNvbXBvbmVudC5pID09PSAnJyB8fCBjb21wb25lbnQuaSA9PT0gMCB8fCBjb21wb25lbnQuZCA9PT0gMCkge1xuICAgIC8vIERyb3AgdGhlIG5ldyBjb21wb25lbnQuXG4gIH0gZWxzZSBpZiAob3AubGVuZ3RoID09PSAwKSB7XG4gICAgb3AucHVzaChjb21wb25lbnQpO1xuICB9IGVsc2Uge1xuICAgIGxhc3QgPSBvcFtvcC5sZW5ndGggLSAxXTtcbiAgICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgbGFzdCA9PSAnbnVtYmVyJykge1xuICAgICAgb3Bbb3AubGVuZ3RoIC0gMV0gKz0gY29tcG9uZW50O1xuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50LmkgIT0gbnVsbCAmJiAobGFzdC5pICE9IG51bGwpICYmIHR5cGVvZiBsYXN0LmkgPT09IHR5cGVvZiBjb21wb25lbnQuaSkge1xuICAgICAgbGFzdC5pICs9IGNvbXBvbmVudC5pO1xuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50LmQgIT0gbnVsbCAmJiAobGFzdC5kICE9IG51bGwpKSB7XG4gICAgICBsYXN0LmQgKz0gY29tcG9uZW50LmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wLnB1c2goY29tcG9uZW50KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIE1ha2VzIDIgZnVuY3Rpb25zIGZvciB0YWtpbmcgY29tcG9uZW50cyBmcm9tIHRoZSBzdGFydCBvZiBhbiBvcCwgYW5kIGZvclxuLy8gcGVla2luZyBhdCB0aGUgbmV4dCBvcCB0aGF0IGNvdWxkIGJlIHRha2VuLlxudmFyIG1ha2VUYWtlID0gZnVuY3Rpb24ob3ApIHtcbiAgLy8gVGhlIGluZGV4IG9mIHRoZSBuZXh0IGNvbXBvbmVudCB0byB0YWtlXG4gIHZhciBpbmRleCA9IDA7XG4gIC8vIFRoZSBvZmZzZXQgaW50byB0aGUgY29tcG9uZW50XG4gIHZhciBvZmZzZXQgPSAwO1xuXG4gIHZhciB0YWtlID0gZnVuY3Rpb24obWF4bGVuZ3RoLCBpbnNlcnRzSW5kaXZpc2libGUpIHtcbiAgICBpZiAoaW5kZXggPT09IG9wLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgdmFyIGUgPSBvcFtpbmRleF07XG4gICAgdmFyIGN1cnJlbnQ7XG4gICAgdmFyIHJlc3VsdDtcblxuICAgIC8vIGlmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYSBza2lwLCBhbiBpbnNlcnQgb2YgYSBudW1iZXIgb3IgYSBkZWxldGVcbiAgICBpZiAodHlwZW9mIChjdXJyZW50ID0gZSkgPT0gJ251bWJlcicgfHwgdHlwZW9mIChjdXJyZW50ID0gZS5pKSA9PSAnbnVtYmVyJyB8fCAoY3VycmVudCA9IGUuZCkgIT0gbnVsbCkge1xuICAgICAgdmFyIGM7XG4gICAgICBpZiAoKG1heGxlbmd0aCA9PSBudWxsKSB8fCBjdXJyZW50IC0gb2Zmc2V0IDw9IG1heGxlbmd0aCB8fCAoaW5zZXJ0c0luZGl2aXNpYmxlICYmIGUuaSAhPSBudWxsKSkge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3Qgb2YgdGhlIGN1cnJlbnQgZWxlbWVudC5cbiAgICAgICAgYyA9IGN1cnJlbnQgLSBvZmZzZXQ7XG4gICAgICAgICsraW5kZXg7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgKz0gbWF4bGVuZ3RoO1xuICAgICAgICBjID0gbWF4bGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBQYWNrYWdlIHRoZSBjb21wb25lbnQgYmFjayB1cC5cbiAgICAgIGlmIChlLmkgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge2k6IGN9O1xuICAgICAgfSBlbHNlIGlmIChlLmQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ge2Q6IGN9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gSW5zZXJ0IG9mIGEgc3RyaW5nLlxuICAgICAgaWYgKChtYXhsZW5ndGggPT0gbnVsbCkgfHwgZS5pLmxlbmd0aCAtIG9mZnNldCA8PSBtYXhsZW5ndGggfHwgaW5zZXJ0c0luZGl2aXNpYmxlKSB7XG4gICAgICAgIHJlc3VsdCA9IHtpOiBlLmkuc2xpY2Uob2Zmc2V0KX07XG4gICAgICAgICsraW5kZXg7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB7aTogZS5pLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbWF4bGVuZ3RoKX07XG4gICAgICAgIG9mZnNldCArPSBtYXhsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfTtcblxuICB2YXIgcGVla1R5cGUgPSBmdW5jdGlvbigpIHtyZXR1cm4gb3BbaW5kZXhdO307XG4gIHJldHVybiBbdGFrZSwgcGVla1R5cGVdO1xufTtcblxuLy8gRmluZCBhbmQgcmV0dXJuIHRoZSBsZW5ndGggb2YgYW4gb3AgY29tcG9uZW50XG52YXIgY29tcG9uZW50TGVuZ3RoID0gZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50ID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBjb21wb25lbnQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNvbXBvbmVudC5pID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjb21wb25lbnQuaS5sZW5ndGg7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudC5kIHx8IGNvbXBvbmVudC5pO1xuICB9XG59O1xuXG4vLyBOb3JtYWxpemUgYW4gb3AsIHJlbW92aW5nIGFsbCBlbXB0eSBza2lwcyBhbmQgZW1wdHkgaW5zZXJ0cyAvIGRlbGV0ZXMuXG4vLyBDb25jYXRlbmF0ZSBhZGphY2VudCBpbnNlcnRzIGFuZCBkZWxldGVzLlxudHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgbmV3T3AgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIGFwcGVuZChuZXdPcCwgb3BbaV0pO1xuICB9XG4gIHJldHVybiBuZXdPcDtcbn07XG5cbi8vIFRoaXMgaXMgYSBoZWxwZXIgbWV0aG9kIHRvIHRyYW5zZm9ybSBhbmQgcHJ1bmUuIGdvRm9yd2FyZHMgaXMgdHJ1ZSBmb3IgdHJhbnNmb3JtLCBmYWxzZSBmb3IgcHJ1bmUuXG52YXIgdHJhbnNmb3JtZXIgPSBmdW5jdGlvbihvcCwgb3RoZXJPcCwgZ29Gb3J3YXJkcywgc2lkZSkge1xuICBjaGVja09wKG9wKTtcbiAgY2hlY2tPcChvdGhlck9wKTtcblxuICB2YXIgbmV3T3AgPSBbXTtcblxuICB2YXIgZm5zID0gbWFrZVRha2Uob3ApLFxuICAgICAgdGFrZSA9IGZuc1swXSxcbiAgICAgIHBlZWsgPSBmbnNbMV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdGhlck9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IG90aGVyT3BbaV07XG4gICAgdmFyIGxlbiA9IGNvbXBvbmVudExlbmd0aChjb21wb25lbnQpO1xuICAgIHZhciBjaHVuaztcblxuICAgIGlmIChjb21wb25lbnQuaSAhPSBudWxsKSB7IC8vIEluc2VydCB0ZXh0IG9yIHRvbWJzXG4gICAgICBpZiAoZ29Gb3J3YXJkcykgeyAvLyBUcmFuc2Zvcm0gLSBpbnNlcnQgc2tpcHMgb3ZlciBkZWxldGVkIHBhcnRzLlxuICAgICAgICBpZiAoc2lkZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgLy8gVGhlIGxlZnQgc2lkZSBpbnNlcnQgc2hvdWxkIGdvIGZpcnN0LlxuICAgICAgICAgIHZhciBuZXh0O1xuICAgICAgICAgIHdoaWxlICgobmV4dCA9IHBlZWsoKSkgJiYgbmV4dC5pICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFwcGVuZChuZXdPcCwgdGFrZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gYW55IGNhc2UsIHNraXAgdGhlIGluc2VydGVkIHRleHQuXG4gICAgICAgIGFwcGVuZChuZXdPcCwgbGVuKTtcblxuICAgICAgfSBlbHNlIHsgLy8gUHJ1bmUuIFJlbW92ZSBza2lwcyBmb3IgaW5zZXJ0cy5cbiAgICAgICAgd2hpbGUgKGxlbiA+IDApIHtcbiAgICAgICAgICBjaHVuayA9IHRha2UobGVuLCB0cnVlKTtcblxuICAgICAgICAgIC8vIFRoZSBjaHVuayB3aWxsIGJlIG51bGwgaWYgd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIGluIHRoZSBvdGhlciBvcC5cbiAgICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignVGhlIHRyYW5zZm9ybWVkIG9wIGlzIGludmFsaWQnKTtcbiAgICAgICAgICBpZiAoY2h1bmsuZCAhPSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdHJhbnNmb3JtZWQgb3AgZGVsZXRlcyBsb2NhbGx5IGluc2VydGVkIGNoYXJhY3RlcnMgLSBpdCBjYW5ub3QgYmUgcHVyZ2VkIG9mIHRoZSBpbnNlcnQuJyk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09ICdudW1iZXInKVxuICAgICAgICAgICAgbGVuIC09IGNodW5rO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFwcGVuZChuZXdPcCwgY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gU2tpcHMgb3IgZGVsZXRlcy5cbiAgICAgIHdoaWxlIChsZW4gPiAwKSB7XG4gICAgICAgIGNodW5rID0gdGFrZShsZW4sIHRydWUpO1xuICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcignVGhlIG9wIHRyYXZlcnNlcyBtb3JlIGVsZW1lbnRzIHRoYW4gdGhlIGRvY3VtZW50IGhhcycpO1xuXG4gICAgICAgIGFwcGVuZChuZXdPcCwgY2h1bmspO1xuICAgICAgICBpZiAoIWNodW5rLmkpIGxlbiAtPSBjb21wb25lbnRMZW5ndGgoY2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFwcGVuZCBleHRyYXMgZnJvbSBvcDEuXG4gIHZhciBjb21wb25lbnQ7XG4gIHdoaWxlICgoY29tcG9uZW50ID0gdGFrZSgpKSkge1xuICAgIGlmIChjb21wb25lbnQuaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZW1haW5pbmcgZnJhZ21lbnRzIGluIHRoZSBvcDogXCIgKyBjb21wb25lbnQpO1xuICAgIH1cbiAgICBhcHBlbmQobmV3T3AsIGNvbXBvbmVudCk7XG4gIH1cbiAgcmV0dXJuIG5ld09wO1xufTtcblxuLy8gdHJhbnNmb3JtIG9wMSBieSBvcDIuIFJldHVybiB0cmFuc2Zvcm1lZCB2ZXJzaW9uIG9mIG9wMS4gb3AxIGFuZCBvcDIgYXJlXG4vLyB1bmNoYW5nZWQgYnkgdHJhbnNmb3JtLiBTaWRlIHNob3VsZCBiZSAnbGVmdCcgb3IgJ3JpZ2h0JywgZGVwZW5kaW5nIG9uIGlmXG4vLyBvcDEuaWQgPD4gb3AyLmlkLlxuLy9cbi8vICdsZWZ0JyA9PSBjbGllbnQgb3AgZm9yIFNoYXJlSlMuXG50eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKG9wLCBvdGhlck9wLCBzaWRlKSB7XG4gIGlmIChzaWRlICE9ICdsZWZ0JyAmJiBzaWRlICE9ICdyaWdodCcpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwic2lkZSAoXCIgKyBzaWRlICsgXCIpIHNob3VsZCBiZSAnbGVmdCcgb3IgJ3JpZ2h0J1wiKTtcblxuICByZXR1cm4gdHJhbnNmb3JtZXIob3AsIG90aGVyT3AsIHRydWUsIHNpZGUpO1xufTtcblxudHlwZS5wcnVuZSA9IGZ1bmN0aW9uKG9wLCBvdGhlck9wKSB7XG4gIHJldHVybiB0cmFuc2Zvcm1lcihvcCwgb3RoZXJPcCwgZmFsc2UpO1xufTtcblxudHlwZS5jb21wb3NlID0gZnVuY3Rpb24ob3AxLCBvcDIpIHtcbiAgLy92YXIgY2h1bmssIGNodW5rTGVuZ3RoLCBjb21wb25lbnQsIGxlbmd0aCwgcmVzdWx0LCB0YWtlLCBfLCBfaSwgX2xlbiwgX3JlZjtcbiAgaWYgKG9wMSA9PSBudWxsKSByZXR1cm4gb3AyO1xuXG4gIGNoZWNrT3Aob3AxKTtcbiAgY2hlY2tPcChvcDIpO1xuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIHRha2UgPSBtYWtlVGFrZShvcDEpWzBdO1xuICB2YXIgY29tcG9uZW50O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29tcG9uZW50ID0gb3AyW2ldO1xuICAgIHZhciBsZW4sIGNodW5rO1xuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdudW1iZXInKSB7IC8vIFNraXBcbiAgICAgIC8vIEp1c3QgY29weSBmcm9tIG9wMS5cbiAgICAgIGxlbiA9IGNvbXBvbmVudDtcbiAgICAgIHdoaWxlIChsZW4gPiAwKSB7XG4gICAgICAgIGNodW5rID0gdGFrZShsZW4pO1xuICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgb3AgdHJhdmVyc2VzIG1vcmUgZWxlbWVudHMgdGhhbiB0aGUgZG9jdW1lbnQgaGFzJyk7XG5cbiAgICAgICAgYXBwZW5kKHJlc3VsdCwgY2h1bmspO1xuICAgICAgICBsZW4gLT0gY29tcG9uZW50TGVuZ3RoKGNodW5rKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoY29tcG9uZW50LmkgIT09IHVuZGVmaW5lZCkgeyAvLyBJbnNlcnRcbiAgICAgIGFwcGVuZChyZXN1bHQsIHtpOiBjb21wb25lbnQuaX0pO1xuXG4gICAgfSBlbHNlIHsgLy8gRGVsZXRlXG4gICAgICBsZW4gPSBjb21wb25lbnQuZDtcbiAgICAgIHdoaWxlIChsZW4gPiAwKSB7XG4gICAgICAgIGNodW5rID0gdGFrZShsZW4pO1xuICAgICAgICBpZiAoY2h1bmsgPT09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgb3AgdHJhdmVyc2VzIG1vcmUgZWxlbWVudHMgdGhhbiB0aGUgZG9jdW1lbnQgaGFzJyk7XG5cbiAgICAgICAgdmFyIGNodW5rTGVuZ3RoID0gY29tcG9uZW50TGVuZ3RoKGNodW5rKTtcblxuICAgICAgICBpZiAoY2h1bmsuaSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIGFwcGVuZChyZXN1bHQsIHtpOiBjaHVua0xlbmd0aH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYXBwZW5kKHJlc3VsdCwge2Q6IGNodW5rTGVuZ3RofSk7XG5cbiAgICAgICAgbGVuIC09IGNodW5rTGVuZ3RoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFwcGVuZCBleHRyYXMgZnJvbSBvcDEuXG4gIHdoaWxlICgoY29tcG9uZW50ID0gdGFrZSgpKSkge1xuICAgIGlmIChjb21wb25lbnQuaSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZW1haW5pbmcgZnJhZ21lbnRzIGluIG9wMTogXCIgKyBjb21wb25lbnQpO1xuICAgIH1cbiAgICBhcHBlbmQocmVzdWx0LCBjb21wb25lbnQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbn0pKCkiLCIvKlxuIFRoaXMgaXMgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBKU09OIE9UIHR5cGUuXG5cbiBTcGVjIGlzIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3NlcGhnL1NoYXJlSlMvd2lraS9KU09OLU9wZXJhdGlvbnNcblxuIE5vdGU6IFRoaXMgaXMgYmVpbmcgbWFkZSBvYnNvbGV0ZS4gSXQgd2lsbCBzb29uIGJlIHJlcGxhY2VkIGJ5IHRoZSBKU09OMiB0eXBlLlxuKi9cblxuLyoqXG4gKiBVVElMSVRZIEZVTkNUSU9OU1xuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwYXNzZWQgb2JqZWN0IGlzIGFuIEFycmF5IGluc3RhbmNlLiBDYW4ndCB1c2UgQXJyYXkuaXNBcnJheVxuICogeWV0IGJlY2F1c2UgaXRzIG5vdCBzdXBwb3J0ZWQgb24gSUU4LlxuICpcbiAqIEBwYXJhbSBvYmpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG52YXIgaXNBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogQ2xvbmVzIHRoZSBwYXNzZWQgb2JqZWN0IHVzaW5nIEpTT04gc2VyaWFsaXphdGlvbiAod2hpY2ggaXMgc2xvdykuXG4gKlxuICogaGF4LCBjb3BpZWQgZnJvbSB0ZXN0L3R5cGVzL2pzb24uIEFwcGFyZW50bHkgdGhpcyBpcyBzdGlsbCB0aGUgZmFzdGVzdCB3YXlcbiAqIHRvIGRlZXAgY2xvbmUgYW4gb2JqZWN0LCBhc3N1bWluZyB3ZSBoYXZlIGJyb3dzZXIgc3VwcG9ydCBmb3IgSlNPTi4gIEBzZWVcbiAqIGh0dHA6Ly9qc3BlcmYuY29tL2Nsb25pbmctYW4tb2JqZWN0LzEyXG4gKi9cbnZhciBjbG9uZSA9IGZ1bmN0aW9uKG8pIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobykpO1xufTtcblxuXG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHRoZSBUZXh0IE9UIHR5cGUuIFRoaXMgaXMgdXNlZCBmb3IgdGhlIEpTT04gU3RyaW5nIG9wZXJhdGlvbnMuXG4gKiBAdHlwZSB7Kn1cbiAqL1xudmFyIHRleHQgPSB0eXBlb2YgcmVxdWlyZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVpcmUoJy4vdGV4dC1vbGQnKSA6IHdpbmRvdy5vdHR5cGVzLnRleHQ7XG5cblxuXG4vKipcbiAqIEpTT04gT1QgVHlwZVxuICogQHR5cGUgeyp9XG4gKi9cbnZhciBqc29uID0geyBcbiAgbmFtZTogJ2pzb24wJyxcbiAgdXJpOiAnaHR0cDovL3NoYXJlanMub3JnL3R5cGVzL0pTT052MCdcbn07XG5cbmpzb24uY3JlYXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICAvLyBOdWxsIGluc3RlYWQgb2YgdW5kZWZpbmVkIGlmIHlvdSBkb24ndCBwYXNzIGFuIGFyZ3VtZW50LlxuICByZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRhdGE7XG59O1xuXG5qc29uLmludmVydENvbXBvbmVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIGNfID0ge3A6IGMucH07XG5cbiAgaWYgKGMuc2kgIT09IHZvaWQgMCkgY18uc2QgPSBjLnNpO1xuICBpZiAoYy5zZCAhPT0gdm9pZCAwKSBjXy5zaSA9IGMuc2Q7XG4gIGlmIChjLm9pICE9PSB2b2lkIDApIGNfLm9kID0gYy5vaTtcbiAgaWYgKGMub2QgIT09IHZvaWQgMCkgY18ub2kgPSBjLm9kO1xuICBpZiAoYy5saSAhPT0gdm9pZCAwKSBjXy5sZCA9IGMubGk7XG4gIGlmIChjLmxkICE9PSB2b2lkIDApIGNfLmxpID0gYy5sZDtcbiAgaWYgKGMubmEgIT09IHZvaWQgMCkgY18ubmEgPSAtYy5uYTtcblxuICBpZiAoYy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgY18ubG0gPSBjLnBbYy5wLmxlbmd0aC0xXTtcbiAgICBjXy5wID0gYy5wLnNsaWNlKDAsYy5wLmxlbmd0aC0xKS5jb25jYXQoW2MubG1dKTtcbiAgfVxuXG4gIHJldHVybiBjXztcbn07XG5cbmpzb24uaW52ZXJ0ID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIG9wXyA9IG9wLnNsaWNlKCkucmV2ZXJzZSgpO1xuICB2YXIgaW9wID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3BfLmxlbmd0aDsgaSsrKSB7XG4gICAgaW9wLnB1c2goanNvbi5pbnZlcnRDb21wb25lbnQob3BfW2ldKSk7XG4gIH1cbiAgcmV0dXJuIGlvcDtcbn07XG5cbmpzb24uY2hlY2tWYWxpZE9wID0gZnVuY3Rpb24ob3ApIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICBpZiAoIWlzQXJyYXkob3BbaV0ucCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHBhdGgnKTtcbiAgfVxufTtcblxuanNvbi5jaGVja0xpc3QgPSBmdW5jdGlvbihlbGVtKSB7XG4gIGlmICghaXNBcnJheShlbGVtKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBsaXN0Jyk7XG59O1xuXG5qc29uLmNoZWNrT2JqID0gZnVuY3Rpb24oZWxlbSkge1xuICBpZiAoZWxlbS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhbiBvYmplY3QgKGl0IHdhcyBcIiArIEpTT04uc3RyaW5naWZ5KGVsZW0pICsgXCIpXCIpO1xuICB9XG59O1xuXG5qc29uLmFwcGx5ID0gZnVuY3Rpb24oc25hcHNob3QsIG9wKSB7XG4gIGpzb24uY2hlY2tWYWxpZE9wKG9wKTtcblxuICBvcCA9IGNsb25lKG9wKTtcblxuICB2YXIgY29udGFpbmVyID0ge1xuICAgIGRhdGE6IHNuYXBzaG90XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjID0gb3BbaV07XG5cbiAgICB2YXIgcGFyZW50ID0gbnVsbDtcbiAgICB2YXIgcGFyZW50S2V5ID0gbnVsbDtcbiAgICB2YXIgZWxlbSA9IGNvbnRhaW5lcjtcbiAgICB2YXIga2V5ID0gJ2RhdGEnO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBjLnAubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwID0gYy5wW2pdO1xuXG4gICAgICBwYXJlbnQgPSBlbGVtO1xuICAgICAgcGFyZW50S2V5ID0ga2V5O1xuICAgICAgZWxlbSA9IGVsZW1ba2V5XTtcbiAgICAgIGtleSA9IHA7XG5cbiAgICAgIGlmIChwYXJlbnQgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXRoIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICAvLyBOdW1iZXIgYWRkXG4gICAgaWYgKGMubmEgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtW2tleV0gIT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhIG51bWJlcicpO1xuXG4gICAgICBlbGVtW2tleV0gKz0gYy5uYTtcbiAgICB9XG5cbiAgICAvLyBTdHJpbmcgaW5zZXJ0XG4gICAgZWxzZSBpZiAoYy5zaSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW0gIT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmZXJlbmNlZCBlbGVtZW50IG5vdCBhIHN0cmluZyAoaXQgd2FzICcrSlNPTi5zdHJpbmdpZnkoZWxlbSkrJyknKTtcblxuICAgICAgcGFyZW50W3BhcmVudEtleV0gPSBlbGVtLnNsaWNlKDAsa2V5KSArIGMuc2kgKyBlbGVtLnNsaWNlKGtleSk7XG4gICAgfVxuXG4gICAgLy8gU3RyaW5nIGRlbGV0ZVxuICAgIGVsc2UgaWYgKGMuc2QgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHR5cGVvZiBlbGVtICE9ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlZmVyZW5jZWQgZWxlbWVudCBub3QgYSBzdHJpbmcnKTtcblxuICAgICAgaWYgKGVsZW0uc2xpY2Uoa2V5LGtleSArIGMuc2QubGVuZ3RoKSAhPT0gYy5zZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWxldGVkIHN0cmluZyBkb2VzIG5vdCBtYXRjaCcpO1xuXG4gICAgICBwYXJlbnRbcGFyZW50S2V5XSA9IGVsZW0uc2xpY2UoMCxrZXkpICsgZWxlbS5zbGljZShrZXkgKyBjLnNkLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCByZXBsYWNlXG4gICAgZWxzZSBpZiAoYy5saSAhPT0gdm9pZCAwICYmIGMubGQgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja0xpc3QoZWxlbSk7XG4gICAgICAvLyBTaG91bGQgY2hlY2sgdGhlIGxpc3QgZWxlbWVudCBtYXRjaGVzIGMubGRcbiAgICAgIGVsZW1ba2V5XSA9IGMubGk7XG4gICAgfVxuXG4gICAgLy8gTGlzdCBpbnNlcnRcbiAgICBlbHNlIGlmIChjLmxpICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tMaXN0KGVsZW0pO1xuICAgICAgZWxlbS5zcGxpY2Uoa2V5LDAsIGMubGkpO1xuICAgIH1cblxuICAgIC8vIExpc3QgZGVsZXRlXG4gICAgZWxzZSBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICBqc29uLmNoZWNrTGlzdChlbGVtKTtcbiAgICAgIC8vIFNob3VsZCBjaGVjayB0aGUgbGlzdCBlbGVtZW50IG1hdGNoZXMgYy5sZCBoZXJlIHRvby5cbiAgICAgIGVsZW0uc3BsaWNlKGtleSwxKTtcbiAgICB9XG5cbiAgICAvLyBMaXN0IG1vdmVcbiAgICBlbHNlIGlmIChjLmxtICE9PSB2b2lkIDApIHtcbiAgICAgIGpzb24uY2hlY2tMaXN0KGVsZW0pO1xuICAgICAgaWYgKGMubG0gIT0ga2V5KSB7XG4gICAgICAgIHZhciBlID0gZWxlbVtrZXldO1xuICAgICAgICAvLyBSZW1vdmUgaXQuLi5cbiAgICAgICAgZWxlbS5zcGxpY2Uoa2V5LDEpO1xuICAgICAgICAvLyBBbmQgaW5zZXJ0IGl0IGJhY2suXG4gICAgICAgIGVsZW0uc3BsaWNlKGMubG0sMCxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPYmplY3QgaW5zZXJ0IC8gcmVwbGFjZVxuICAgIGVsc2UgaWYgKGMub2kgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja09iaihlbGVtKTtcblxuICAgICAgLy8gU2hvdWxkIGNoZWNrIHRoYXQgZWxlbVtrZXldID09IGMub2RcbiAgICAgIGVsZW1ba2V5XSA9IGMub2k7XG4gICAgfVxuXG4gICAgLy8gT2JqZWN0IGRlbGV0ZVxuICAgIGVsc2UgaWYgKGMub2QgIT09IHZvaWQgMCkge1xuICAgICAganNvbi5jaGVja09iaihlbGVtKTtcblxuICAgICAgLy8gU2hvdWxkIGNoZWNrIHRoYXQgZWxlbVtrZXldID09IGMub2RcbiAgICAgIGRlbGV0ZSBlbGVtW2tleV07XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgLyBtaXNzaW5nIGluc3RydWN0aW9uIGluIG9wJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5kYXRhO1xufTtcblxuLy8gSGVscGVyIGZvciBpbmNyZW1lbnRhbGx5IGFwcGx5aW5nIGFuIG9wZXJhdGlvbiB0byBhIHNuYXBzaG90LiBDYWxscyB5aWVsZFxuLy8gYWZ0ZXIgZWFjaCBvcCBjb21wb25lbnQgaGFzIGJlZW4gYXBwbGllZC5cbmpzb24uaW5jcmVtZW50YWxBcHBseSA9IGZ1bmN0aW9uKHNuYXBzaG90LCBvcCwgX3lpZWxkKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc21hbGxPcCA9IFtvcFtpXV07XG4gICAgc25hcHNob3QgPSBqc29uLmFwcGx5KHNuYXBzaG90LCBzbWFsbE9wKTtcbiAgICAvLyBJJ2QganVzdCBjYWxsIHRoaXMgeWllbGQsIGJ1dCB0aGF0cyBhIHJlc2VydmVkIGtleXdvcmQuIEJhaCFcbiAgICBfeWllbGQoc21hbGxPcCwgc25hcHNob3QpO1xuICB9XG4gIFxuICByZXR1cm4gc25hcHNob3Q7XG59O1xuXG4vLyBDaGVja3MgaWYgdHdvIHBhdGhzLCBwMSBhbmQgcDIgbWF0Y2guXG52YXIgcGF0aE1hdGNoZXMgPSBqc29uLnBhdGhNYXRjaGVzID0gZnVuY3Rpb24ocDEsIHAyLCBpZ25vcmVMYXN0KSB7XG4gIGlmIChwMS5sZW5ndGggIT0gcDIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHAxLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHAxW2ldICE9PSBwMltpXSAmJiAoIWlnbm9yZUxhc3QgfHwgaSAhPT0gcDEubGVuZ3RoIC0gMSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBfY29udmVydFRvVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICB2YXIgbmV3QyA9IHtwOiBjb21wb25lbnQucFtjb21wb25lbnQucC5sZW5ndGggLSAxXX07XG4gIGlmIChjb21wb25lbnQuc2kgIT0gbnVsbCkge1xuICAgIG5ld0MuaSA9IGNvbXBvbmVudC5zaTtcbiAgfSBlbHNlIHtcbiAgICBuZXdDLmQgPSBjb21wb25lbnQuc2Q7XG4gIH1cbiAgcmV0dXJuIG5ld0M7XG59O1xuXG5qc29uLmFwcGVuZCA9IGZ1bmN0aW9uKGRlc3QsYykge1xuICBjID0gY2xvbmUoYyk7XG5cbiAgdmFyIGxhc3Q7XG5cbiAgaWYgKGRlc3QubGVuZ3RoICE9IDAgJiYgcGF0aE1hdGNoZXMoYy5wLCAobGFzdCA9IGRlc3RbZGVzdC5sZW5ndGggLSAxXSkucCkpIHtcbiAgICBpZiAobGFzdC5uYSAhPSBudWxsICYmIGMubmEgIT0gbnVsbCkge1xuICAgICAgZGVzdFtkZXN0Lmxlbmd0aCAtIDFdID0ge3A6IGxhc3QucCwgbmE6IGxhc3QubmEgKyBjLm5hfTtcbiAgICB9IGVsc2UgaWYgKGxhc3QubGkgIT09IHVuZGVmaW5lZCAmJiBjLmxpID09PSB1bmRlZmluZWQgJiYgYy5sZCA9PT0gbGFzdC5saSkge1xuICAgICAgLy8gaW5zZXJ0IGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGRlbGV0ZSBiZWNvbWVzIGEgbm9vcC5cbiAgICAgIGlmIChsYXN0LmxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gbGVhdmUgdGhlIGRlbGV0ZSBwYXJ0IG9mIHRoZSByZXBsYWNlXG4gICAgICAgIGRlbGV0ZSBsYXN0LmxpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzdC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxhc3Qub2QgIT09IHVuZGVmaW5lZCAmJiBsYXN0Lm9pID09PSB1bmRlZmluZWQgJiYgYy5vaSAhPT0gdW5kZWZpbmVkICYmIGMub2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGFzdC5vaSA9IGMub2k7XG4gICAgfSBlbHNlIGlmIChsYXN0Lm9pICE9PSB1bmRlZmluZWQgJiYgYy5vZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBUaGUgbGFzdCBwYXRoIGNvbXBvbmVudCBpbnNlcnRlZCBzb21ldGhpbmcgdGhhdCB0aGUgbmV3IGNvbXBvbmVudCBkZWxldGVzIChvciByZXBsYWNlcykuXG4gICAgICAvLyBKdXN0IG1lcmdlIHRoZW0uXG4gICAgICBpZiAoYy5vaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxhc3Qub2kgPSBjLm9pO1xuICAgICAgfSBlbHNlIGlmIChsYXN0Lm9kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVsZXRlIGxhc3Qub2k7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbiBpbnNlcnQgZGlyZWN0bHkgZm9sbG93ZWQgYnkgYSBkZWxldGUgdHVybnMgaW50byBhIG5vLW9wIGFuZCBjYW4gYmUgcmVtb3ZlZC5cbiAgICAgICAgZGVzdC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGMubG0gIT09IHVuZGVmaW5lZCAmJiBjLnBbYy5wLmxlbmd0aCAtIDFdID09PSBjLmxtKSB7XG4gICAgICAvLyBkb24ndCBkbyBhbnl0aGluZ1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXN0LnB1c2goYyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRlc3QubGVuZ3RoICE9IDAgJiYgcGF0aE1hdGNoZXMoYy5wLCBsYXN0LnAsIHRydWUpKSB7XG4gICAgaWYgKChjLnNpICE9IG51bGwgfHwgYy5zZCAhPSBudWxsKSAmJiAobGFzdC5zaSAhPSBudWxsIHx8IGxhc3Quc2QgIT0gbnVsbCkpIHtcbiAgICAgIC8vIFRyeSB0byBjb21wb3NlIHRoZSBzdHJpbmcgb3BzIHRvZ2V0aGVyIHVzaW5nIHRleHQncyBlcXVpdmFsZW50IG1ldGhvZHNcbiAgICAgIHZhciB0ZXh0T3AgPSBbX2NvbnZlcnRUb1RleHRDb21wb25lbnQobGFzdCldO1xuICAgICAgdGV4dC5fYXBwZW5kKHRleHRPcCwgX2NvbnZlcnRUb1RleHRDb21wb25lbnQoYykpO1xuICAgICAgXG4gICAgICAvLyBUaGVuIGNvbnZlcnQgYmFjay5cbiAgICAgIGlmICh0ZXh0T3AubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIGRlc3QucHVzaChjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXh0QyA9IHRleHRPcFswXTtcbiAgICAgICAgbGFzdC5wW2xhc3QucC5sZW5ndGggLSAxXSA9IHRleHRDLnA7XG4gICAgICAgIGlmICh0ZXh0Qy5pICE9IG51bGwpXG4gICAgICAgICAgbGFzdC5zaSA9IHRleHRDLmk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsYXN0LnNkID0gdGV4dEMuZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVzdC5wdXNoKGMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZXN0LnB1c2goYyk7XG4gIH1cbn07XG5cbmpzb24uY29tcG9zZSA9IGZ1bmN0aW9uKG9wMSxvcDIpIHtcbiAganNvbi5jaGVja1ZhbGlkT3Aob3AxKTtcbiAganNvbi5jaGVja1ZhbGlkT3Aob3AyKTtcblxuICB2YXIgbmV3T3AgPSBjbG9uZShvcDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3AyLmxlbmd0aDsgaSsrKSB7XG4gICAganNvbi5hcHBlbmQobmV3T3Asb3AyW2ldKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPcDtcbn07XG5cbmpzb24ubm9ybWFsaXplID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIG5ld09wID0gW107XG5cbiAgb3AgPSBpc0FycmF5KG9wKSA/IG9wIDogW29wXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG9wLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGMgPSBvcFtpXTtcbiAgICBpZiAoYy5wID09IG51bGwpIGMucCA9IFtdO1xuXG4gICAganNvbi5hcHBlbmQobmV3T3AsYyk7XG4gIH1cblxuICByZXR1cm4gbmV3T3A7XG59O1xuXG4vLyBSZXR1cm5zIHRydWUgaWYgYW4gb3AgYXQgb3RoZXJQYXRoIG1heSBhZmZlY3QgYW4gb3AgYXQgcGF0aFxuanNvbi5jYW5PcEFmZmVjdE9wID0gZnVuY3Rpb24ob3RoZXJQYXRoLHBhdGgpIHtcbiAgaWYgKG90aGVyUGF0aC5sZW5ndGggPT09IDApIHJldHVybiB0cnVlO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICBwYXRoID0gcGF0aC5zbGljZSgwLHBhdGgubGVuZ3RoIC0gMSk7XG4gIG90aGVyUGF0aCA9IG90aGVyUGF0aC5zbGljZSgwLG90aGVyUGF0aC5sZW5ndGggLSAxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyUGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gb3RoZXJQYXRoW2ldO1xuICAgIGlmIChpID49IHBhdGgubGVuZ3RoIHx8IHAgIT0gcGF0aFtpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gU2FtZVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vIHRyYW5zZm9ybSBjIHNvIGl0IGFwcGxpZXMgdG8gYSBkb2N1bWVudCB3aXRoIG90aGVyQyBhcHBsaWVkLlxuanNvbi50cmFuc2Zvcm1Db21wb25lbnQgPSBmdW5jdGlvbihkZXN0LCBjLCBvdGhlckMsIHR5cGUpIHtcbiAgYyA9IGNsb25lKGMpO1xuXG4gIGlmIChjLm5hICE9PSB2b2lkIDApXG4gICAgYy5wLnB1c2goMCk7XG5cbiAgaWYgKG90aGVyQy5uYSAhPT0gdm9pZCAwKVxuICAgIG90aGVyQy5wLnB1c2goMCk7XG5cbiAgdmFyIGNvbW1vbjtcbiAgaWYgKGpzb24uY2FuT3BBZmZlY3RPcChvdGhlckMucCwgYy5wKSlcbiAgICBjb21tb24gPSBvdGhlckMucC5sZW5ndGggLSAxO1xuXG4gIHZhciBjb21tb24yO1xuICBpZiAoanNvbi5jYW5PcEFmZmVjdE9wKGMucCxvdGhlckMucCkpXG4gICAgY29tbW9uMiA9IGMucC5sZW5ndGggLSAxO1xuXG4gIHZhciBjcGxlbmd0aCA9IGMucC5sZW5ndGg7XG4gIHZhciBvdGhlckNwbGVuZ3RoID0gb3RoZXJDLnAubGVuZ3RoO1xuXG4gIGlmIChjLm5hICE9PSB2b2lkIDApIC8vIGhheFxuICAgIGMucC5wb3AoKTtcblxuICBpZiAob3RoZXJDLm5hICE9PSB2b2lkIDApXG4gICAgb3RoZXJDLnAucG9wKCk7XG5cbiAgaWYgKG90aGVyQy5uYSkge1xuICAgIGlmIChjb21tb24yICE9IG51bGwgJiYgb3RoZXJDcGxlbmd0aCA+PSBjcGxlbmd0aCAmJiBvdGhlckMucFtjb21tb24yXSA9PSBjLnBbY29tbW9uMl0pIHtcbiAgICAgIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcbiAgICAgICAgb2MucCA9IG9jLnAuc2xpY2UoY3BsZW5ndGgpO1xuICAgICAgICBjLmxkID0ganNvbi5hcHBseShjbG9uZShjLmxkKSxbb2NdKTtcbiAgICAgIH0gZWxzZSBpZiAoYy5vZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBvYyA9IGNsb25lKG90aGVyQyk7XG4gICAgICAgIG9jLnAgPSBvYy5wLnNsaWNlKGNwbGVuZ3RoKTtcbiAgICAgICAgYy5vZCA9IGpzb24uYXBwbHkoY2xvbmUoYy5vZCksW29jXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGpzb24uYXBwZW5kKGRlc3QsYyk7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICAvLyBpZiBjIGlzIGRlbGV0aW5nIHNvbWV0aGluZywgYW5kIHRoYXQgdGhpbmcgaXMgY2hhbmdlZCBieSBvdGhlckMsIHdlIG5lZWQgdG9cbiAgLy8gdXBkYXRlIGMgdG8gcmVmbGVjdCB0aGF0IGNoYW5nZSBmb3IgaW52ZXJ0aWJpbGl0eS5cbiAgLy8gVE9ETyB0aGlzIGlzIHByb2JhYmx5IG5vdCBuZWVkZWQgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBpbnZlcnRpYmlsaXR5XG4gIGlmIChjb21tb24yICE9IG51bGwgJiYgb3RoZXJDcGxlbmd0aCA+IGNwbGVuZ3RoICYmIGMucFtjb21tb24yXSA9PSBvdGhlckMucFtjb21tb24yXSkge1xuICAgIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgIHZhciBvYyA9IGNsb25lKG90aGVyQyk7XG4gICAgICBvYy5wID0gb2MucC5zbGljZShjcGxlbmd0aCk7XG4gICAgICBjLmxkID0ganNvbi5hcHBseShjbG9uZShjLmxkKSxbb2NdKTtcbiAgICB9IGVsc2UgaWYgKGMub2QgIT09IHZvaWQgMCkge1xuICAgICAgdmFyIG9jID0gY2xvbmUob3RoZXJDKTtcbiAgICAgIG9jLnAgPSBvYy5wLnNsaWNlKGNwbGVuZ3RoKTtcbiAgICAgIGMub2QgPSBqc29uLmFwcGx5KGNsb25lKGMub2QpLFtvY10pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb21tb24gIT0gbnVsbCkge1xuICAgIHZhciBjb21tb25PcGVyYW5kID0gY3BsZW5ndGggPT0gb3RoZXJDcGxlbmd0aDtcblxuICAgIC8vIHRyYW5zZm9ybSBiYXNlZCBvbiBvdGhlckNcbiAgICBpZiAob3RoZXJDLm5hICE9PSB2b2lkIDApIHtcbiAgICAgIC8vIHRoaXMgY2FzZSBpcyBoYW5kbGVkIGFib3ZlIGR1ZSB0byBpY2t5IHBhdGggaGF4XG4gICAgfSBlbHNlIGlmIChvdGhlckMuc2kgIT09IHZvaWQgMCB8fCBvdGhlckMuc2QgIT09IHZvaWQgMCkge1xuICAgICAgLy8gU3RyaW5nIG9wIHZzIHN0cmluZyBvcCAtIHBhc3MgdGhyb3VnaCB0byB0ZXh0IHR5cGVcbiAgICAgIGlmIChjLnNpICE9PSB2b2lkIDAgfHwgYy5zZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghY29tbW9uT3BlcmFuZCkgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGJlIGEgc3RyaW5nPycpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgYW4gb3AgY29tcG9uZW50IHRvIGEgdGV4dCBvcCBjb21wb25lbnQgc28gd2UgY2FuIHVzZSB0aGVcbiAgICAgICAgLy8gdGV4dCB0eXBlJ3MgdHJhbnNmb3JtIGZ1bmN0aW9uXG4gICAgICAgIHZhciB0YzEgPSBfY29udmVydFRvVGV4dENvbXBvbmVudChjKTtcbiAgICAgICAgdmFyIHRjMiA9IF9jb252ZXJ0VG9UZXh0Q29tcG9uZW50KG90aGVyQyk7XG5cbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuXG4gICAgICAgIC8vIGFjdHVhbGx5IHRyYW5zZm9ybVxuICAgICAgICB0ZXh0Ll90YyhyZXMsIHRjMSwgdGMyLCB0eXBlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIC4uLi4gdGhlbiBjb252ZXJ0IHRoZSByZXN1bHQgYmFjayBpbnRvIGEgSlNPTiBvcCBhZ2Fpbi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAvLyBUZXh0IGNvbXBvbmVudFxuICAgICAgICAgIHZhciB0YyA9IHJlc1tpXTtcbiAgICAgICAgICAvLyBKU09OIGNvbXBvbmVudFxuICAgICAgICAgIHZhciBqYyA9IHtwOiBjLnAuc2xpY2UoMCwgY29tbW9uKX07XG4gICAgICAgICAgamMucC5wdXNoKHRjLnApO1xuXG4gICAgICAgICAgaWYgKHRjLmkgIT0gbnVsbCkgamMuc2kgPSB0Yy5pO1xuICAgICAgICAgIGlmICh0Yy5kICE9IG51bGwpIGpjLnNkID0gdGMuZDtcbiAgICAgICAgICBqc29uLmFwcGVuZChkZXN0LCBqYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMubGkgIT09IHZvaWQgMCAmJiBvdGhlckMubGQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKG90aGVyQy5wW2NvbW1vbl0gPT09IGMucFtjb21tb25dKSB7XG4gICAgICAgIC8vIG5vb3BcblxuICAgICAgICBpZiAoIWNvbW1vbk9wZXJhbmQpIHtcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfSBlbHNlIGlmIChjLmxkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAvLyB3ZSdyZSB0cnlpbmcgdG8gZGVsZXRlIHRoZSBzYW1lIGVsZW1lbnQsIC0+IG5vb3BcbiAgICAgICAgICBpZiAoYy5saSAhPT0gdm9pZCAwICYmIHR5cGUgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgLy8gd2UncmUgYm90aCByZXBsYWNpbmcgb25lIGVsZW1lbnQgd2l0aCBhbm90aGVyLiBvbmx5IG9uZSBjYW4gc3Vydml2ZVxuICAgICAgICAgICAgYy5sZCA9IGNsb25lKG90aGVyQy5saSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLmxpICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLmxpICE9PSB2b2lkIDAgJiYgYy5sZCA9PT0gdW5kZWZpbmVkICYmIGNvbW1vbk9wZXJhbmQgJiYgYy5wW2NvbW1vbl0gPT09IG90aGVyQy5wW2NvbW1vbl0pIHtcbiAgICAgICAgLy8gaW4gbGkgdnMuIGxpLCBsZWZ0IHdpbnMuXG4gICAgICAgIGlmICh0eXBlID09PSAncmlnaHQnKVxuICAgICAgICAgIGMucFtjb21tb25dKys7XG4gICAgICB9IGVsc2UgaWYgKG90aGVyQy5wW2NvbW1vbl0gPD0gYy5wW2NvbW1vbl0pIHtcbiAgICAgICAgYy5wW2NvbW1vbl0rKztcbiAgICAgIH1cblxuICAgICAgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIC8vIG90aGVyQyBlZGl0cyB0aGUgc2FtZSBsaXN0IHdlIGVkaXRcbiAgICAgICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA8PSBjLmxtKVxuICAgICAgICAgICAgYy5sbSsrO1xuICAgICAgICAgIC8vIGNoYW5naW5nIGMuZnJvbSBpcyBoYW5kbGVkIGFib3ZlLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMubGQgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMubG0gIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIGlmIChvdGhlckMucFtjb21tb25dID09PSBjLnBbY29tbW9uXSkge1xuICAgICAgICAgICAgLy8gdGhleSBkZWxldGVkIHRoZSB0aGluZyB3ZSdyZSB0cnlpbmcgdG8gbW92ZVxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG90aGVyQyBlZGl0cyB0aGUgc2FtZSBsaXN0IHdlIGVkaXRcbiAgICAgICAgICB2YXIgcCA9IG90aGVyQy5wW2NvbW1vbl07XG4gICAgICAgICAgdmFyIGZyb20gPSBjLnBbY29tbW9uXTtcbiAgICAgICAgICB2YXIgdG8gPSBjLmxtO1xuICAgICAgICAgIGlmIChwIDwgdG8gfHwgKHAgPT09IHRvICYmIGZyb20gPCB0bykpXG4gICAgICAgICAgICBjLmxtLS07XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3RoZXJDLnBbY29tbW9uXSA8IGMucFtjb21tb25dKSB7XG4gICAgICAgIGMucFtjb21tb25dLS07XG4gICAgICB9IGVsc2UgaWYgKG90aGVyQy5wW2NvbW1vbl0gPT09IGMucFtjb21tb25dKSB7XG4gICAgICAgIGlmIChvdGhlckNwbGVuZ3RoIDwgY3BsZW5ndGgpIHtcbiAgICAgICAgICAvLyB3ZSdyZSBiZWxvdyB0aGUgZGVsZXRlZCBlbGVtZW50LCBzbyAtPiBub29wXG4gICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoYy5sZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgaWYgKGMubGkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgLy8gd2UncmUgcmVwbGFjaW5nLCB0aGV5J3JlIGRlbGV0aW5nLiB3ZSBiZWNvbWUgYW4gaW5zZXJ0LlxuICAgICAgICAgICAgZGVsZXRlIGMubGQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHdlJ3JlIHRyeWluZyB0byBkZWxldGUgdGhlIHNhbWUgZWxlbWVudCwgLT4gbm9vcFxuICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKG90aGVyQy5sbSAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoYy5sbSAhPT0gdm9pZCAwICYmIGNwbGVuZ3RoID09PSBvdGhlckNwbGVuZ3RoKSB7XG4gICAgICAgIC8vIGxtIHZzIGxtLCBoZXJlIHdlIGdvIVxuICAgICAgICB2YXIgZnJvbSA9IGMucFtjb21tb25dO1xuICAgICAgICB2YXIgdG8gPSBjLmxtO1xuICAgICAgICB2YXIgb3RoZXJGcm9tID0gb3RoZXJDLnBbY29tbW9uXTtcbiAgICAgICAgdmFyIG90aGVyVG8gPSBvdGhlckMubG07XG4gICAgICAgIGlmIChvdGhlckZyb20gIT09IG90aGVyVG8pIHtcbiAgICAgICAgICAvLyBpZiBvdGhlckZyb20gPT0gb3RoZXJUbywgd2UgZG9uJ3QgbmVlZCB0byBjaGFuZ2Ugb3VyIG9wLlxuXG4gICAgICAgICAgLy8gd2hlcmUgZGlkIG15IHRoaW5nIGdvP1xuICAgICAgICAgIGlmIChmcm9tID09PSBvdGhlckZyb20pIHtcbiAgICAgICAgICAgIC8vIHRoZXkgbW92ZWQgaXQhIHRpZSBicmVhay5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgICAgYy5wW2NvbW1vbl0gPSBvdGhlclRvO1xuICAgICAgICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIC8vIHVnaFxuICAgICAgICAgICAgICAgIGMubG0gPSBvdGhlclRvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoZXkgbW92ZWQgYXJvdW5kIGl0XG4gICAgICAgICAgICBpZiAoZnJvbSA+IG90aGVyRnJvbSkgYy5wW2NvbW1vbl0tLTtcbiAgICAgICAgICAgIGlmIChmcm9tID4gb3RoZXJUbykgYy5wW2NvbW1vbl0rKztcbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb20gPT09IG90aGVyVG8pIHtcbiAgICAgICAgICAgICAgaWYgKG90aGVyRnJvbSA+IG90aGVyVG8pIHtcbiAgICAgICAgICAgICAgICBjLnBbY29tbW9uXSsrO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykgLy8gdWdoLCBhZ2FpblxuICAgICAgICAgICAgICAgICAgYy5sbSsrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0ZXAgMjogd2hlcmUgYW0gaSBnb2luZyB0byBwdXQgaXQ/XG4gICAgICAgICAgICBpZiAodG8gPiBvdGhlckZyb20pIHtcbiAgICAgICAgICAgICAgYy5sbS0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0byA9PT0gb3RoZXJGcm9tKSB7XG4gICAgICAgICAgICAgIGlmICh0byA+IGZyb20pXG4gICAgICAgICAgICAgICAgYy5sbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvID4gb3RoZXJUbykge1xuICAgICAgICAgICAgICBjLmxtKys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRvID09PSBvdGhlclRvKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHdlJ3JlIGJvdGggbW92aW5nIGluIHRoZSBzYW1lIGRpcmVjdGlvbiwgdGllIGJyZWFrXG4gICAgICAgICAgICAgIGlmICgob3RoZXJUbyA+IG90aGVyRnJvbSAmJiB0byA+IGZyb20pIHx8XG4gICAgICAgICAgICAgICAgICAob3RoZXJUbyA8IG90aGVyRnJvbSAmJiB0byA8IGZyb20pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdyaWdodCcpIGMubG0rKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodG8gPiBmcm9tKSBjLmxtKys7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodG8gPT09IG90aGVyRnJvbSkgYy5sbS0tO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGMubGkgIT09IHZvaWQgMCAmJiBjLmxkID09PSB1bmRlZmluZWQgJiYgY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAvLyBsaVxuICAgICAgICB2YXIgZnJvbSA9IG90aGVyQy5wW2NvbW1vbl07XG4gICAgICAgIHZhciB0byA9IG90aGVyQy5sbTtcbiAgICAgICAgcCA9IGMucFtjb21tb25dO1xuICAgICAgICBpZiAocCA+IGZyb20pIGMucFtjb21tb25dLS07XG4gICAgICAgIGlmIChwID4gdG8pIGMucFtjb21tb25dKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBsZCwgbGQrbGksIHNpLCBzZCwgbmEsIG9pLCBvZCwgb2krb2QsIGFueSBsaSBvbiBhbiBlbGVtZW50IGJlbmVhdGhcbiAgICAgICAgLy8gdGhlIGxtXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGkuZS4gdGhpbmdzIGNhcmUgYWJvdXQgd2hlcmUgdGhlaXIgaXRlbSBpcyBhZnRlciB0aGUgbW92ZS5cbiAgICAgICAgdmFyIGZyb20gPSBvdGhlckMucFtjb21tb25dO1xuICAgICAgICB2YXIgdG8gPSBvdGhlckMubG07XG4gICAgICAgIHAgPSBjLnBbY29tbW9uXTtcbiAgICAgICAgaWYgKHAgPT09IGZyb20pIHtcbiAgICAgICAgICBjLnBbY29tbW9uXSA9IHRvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChwID4gZnJvbSkgYy5wW2NvbW1vbl0tLTtcbiAgICAgICAgICBpZiAocCA+IHRvKSBjLnBbY29tbW9uXSsrO1xuICAgICAgICAgIGVsc2UgaWYgKHAgPT09IHRvICYmIGZyb20gPiB0bykgYy5wW2NvbW1vbl0rKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvdGhlckMub2kgIT09IHZvaWQgMCAmJiBvdGhlckMub2QgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMucFtjb21tb25dID09PSBvdGhlckMucFtjb21tb25dKSB7XG4gICAgICAgIGlmIChjLm9pICE9PSB2b2lkIDAgJiYgY29tbW9uT3BlcmFuZCkge1xuICAgICAgICAgIC8vIHdlIGluc2VydGVkIHdoZXJlIHNvbWVvbmUgZWxzZSByZXBsYWNlZFxuICAgICAgICAgIGlmICh0eXBlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAvLyBsZWZ0IHdpbnNcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSB3aW4sIG1ha2Ugb3VyIG9wIHJlcGxhY2Ugd2hhdCB0aGV5IGluc2VydGVkXG4gICAgICAgICAgICBjLm9kID0gb3RoZXJDLm9pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAtPiBub29wIGlmIHRoZSBvdGhlciBjb21wb25lbnQgaXMgZGVsZXRpbmcgdGhlIHNhbWUgb2JqZWN0IChvciBhbnkgcGFyZW50KVxuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvdGhlckMub2kgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGMub2kgIT09IHZvaWQgMCAmJiBjLnBbY29tbW9uXSA9PT0gb3RoZXJDLnBbY29tbW9uXSkge1xuICAgICAgICAvLyBsZWZ0IHdpbnMgaWYgd2UgdHJ5IHRvIGluc2VydCBhdCB0aGUgc2FtZSBwbGFjZVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAganNvbi5hcHBlbmQoZGVzdCx7cDogYy5wLCBvZDpvdGhlckMub2l9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3RoZXJDLm9kICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChjLnBbY29tbW9uXSA9PSBvdGhlckMucFtjb21tb25dKSB7XG4gICAgICAgIGlmICghY29tbW9uT3BlcmFuZClcbiAgICAgICAgICByZXR1cm4gZGVzdDtcbiAgICAgICAgaWYgKGMub2kgIT09IHZvaWQgMCkge1xuICAgICAgICAgIGRlbGV0ZSBjLm9kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAganNvbi5hcHBlbmQoZGVzdCxjKTtcbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgcmVxdWlyZSgnLi9oZWxwZXJzJykuX2Jvb3RzdHJhcFRyYW5zZm9ybShqc29uLCBqc29uLnRyYW5zZm9ybUNvbXBvbmVudCwganNvbi5jaGVja1ZhbGlkT3AsIGpzb24uYXBwZW5kKTtcbn0gZWxzZSB7XG4gIC8vIFRoaXMgaXMga2luZCBvZiBhd2Z1bCAtIGNvbWUgdXAgd2l0aCBhIGJldHRlciB3YXkgdG8gaG9vayB0aGlzIGhlbHBlciBjb2RlIHVwLlxuICBleHBvcnRzLl9ib290c3RyYXBUcmFuc2Zvcm0oanNvbiwganNvbi50cmFuc2Zvcm1Db21wb25lbnQsIGpzb24uY2hlY2tWYWxpZE9wLCBqc29uLmFwcGVuZCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ganNvbjtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS42LjJcbmV4cG9ydHMuX2Jvb3RzdHJhcFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHR5cGUsIHRyYW5zZm9ybUNvbXBvbmVudCwgY2hlY2tWYWxpZE9wLCBhcHBlbmQpIHtcbiAgdmFyIHRyYW5zZm9ybUNvbXBvbmVudFgsIHRyYW5zZm9ybVg7XG5cbiAgdHJhbnNmb3JtQ29tcG9uZW50WCA9IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0LCBkZXN0TGVmdCwgZGVzdFJpZ2h0KSB7XG4gICAgdHJhbnNmb3JtQ29tcG9uZW50KGRlc3RMZWZ0LCBsZWZ0LCByaWdodCwgJ2xlZnQnKTtcbiAgICByZXR1cm4gdHJhbnNmb3JtQ29tcG9uZW50KGRlc3RSaWdodCwgcmlnaHQsIGxlZnQsICdyaWdodCcpO1xuICB9O1xuICB0eXBlLnRyYW5zZm9ybVggPSB0eXBlLnRyYW5zZm9ybVggPSB0cmFuc2Zvcm1YID0gZnVuY3Rpb24obGVmdE9wLCByaWdodE9wKSB7XG4gICAgdmFyIGssIGwsIGxfLCBuZXdMZWZ0T3AsIG5ld1JpZ2h0T3AsIG5leHRDLCByLCByXywgcmlnaHRDb21wb25lbnQsIF9pLCBfaiwgX2ssIF9sLCBfbGVuLCBfbGVuMSwgX2xlbjIsIF9sZW4zLCBfcmVmLCBfcmVmMTtcblxuICAgIGNoZWNrVmFsaWRPcChsZWZ0T3ApO1xuICAgIGNoZWNrVmFsaWRPcChyaWdodE9wKTtcbiAgICBuZXdSaWdodE9wID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSByaWdodE9wLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICByaWdodENvbXBvbmVudCA9IHJpZ2h0T3BbX2ldO1xuICAgICAgbmV3TGVmdE9wID0gW107XG4gICAgICBrID0gMDtcbiAgICAgIHdoaWxlIChrIDwgbGVmdE9wLmxlbmd0aCkge1xuICAgICAgICBuZXh0QyA9IFtdO1xuICAgICAgICB0cmFuc2Zvcm1Db21wb25lbnRYKGxlZnRPcFtrXSwgcmlnaHRDb21wb25lbnQsIG5ld0xlZnRPcCwgbmV4dEMpO1xuICAgICAgICBrKys7XG4gICAgICAgIGlmIChuZXh0Qy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByaWdodENvbXBvbmVudCA9IG5leHRDWzBdO1xuICAgICAgICB9IGVsc2UgaWYgKG5leHRDLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIF9yZWYgPSBsZWZ0T3Auc2xpY2Uoayk7XG4gICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZi5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgIGwgPSBfcmVmW19qXTtcbiAgICAgICAgICAgIGFwcGVuZChuZXdMZWZ0T3AsIGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByaWdodENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3JlZjEgPSB0cmFuc2Zvcm1YKGxlZnRPcC5zbGljZShrKSwgbmV4dEMpLCBsXyA9IF9yZWYxWzBdLCByXyA9IF9yZWYxWzFdO1xuICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IGxfLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgICAgbCA9IGxfW19rXTtcbiAgICAgICAgICAgIGFwcGVuZChuZXdMZWZ0T3AsIGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKF9sID0gMCwgX2xlbjMgPSByXy5sZW5ndGg7IF9sIDwgX2xlbjM7IF9sKyspIHtcbiAgICAgICAgICAgIHIgPSByX1tfbF07XG4gICAgICAgICAgICBhcHBlbmQobmV3UmlnaHRPcCwgcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJpZ2h0Q29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJpZ2h0Q29tcG9uZW50ICE9IG51bGwpIHtcbiAgICAgICAgYXBwZW5kKG5ld1JpZ2h0T3AsIHJpZ2h0Q29tcG9uZW50KTtcbiAgICAgIH1cbiAgICAgIGxlZnRPcCA9IG5ld0xlZnRPcDtcbiAgICB9XG4gICAgcmV0dXJuIFtsZWZ0T3AsIG5ld1JpZ2h0T3BdO1xuICB9O1xuICByZXR1cm4gdHlwZS50cmFuc2Zvcm0gPSB0eXBlWyd0cmFuc2Zvcm0nXSA9IGZ1bmN0aW9uKG9wLCBvdGhlck9wLCB0eXBlKSB7XG4gICAgaWYgKCEodHlwZSA9PT0gJ2xlZnQnIHx8IHR5cGUgPT09ICdyaWdodCcpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIG11c3QgYmUgJ2xlZnQnIG9yICdyaWdodCdcIik7XG4gICAgfVxuICAgIGlmIChvdGhlck9wLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIG9wO1xuICAgIH1cbiAgICBpZiAob3AubGVuZ3RoID09PSAxICYmIG90aGVyT3AubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtQ29tcG9uZW50KFtdLCBvcFswXSwgb3RoZXJPcFswXSwgdHlwZSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnbGVmdCcpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1YKG9wLCBvdGhlck9wKVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybVgob3RoZXJPcCwgb3ApWzFdO1xuICAgIH1cbiAgfTtcbn07XG4iLCIvLyBHZW5lcmF0ZWQgYnkgQ29mZmVlU2NyaXB0IDEuNi4yXG52YXIgYXBwZW5kLCBjaGVja1ZhbGlkQ29tcG9uZW50LCBjaGVja1ZhbGlkT3AsIGludmVydENvbXBvbmVudCwgc3RySW5qZWN0LCB0ZXh0LCB0cmFuc2Zvcm1Db21wb25lbnQsIHRyYW5zZm9ybVBvc2l0aW9uO1xuXG50ZXh0ID0ge1xuICBuYW1lOiAndGV4dC1vbGQnLFxuICB1cmk6ICdodHRwOi8vc2hhcmVqcy5vcmcvdHlwZXMvdGV4dHYwJyxcbiAgY3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbnN0ckluamVjdCA9IGZ1bmN0aW9uKHMxLCBwb3MsIHMyKSB7XG4gIHJldHVybiBzMS5zbGljZSgwLCBwb3MpICsgczIgKyBzMS5zbGljZShwb3MpO1xufTtcblxuY2hlY2tWYWxpZENvbXBvbmVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgdmFyIGRfdHlwZSwgaV90eXBlO1xuXG4gIGlmICh0eXBlb2YgYy5wICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY29tcG9uZW50IG1pc3NpbmcgcG9zaXRpb24gZmllbGQnKTtcbiAgfVxuICBpX3R5cGUgPSB0eXBlb2YgYy5pO1xuICBkX3R5cGUgPSB0eXBlb2YgYy5kO1xuICBpZiAoISgoaV90eXBlID09PSAnc3RyaW5nJykgXiAoZF90eXBlID09PSAnc3RyaW5nJykpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wb25lbnQgbmVlZHMgYW4gaSBvciBkIGZpZWxkJyk7XG4gIH1cbiAgaWYgKCEoYy5wID49IDApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwb3NpdGlvbiBjYW5ub3QgYmUgbmVnYXRpdmUnKTtcbiAgfVxufTtcblxuY2hlY2tWYWxpZE9wID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIGMsIF9pLCBfbGVuO1xuXG4gIGZvciAoX2kgPSAwLCBfbGVuID0gb3AubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBjID0gb3BbX2ldO1xuICAgIGNoZWNrVmFsaWRDb21wb25lbnQoYyk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG50ZXh0LmFwcGx5ID0gZnVuY3Rpb24oc25hcHNob3QsIG9wKSB7XG4gIHZhciBjb21wb25lbnQsIGRlbGV0ZWQsIF9pLCBfbGVuO1xuXG4gIGNoZWNrVmFsaWRPcChvcCk7XG4gIGZvciAoX2kgPSAwLCBfbGVuID0gb3AubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBjb21wb25lbnQgPSBvcFtfaV07XG4gICAgaWYgKGNvbXBvbmVudC5pICE9IG51bGwpIHtcbiAgICAgIHNuYXBzaG90ID0gc3RySW5qZWN0KHNuYXBzaG90LCBjb21wb25lbnQucCwgY29tcG9uZW50LmkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGVkID0gc25hcHNob3Quc2xpY2UoY29tcG9uZW50LnAsIGNvbXBvbmVudC5wICsgY29tcG9uZW50LmQubGVuZ3RoKTtcbiAgICAgIGlmIChjb21wb25lbnQuZCAhPT0gZGVsZXRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEZWxldGUgY29tcG9uZW50ICdcIiArIGNvbXBvbmVudC5kICsgXCInIGRvZXMgbm90IG1hdGNoIGRlbGV0ZWQgdGV4dCAnXCIgKyBkZWxldGVkICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgc25hcHNob3QgPSBzbmFwc2hvdC5zbGljZSgwLCBjb21wb25lbnQucCkgKyBzbmFwc2hvdC5zbGljZShjb21wb25lbnQucCArIGNvbXBvbmVudC5kLmxlbmd0aCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzbmFwc2hvdDtcbn07XG5cbnRleHQuX2FwcGVuZCA9IGFwcGVuZCA9IGZ1bmN0aW9uKG5ld09wLCBjKSB7XG4gIHZhciBsYXN0LCBfcmVmLCBfcmVmMTtcblxuICBpZiAoYy5pID09PSAnJyB8fCBjLmQgPT09ICcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChuZXdPcC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3T3AucHVzaChjKTtcbiAgfSBlbHNlIHtcbiAgICBsYXN0ID0gbmV3T3BbbmV3T3AubGVuZ3RoIC0gMV07XG4gICAgaWYgKChsYXN0LmkgIT0gbnVsbCkgJiYgKGMuaSAhPSBudWxsKSAmJiAobGFzdC5wIDw9IChfcmVmID0gYy5wKSAmJiBfcmVmIDw9IChsYXN0LnAgKyBsYXN0LmkubGVuZ3RoKSkpIHtcbiAgICAgIHJldHVybiBuZXdPcFtuZXdPcC5sZW5ndGggLSAxXSA9IHtcbiAgICAgICAgaTogc3RySW5qZWN0KGxhc3QuaSwgYy5wIC0gbGFzdC5wLCBjLmkpLFxuICAgICAgICBwOiBsYXN0LnBcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICgobGFzdC5kICE9IG51bGwpICYmIChjLmQgIT0gbnVsbCkgJiYgKGMucCA8PSAoX3JlZjEgPSBsYXN0LnApICYmIF9yZWYxIDw9IChjLnAgKyBjLmQubGVuZ3RoKSkpIHtcbiAgICAgIHJldHVybiBuZXdPcFtuZXdPcC5sZW5ndGggLSAxXSA9IHtcbiAgICAgICAgZDogc3RySW5qZWN0KGMuZCwgbGFzdC5wIC0gYy5wLCBsYXN0LmQpLFxuICAgICAgICBwOiBjLnBcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXdPcC5wdXNoKGMpO1xuICAgIH1cbiAgfVxufTtcblxudGV4dC5jb21wb3NlID0gZnVuY3Rpb24ob3AxLCBvcDIpIHtcbiAgdmFyIGMsIG5ld09wLCBfaSwgX2xlbjtcblxuICBjaGVja1ZhbGlkT3Aob3AxKTtcbiAgY2hlY2tWYWxpZE9wKG9wMik7XG4gIG5ld09wID0gb3AxLnNsaWNlKCk7XG4gIGZvciAoX2kgPSAwLCBfbGVuID0gb3AyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgYyA9IG9wMltfaV07XG4gICAgYXBwZW5kKG5ld09wLCBjKTtcbiAgfVxuICByZXR1cm4gbmV3T3A7XG59O1xuXG50ZXh0LmNvbXByZXNzID0gZnVuY3Rpb24ob3ApIHtcbiAgcmV0dXJuIHRleHQuY29tcG9zZShbXSwgb3ApO1xufTtcblxudGV4dC5ub3JtYWxpemUgPSBmdW5jdGlvbihvcCkge1xuICB2YXIgYywgbmV3T3AsIF9pLCBfbGVuLCBfcmVmO1xuXG4gIG5ld09wID0gW107XG4gIGlmICgob3AuaSAhPSBudWxsKSB8fCAob3AucCAhPSBudWxsKSkge1xuICAgIG9wID0gW29wXTtcbiAgfVxuICBmb3IgKF9pID0gMCwgX2xlbiA9IG9wLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgYyA9IG9wW19pXTtcbiAgICBpZiAoKF9yZWYgPSBjLnApID09IG51bGwpIHtcbiAgICAgIGMucCA9IDA7XG4gICAgfVxuICAgIGFwcGVuZChuZXdPcCwgYyk7XG4gIH1cbiAgcmV0dXJuIG5ld09wO1xufTtcblxudHJhbnNmb3JtUG9zaXRpb24gPSBmdW5jdGlvbihwb3MsIGMsIGluc2VydEFmdGVyKSB7XG4gIGlmIChjLmkgIT0gbnVsbCkge1xuICAgIGlmIChjLnAgPCBwb3MgfHwgKGMucCA9PT0gcG9zICYmIGluc2VydEFmdGVyKSkge1xuICAgICAgcmV0dXJuIHBvcyArIGMuaS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwb3MgPD0gYy5wKSB7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH0gZWxzZSBpZiAocG9zIDw9IGMucCArIGMuZC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBjLnA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwb3MgLSBjLmQubGVuZ3RoO1xuICAgIH1cbiAgfVxufTtcblxudGV4dC50cmFuc2Zvcm1DdXJzb3IgPSBmdW5jdGlvbihwb3NpdGlvbiwgb3AsIHNpZGUpIHtcbiAgdmFyIGMsIGluc2VydEFmdGVyLCBfaSwgX2xlbjtcblxuICBpbnNlcnRBZnRlciA9IHNpZGUgPT09ICdyaWdodCc7XG4gIGZvciAoX2kgPSAwLCBfbGVuID0gb3AubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBjID0gb3BbX2ldO1xuICAgIHBvc2l0aW9uID0gdHJhbnNmb3JtUG9zaXRpb24ocG9zaXRpb24sIGMsIGluc2VydEFmdGVyKTtcbiAgfVxuICByZXR1cm4gcG9zaXRpb247XG59O1xuXG50ZXh0Ll90YyA9IHRyYW5zZm9ybUNvbXBvbmVudCA9IGZ1bmN0aW9uKGRlc3QsIGMsIG90aGVyQywgc2lkZSkge1xuICB2YXIgY0ludGVyc2VjdCwgaW50ZXJzZWN0RW5kLCBpbnRlcnNlY3RTdGFydCwgbmV3Qywgb3RoZXJJbnRlcnNlY3QsIHM7XG5cbiAgY2hlY2tWYWxpZE9wKFtjXSk7XG4gIGNoZWNrVmFsaWRPcChbb3RoZXJDXSk7XG4gIGlmIChjLmkgIT0gbnVsbCkge1xuICAgIGFwcGVuZChkZXN0LCB7XG4gICAgICBpOiBjLmksXG4gICAgICBwOiB0cmFuc2Zvcm1Qb3NpdGlvbihjLnAsIG90aGVyQywgc2lkZSA9PT0gJ3JpZ2h0JylcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAob3RoZXJDLmkgIT0gbnVsbCkge1xuICAgICAgcyA9IGMuZDtcbiAgICAgIGlmIChjLnAgPCBvdGhlckMucCkge1xuICAgICAgICBhcHBlbmQoZGVzdCwge1xuICAgICAgICAgIGQ6IHMuc2xpY2UoMCwgb3RoZXJDLnAgLSBjLnApLFxuICAgICAgICAgIHA6IGMucFxuICAgICAgICB9KTtcbiAgICAgICAgcyA9IHMuc2xpY2Uob3RoZXJDLnAgLSBjLnApO1xuICAgICAgfVxuICAgICAgaWYgKHMgIT09ICcnKSB7XG4gICAgICAgIGFwcGVuZChkZXN0LCB7XG4gICAgICAgICAgZDogcyxcbiAgICAgICAgICBwOiBjLnAgKyBvdGhlckMuaS5sZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjLnAgPj0gb3RoZXJDLnAgKyBvdGhlckMuZC5sZW5ndGgpIHtcbiAgICAgICAgYXBwZW5kKGRlc3QsIHtcbiAgICAgICAgICBkOiBjLmQsXG4gICAgICAgICAgcDogYy5wIC0gb3RoZXJDLmQubGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChjLnAgKyBjLmQubGVuZ3RoIDw9IG90aGVyQy5wKSB7XG4gICAgICAgIGFwcGVuZChkZXN0LCBjKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld0MgPSB7XG4gICAgICAgICAgZDogJycsXG4gICAgICAgICAgcDogYy5wXG4gICAgICAgIH07XG4gICAgICAgIGlmIChjLnAgPCBvdGhlckMucCkge1xuICAgICAgICAgIG5ld0MuZCA9IGMuZC5zbGljZSgwLCBvdGhlckMucCAtIGMucCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMucCArIGMuZC5sZW5ndGggPiBvdGhlckMucCArIG90aGVyQy5kLmxlbmd0aCkge1xuICAgICAgICAgIG5ld0MuZCArPSBjLmQuc2xpY2Uob3RoZXJDLnAgKyBvdGhlckMuZC5sZW5ndGggLSBjLnApO1xuICAgICAgICB9XG4gICAgICAgIGludGVyc2VjdFN0YXJ0ID0gTWF0aC5tYXgoYy5wLCBvdGhlckMucCk7XG4gICAgICAgIGludGVyc2VjdEVuZCA9IE1hdGgubWluKGMucCArIGMuZC5sZW5ndGgsIG90aGVyQy5wICsgb3RoZXJDLmQubGVuZ3RoKTtcbiAgICAgICAgY0ludGVyc2VjdCA9IGMuZC5zbGljZShpbnRlcnNlY3RTdGFydCAtIGMucCwgaW50ZXJzZWN0RW5kIC0gYy5wKTtcbiAgICAgICAgb3RoZXJJbnRlcnNlY3QgPSBvdGhlckMuZC5zbGljZShpbnRlcnNlY3RTdGFydCAtIG90aGVyQy5wLCBpbnRlcnNlY3RFbmQgLSBvdGhlckMucCk7XG4gICAgICAgIGlmIChjSW50ZXJzZWN0ICE9PSBvdGhlckludGVyc2VjdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGVsZXRlIG9wcyBkZWxldGUgZGlmZmVyZW50IHRleHQgaW4gdGhlIHNhbWUgcmVnaW9uIG9mIHRoZSBkb2N1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdDLmQgIT09ICcnKSB7XG4gICAgICAgICAgbmV3Qy5wID0gdHJhbnNmb3JtUG9zaXRpb24obmV3Qy5wLCBvdGhlckMpO1xuICAgICAgICAgIGFwcGVuZChkZXN0LCBuZXdDKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdDtcbn07XG5cbmludmVydENvbXBvbmVudCA9IGZ1bmN0aW9uKGMpIHtcbiAgaWYgKGMuaSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGQ6IGMuaSxcbiAgICAgIHA6IGMucFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGk6IGMuZCxcbiAgICAgIHA6IGMucFxuICAgIH07XG4gIH1cbn07XG5cbnRleHQuaW52ZXJ0ID0gZnVuY3Rpb24ob3ApIHtcbiAgdmFyIGMsIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcblxuICBfcmVmID0gb3Auc2xpY2UoKS5yZXZlcnNlKCk7XG4gIF9yZXN1bHRzID0gW107XG4gIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgIGMgPSBfcmVmW19pXTtcbiAgICBfcmVzdWx0cy5wdXNoKGludmVydENvbXBvbmVudChjKSk7XG4gIH1cbiAgcmV0dXJuIF9yZXN1bHRzO1xufTtcblxuaWYgKHR5cGVvZiByZXF1aXJlID09PSAndW5kZWZpbmVkJykge1xuICBleHBvcnRzLl9ib290c3RyYXBUcmFuc2Zvcm0odGV4dCwgdGV4dC50cmFuc2Zvcm1Db21wb25lbnQsIHRleHQuY2hlY2tWYWxpZE9wLCB0ZXh0LmFwcGVuZCk7XG59IGVsc2Uge1xuICByZXF1aXJlKCcuL2hlbHBlcnMnKS5fYm9vdHN0cmFwVHJhbnNmb3JtKHRleHQsIHRleHQudHJhbnNmb3JtQ29tcG9uZW50LCB0ZXh0LmNoZWNrVmFsaWRPcCwgdGV4dC5hcHBlbmQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRleHQ7XG4iXX0=
;